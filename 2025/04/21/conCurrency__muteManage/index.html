<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.lug.ustc.edu.cn/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-corner-indicator.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":{"valine":{"order":-1}},"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="锁的管理 多个线程同时访问共享资源会导致资源竞争，互斥锁允许多个线程安全地访问共享对象。 在单独使用互斥锁的情况下，在函数返回或者抛出异常的时候容易出现没有释放锁的情况（导致死锁），为了避免这种情况，可以使用std::lock_guard&lt;&gt;,std::unique_lock&lt;&gt;,std::scoped_lock。注意抛出异常时，这些类模板也会离开作用域，同时调用析构函数释">
<meta property="og:type" content="article">
<meta property="og:title" content="死锁与活锁">
<meta property="og:url" content="http://example.com/2025/04/21/conCurrency__muteManage/index.html">
<meta property="og:site_name" content="liujiahua&#39;s personalBlog">
<meta property="og:description" content="锁的管理 多个线程同时访问共享资源会导致资源竞争，互斥锁允许多个线程安全地访问共享对象。 在单独使用互斥锁的情况下，在函数返回或者抛出异常的时候容易出现没有释放锁的情况（导致死锁），为了避免这种情况，可以使用std::lock_guard&lt;&gt;,std::unique_lock&lt;&gt;,std::scoped_lock。注意抛出异常时，这些类模板也会离开作用域，同时调用析构函数释">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2025/04/21/conCurrency__muteManage/image-20250527174213848.png">
<meta property="og:image" content="http://example.com/2025/04/21/conCurrency__muteManage/image-20250527174249846.png">
<meta property="og:image" content="http://example.com/2025/04/21/conCurrency__muteManage/image-20250527174412746.png">
<meta property="og:image" content="http://example.com/2025/04/21/conCurrency__muteManage/image-20250527174425801.png">
<meta property="og:image" content="http://example.com/2025/04/21/conCurrency__muteManage/image-20250527180708730.png">
<meta property="article:published_time" content="2025-04-21T14:57:08.000Z">
<meta property="article:modified_time" content="2025-05-27T10:33:14.160Z">
<meta property="article:author" content="Liu Jiahua">
<meta property="article:tag" content="死锁">
<meta property="article:tag" content="活锁">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2025/04/21/conCurrency__muteManage/image-20250527174213848.png">

<link rel="canonical" href="http://example.com/2025/04/21/conCurrency__muteManage/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>死锁与活锁 | liujiahua's personalBlog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">liujiahua's personalBlog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/04/21/conCurrency__muteManage/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Liu Jiahua">
      <meta itemprop="description" content="无限进步">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liujiahua's personalBlog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          死锁与活锁
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-04-21 22:57:08" itemprop="dateCreated datePublished" datetime="2025-04-21T22:57:08+08:00">2025-04-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-05-27 18:33:14" itemprop="dateModified" datetime="2025-05-27T18:33:14+08:00">2025-05-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">并发</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B9%B6%E5%8F%91/%E9%94%81%E7%AE%A1%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">锁管理</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2025/04/21/conCurrency__muteManage/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2025/04/21/conCurrency__muteManage/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>30k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>27 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="锁的管理"><a href="#锁的管理" class="headerlink" title="锁的管理"></a>锁的管理</h2><blockquote>
<p>多个线程同时访问共享资源会导致资源竞争，<strong>互斥锁允许多个线程安全地访问共享对象。</strong></p>
<p>在单独使用互斥锁的情况下，在函数返回或者抛出异常的时候容易出现没有释放锁的情况（<strong>导致死锁</strong>），为了避免这种情况，可以使用<code>std::lock_guard&lt;&gt;</code>,<code>std::unique_lock&lt;&gt;</code>,<code>std::scoped_lock</code>。注意抛出异常时，这些类模板也会离开作用域，同时调用析构函数释放管理的锁。</p>
</blockquote>
<h3 id="lock-guard"><a href="#lock-guard" class="headerlink" title="lock_guard"></a>lock_guard</h3><p><code>lock_guard</code>简化后代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Mutex&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lock_guard</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">lock_guard</span><span class="params">(Mutex &amp;m)</span> : m_mutex(m)</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">lock_guard</span>(Mutex&amp; m, <span class="type">adopt_lock_t</span>) <span class="keyword">noexcept</span> : <span class="built_in">m_mutex</span>(m)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">lock_guard</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">lock_guard</span>(<span class="type">const</span> lock_guard &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    lock_guard &amp;<span class="keyword">operator</span>=(<span class="type">const</span> lock_guard &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutex &amp;m_mutex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>adopt_lock_t</code>：第二个参数是一个标签类型（tag type），名为 <code>adopt_lock_t</code>，通常通过 <code>std::adopt_lock</code> 常量传入。</p>
</li>
<li><p>lock_guard的拷贝构造和拷贝赋值函数都被删除了，<font color='red'>所以其是不能被拷贝的</font>。</p>
</li>
</ul>
<p>其中<code>lock_guard(Mutex &amp;m, adopt_lock_t) </code>函数<strong>作用及用法</strong>如下：</p>
<ul>
<li><p>这个构造函数假设调用者<strong>已经获得了互斥量的所有权</strong>（已经调用<code>mutex.lock()</code>）</p>
</li>
<li><p><code>lock_guard</code> 不会再去锁定互斥量，而是<strong>直接”接管”已锁定互斥量的所有权</strong></p>
</li>
<li><p>当 <code>lock_guard</code> 对象销毁时，它会自动解锁互斥量</p>
</li>
</ul>
<p><strong>示例用法</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">std::mutex m1, m2;</span><br><span class="line"><span class="comment">// 首先锁定两个互斥量</span></span><br><span class="line">std::<span class="built_in">lock</span>(m1, m2);  <span class="comment">// 以避免死锁的方式锁定多个互斥量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后使用 adopt_lock 来管理它们</span></span><br><span class="line"><span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard1</span><span class="params">(m1, std::adopt_lock)</span></span>;</span><br><span class="line"><span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard2</span><span class="params">(m2, std::adopt_lock)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在可以安全地访问由m1和m2保护的共享资源</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 当guard1和guard2离开作用域时，互斥量会自动解锁</span></span><br></pre></td></tr></table></figure>



<h3 id="unique-lock"><a href="#unique-lock" class="headerlink" title="unique_lock"></a>unique_lock</h3><p>unique_lock更加灵活，<strong>创建时可以不锁定互斥量。</strong></p>
<blockquote>
<p><code>std::unique_lock lock(m_mutex, std::defer_lock);</code>第二个参数传递<code>std::defer_lock</code></p>
</blockquote>
<h4 id="简化版本源码"><a href="#简化版本源码" class="headerlink" title="简化版本源码"></a>简化版本源码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 延迟锁定标签</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">defer_lock_t</span> &#123; <span class="function"><span class="keyword">explicit</span> <span class="title">defer_lock_t</span><span class="params">()</span> </span>= <span class="keyword">default</span>; &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">try_to_lock_t</span> &#123; <span class="function"><span class="keyword">explicit</span> <span class="title">try_to_lock_t</span><span class="params">()</span> </span>= <span class="keyword">default</span>; &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">adopt_lock_t</span> &#123; <span class="function"><span class="keyword">explicit</span> <span class="title">adopt_lock_t</span><span class="params">()</span> </span>= <span class="keyword">default</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">defer_lock_t</span> defer_lock&#123;&#125;;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">try_to_lock_t</span> try_to_lock&#123;&#125;;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">adopt_lock_t</span> adopt_lock&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Mutex&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">unique_lock</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> Mutex mutex_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    mutex_type* m_mutex;</span><br><span class="line">    <span class="type">bool</span> m_owns;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">unique_lock</span>() <span class="keyword">noexcept</span> : <span class="built_in">m_mutex</span>(<span class="literal">nullptr</span>), <span class="built_in">m_owns</span>(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁定构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">unique_lock</span><span class="params">(mutex_type&amp; m)</span> : m_mutex(&amp;m), m_owns(false) &#123;</span></span><br><span class="line">        <span class="built_in">lock</span>();</span><br><span class="line">        m_owns = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 延迟锁定构造函数</span></span><br><span class="line">    <span class="built_in">unique_lock</span>(mutex_type&amp; m, <span class="type">defer_lock_t</span>) <span class="keyword">noexcept</span> </span><br><span class="line">        : <span class="built_in">m_mutex</span>(&amp;m), <span class="built_in">m_owns</span>(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试锁定构造函数</span></span><br><span class="line">    <span class="built_in">unique_lock</span>(mutex_type&amp; m, <span class="type">try_to_lock_t</span>) </span><br><span class="line">        : <span class="built_in">m_mutex</span>(&amp;m), <span class="built_in">m_owns</span>(m_mutex-&gt;<span class="built_in">try_lock</span>()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 采用已有锁构造函数</span></span><br><span class="line">    <span class="built_in">unique_lock</span>(mutex_type&amp; m, <span class="type">adopt_lock_t</span>) </span><br><span class="line">        : <span class="built_in">m_mutex</span>(&amp;m), <span class="built_in">m_owns</span>(<span class="literal">true</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 超时锁定构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Rep, <span class="keyword">typename</span> Period&gt;</span></span><br><span class="line"><span class="function">    <span class="title">unique_lock</span><span class="params">(mutex_type&amp; m, <span class="type">const</span> std::chrono::duration&lt;Rep, Period&gt;&amp; timeout_duration)</span></span></span><br><span class="line"><span class="function">        : m_mutex(&amp;m), m_owns(m_mutex-&gt;try_lock_for(timeout_duration)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Clock, <span class="keyword">typename</span> Duration&gt;</span></span><br><span class="line"><span class="function">    <span class="title">unique_lock</span><span class="params">(mutex_type&amp; m, <span class="type">const</span> std::chrono::time_point&lt;Clock, Duration&gt;&amp; timeout_time)</span></span></span><br><span class="line"><span class="function">        : m_mutex(&amp;m), m_owns(m_mutex-&gt;try_lock_until(timeout_time)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">unique_lock</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_owns) &#123;</span><br><span class="line">            <span class="built_in">unlock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">unique_lock</span>(unique_lock&amp;&amp; other) <span class="keyword">noexcept</span> </span><br><span class="line">        : <span class="built_in">m_mutex</span>(other.m_mutex), <span class="built_in">m_owns</span>(other.m_owns) &#123;</span><br><span class="line">        other.m_mutex = <span class="literal">nullptr</span>;</span><br><span class="line">        other.m_owns = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动赋值操作符</span></span><br><span class="line">    unique_lock&amp; <span class="keyword">operator</span>=(unique_lock&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_owns) &#123;</span><br><span class="line">                <span class="built_in">unlock</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            m_mutex = other.m_mutex;</span><br><span class="line">            m_owns = other.m_owns;</span><br><span class="line">            other.m_mutex = <span class="literal">nullptr</span>;</span><br><span class="line">            other.m_owns = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁用拷贝构造和拷贝赋值</span></span><br><span class="line">    <span class="built_in">unique_lock</span>(<span class="type">const</span> unique_lock&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    unique_lock&amp; <span class="keyword">operator</span>=(<span class="type">const</span> unique_lock&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁定操作</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_mutex == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">system_error</span>(std::<span class="built_in">make_error_code</span>(std::errc::operation_not_permitted));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (m_owns) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">system_error</span>(std::<span class="built_in">make_error_code</span>(std::errc::resource_deadlock_would_occur));</span><br><span class="line">        &#125;</span><br><span class="line">        m_mutex-&gt;<span class="built_in">lock</span>();</span><br><span class="line">        m_owns = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试锁定</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">try_lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_mutex == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">system_error</span>(std::<span class="built_in">make_error_code</span>(std::errc::operation_not_permitted));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (m_owns) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">system_error</span>(std::<span class="built_in">make_error_code</span>(std::errc::resource_deadlock_would_occur));</span><br><span class="line">        &#125;</span><br><span class="line">        m_owns = m_mutex-&gt;<span class="built_in">try_lock</span>();</span><br><span class="line">        <span class="keyword">return</span> m_owns;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 超时尝试锁定</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Rep, <span class="keyword">typename</span> Period&gt;</span></span><br><span class="line"><span class="function">    <span class="type">bool</span> <span class="title">try_lock_for</span><span class="params">(<span class="type">const</span> std::chrono::duration&lt;Rep, Period&gt;&amp; timeout_duration)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_mutex == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">system_error</span>(std::<span class="built_in">make_error_code</span>(std::errc::operation_not_permitted));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (m_owns) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">system_error</span>(std::<span class="built_in">make_error_code</span>(std::errc::resource_deadlock_would_occur));</span><br><span class="line">        &#125;</span><br><span class="line">        m_owns = m_mutex-&gt;<span class="built_in">try_lock_for</span>(timeout_duration);</span><br><span class="line">        <span class="keyword">return</span> m_owns;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Clock, <span class="keyword">typename</span> Duration&gt;</span></span><br><span class="line"><span class="function">    <span class="type">bool</span> <span class="title">try_lock_until</span><span class="params">(<span class="type">const</span> std::chrono::time_point&lt;Clock, Duration&gt;&amp; timeout_time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_mutex == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">system_error</span>(std::<span class="built_in">make_error_code</span>(std::errc::operation_not_permitted));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (m_owns) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">system_error</span>(std::<span class="built_in">make_error_code</span>(std::errc::resource_deadlock_would_occur));</span><br><span class="line">        &#125;</span><br><span class="line">        m_owns = m_mutex-&gt;<span class="built_in">try_lock_until</span>(timeout_time);</span><br><span class="line">        <span class="keyword">return</span> m_owns;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解锁操作</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!m_owns) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">system_error</span>(std::<span class="built_in">make_error_code</span>(std::errc::operation_not_permitted));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (m_mutex) &#123;</span><br><span class="line">            m_mutex-&gt;<span class="built_in">unlock</span>();</span><br><span class="line">            m_owns = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换操作</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(unique_lock&amp; other)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        std::<span class="built_in">swap</span>(m_mutex, other.m_mutex);</span><br><span class="line">        std::<span class="built_in">swap</span>(m_owns, other.m_owns);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放互斥锁的所有权</span></span><br><span class="line">    <span class="function">mutex_type* <span class="title">release</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        mutex_type* ret = m_mutex;</span><br><span class="line">        m_mutex = <span class="literal">nullptr</span>;</span><br><span class="line">        m_owns = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询状态</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">owns_lock</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_owns;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换为bool (检查是否拥有锁)</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">owns_lock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取关联的互斥锁</span></span><br><span class="line">    <span class="function">mutex_type* <span class="title">mutex</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_mutex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换函数的非成员版本</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Mutex&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(unique_lock&lt;Mutex&gt;&amp; lhs, unique_lock&lt;Mutex&gt;&amp; rhs)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    lhs.<span class="built_in">swap</span>(rhs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace std</span></span><br></pre></td></tr></table></figure>



<h4 id="timed-mutex"><a href="#timed-mutex" class="headerlink" title="timed_mutex"></a>timed_mutex</h4><p><strong>可以使用timed_mutex来实现有等待时长的互斥</strong>。该类的成员函数有：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lock</span><br><span class="line">try_lock</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面两个是timed_mutex相比mutex特有的，返回true表示获得mutex所有权，注意返回false不意味着mutex当前被其它线程占用</span></span><br><span class="line">try_lock_for <span class="comment">//在指定时长内获得mutex的所有权</span></span><br><span class="line">try_lock_until  <span class="comment">//在指定时刻前获得mutex的所有权</span></span><br><span class="line"></span><br><span class="line">unlock</span><br></pre></td></tr></table></figure>



<p>注意unique_lock也有一个同名的<code>try_lock_for</code>方法，<strong>不过他本质上是在调用他所管理的互斥量的相应方法</strong>。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p><strong>一个unique_lock和timed_mutex使用的示例</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TryDemo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 设置unique_lock构造时不锁定互斥量</span></span><br><span class="line">            <span class="function">std::unique_lock <span class="title">lock</span><span class="params">(m_mutex, std::defer_lock)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (lock.<span class="built_in">try_lock_for</span>(<span class="number">100</span>ms)) <span class="comment">// 在100ms内获得锁</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function">std::lock_guard <span class="title">guard</span><span class="params">(cout_mutex)</span></span>;</span><br><span class="line">                <span class="comment">// 如果在100ms内获得锁就打印成功</span></span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; <span class="string">&quot;成功;\n&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                std::lock_guard <span class="built_in">guard</span>(cout_mutex);</span><br><span class="line">                <span class="comment">// 如果在100ms内没有获得锁就打印失败</span></span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; <span class="string">&quot;失败;\n&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">100</span>ms);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 定义一个timed_mutex类型的互斥量</span></span><br><span class="line">    std::timed_mutex m_mutex;</span><br><span class="line">    std::mutex cout_mutex;</span><br><span class="line">    <span class="type">int</span> m_count = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> TryDemo demo;</span><br><span class="line"> <span class="keyword">auto</span> print = [](TryDemo &amp;demo) &#123;</span><br><span class="line">     demo.<span class="built_in">print</span>();</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="comment">//std::ref是对demo取引用，使得两个线程都能访问这个栈区变量</span></span><br><span class="line"> <span class="function">std::thread <span class="title">thr1</span><span class="params">(print, std::ref(demo))</span></span>;  </span><br><span class="line"> <span class="function">std::thread <span class="title">thr2</span><span class="params">(print, std::ref(demo))</span></span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//结果</span><br><span class="line">[2]成功；</span><br><span class="line">[3]失败；</span><br><span class="line">[2]成功；</span><br><span class="line">[3]失败；</span><br><span class="line">[2]成功；</span><br><span class="line">[3]失败；</span><br><span class="line">[2]成功；</span><br><span class="line">[3]失败；</span><br><span class="line">[2]成功；</span><br><span class="line">[2]成功；</span><br></pre></td></tr></table></figure>





<h2 id="死锁与活锁"><a href="#死锁与活锁" class="headerlink" title="死锁与活锁"></a>死锁与活锁</h2><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h4 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h4><p>在多线程编程中，我们为了防止多线程竞争共享资源而导致数据错乱，都会在操作共享资源之前加上互斥锁，只有成功获得到锁的线程，才能操作共享资源，获取不到锁的线程就只能等待，直到锁被释放。</p>
<p>那么，当两个线程为了保护两个不同的共享资源而使用了两个互斥锁，那么这两个互斥锁应用不当的时候，可能会造成<strong>两个线程都在等待对方释放锁</strong>，在没有外力的作用下，这些线程会一直相互等待，就没办法继续运行，这种情况就是发生了<strong>死锁</strong>。</p>
<p>死锁只有<strong>同时满足</strong>以下四个条件才会发生：</p>
<ul>
<li>互斥条件；</li>
<li>持有并等待条件；</li>
<li>不可剥夺条件；</li>
<li>环路等待条件；</li>
</ul>
<h5 id="互斥条件"><a href="#互斥条件" class="headerlink" title="互斥条件"></a>互斥条件</h5><p>互斥条件是指<strong>多个线程不能同时使用同一个资源</strong>。</p>
<p>比如下图，如果线程 A 已经持有的资源，不能再同时被线程 B 持有，如果线程 B 请求获取线程 A 已经占用的资源，那线程 B 只能等待，直到线程 A 释放了资源。</p>
<style>.goqdopsjjnpu{zoom:67%;}</style><img src="/2025/04/21/conCurrency__muteManage/image-20250527174213848.png" class="goqdopsjjnpu" alt="image-20250527174213848">

<h5 id="持有并等待条件"><a href="#持有并等待条件" class="headerlink" title="持有并等待条件"></a>持有并等待条件</h5><p>持有并等待条件是指，当线程 A 已经持有了资源 1，又想申请资源 2，而资源 2 已经被线程 C 持有了，所以线程 A 就会处于等待状态，但是<strong>线程 A 在等待资源 2 的同时并不会释放自己已经持有的资源 1</strong>。</p>
<style>.psbcsylmpcfu{zoom: 67%;}</style><img src="/2025/04/21/conCurrency__muteManage/image-20250527174249846.png" class="psbcsylmpcfu" alt="image-20250527174249846">

<h5 id="不可剥夺条件"><a href="#不可剥夺条件" class="headerlink" title="不可剥夺条件"></a>不可剥夺条件</h5><p>不可剥夺条件是指，当线程已经持有了资源 ，<strong>在自己使用完之前不能被其他线程获取</strong>，线程 B 如果也想使用此资源，则只能在线程 A 使用完并释放后才能获取。</p>
<style>.ufhbumkjoxbs{zoom:67%;}</style><img src="/2025/04/21/conCurrency__muteManage/image-20250527174412746.png" class="ufhbumkjoxbs" alt="image-20250527174412746">

<h5 id="环路等待条件"><a href="#环路等待条件" class="headerlink" title="环路等待条件"></a>环路等待条件</h5><p>环路等待条件指的是，在死锁发生的时候，<strong>两个线程获取资源的顺序构成了环形链</strong>。</p>
<p>比如，线程 A 已经持有资源 2，而想请求资源 1， 线程 B 已经获取了资源 1，而想请求资源 2，这就形成资源请求等待的环形图。</p>
<style>.cebyfbbhhfkc{zoom:67%;}</style><img src="/2025/04/21/conCurrency__muteManage/image-20250527174425801.png" class="cebyfbbhhfkc" alt="image-20250527174425801">

<h4 id="死锁产生实例"><a href="#死锁产生实例" class="headerlink" title="死锁产生实例"></a>死锁产生实例</h4><h5 id="1-在单一线程中多次锁定同一互斥量"><a href="#1-在单一线程中多次锁定同一互斥量" class="headerlink" title="(1)在单一线程中多次锁定同一互斥量"></a>(1)在单一线程中多次锁定同一互斥量</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DoSomething</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        count *= <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">func2</span>();</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 已经锁定了互斥量，这里又进行锁定</span></span><br><span class="line">        <span class="function">std::lock_guard <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::mutex mtx;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面这一个线程func1会永远进行阻塞状态。</p>
<blockquote>
<p>上述问题可以将互斥量<code>mutex</code>改为<code>recursive_mutex</code>解决。当再次锁定互斥量时，不会进入阻塞，<strong>直接到调用相同数量unlock之后才会完全释放该互斥量。</strong></p>
</blockquote>
<h5 id="2-同时对多个互斥量进行获取和释放时，由于获得和释放的顺序不同，也可能导致死锁"><a href="#2-同时对多个互斥量进行获取和释放时，由于获得和释放的顺序不同，也可能导致死锁" class="headerlink" title="(2)同时对多个互斥量进行获取和释放时，由于获得和释放的顺序不同，也可能导致死锁"></a>(2)同时对多个互斥量进行获取和释放时，由于获得和释放的顺序不同，也可能导致死锁</h5><p>如下示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DemoClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard <span class="title">lock1</span><span class="params">(mtx1)</span></span>;</span><br><span class="line">        <span class="function">std::lock_guard <span class="title">lock2</span><span class="params">(cout_mtx)</span></span>;</span><br><span class="line">        count++;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[func1]Count=&quot;</span> &lt;&lt; count &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">1</span>ms);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard <span class="title">lock1</span><span class="params">(cout_mtx)</span></span>;</span><br><span class="line">        <span class="function">std::lock_guard <span class="title">lock2</span><span class="params">(mtx1)</span></span>;</span><br><span class="line">        count--;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[func2]Count=&quot;</span> &lt;&lt; count &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">1</span>ms);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % <span class="number">2</span>)</span><br><span class="line">                <span class="built_in">func2</span>();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">func1</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::mutex mtx1;</span><br><span class="line">    std::mutex cout_mtx;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果主函数创建了如下两个线程，则会出现死锁。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DemoClass demo;</span><br><span class="line">    <span class="type">int</span> N1 = <span class="number">10000</span>;</span><br><span class="line">    <span class="type">int</span> N2 = <span class="number">10001</span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">thr1</span><span class="params">(DemoClass::calc, &amp;demo, N1)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">thr2</span><span class="params">(DemoClass::calc, &amp;demo, N2)</span></span>;</span><br><span class="line">    </span><br><span class="line">    thr<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    thr<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color='mediumseagreen'>产生死锁的可能原因</font>：</p>
<blockquote>
<p>线程1先锁定互斥量mtx1(或者说获得互斥锁mtx1)，线程2先获得互斥量cout_mtx，当线程1要获得互斥量cout_mtx时，由于线程2正在占用该锁，<strong>所以其会阻塞等待线程2释放锁</strong>，而如果此时线程2又要获得锁mtx1，<strong>那么其也会阻塞等待，最终导致死锁。</strong></p>
</blockquote>
<h3 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h3><blockquote>
<p><strong>活锁概念</strong>：</p>
<p>活锁是指多个线程虽然没有阻塞，<strong>但由于不断地相互让步或重试，导致程序无法继续向前推进的状态</strong>。</p>
</blockquote>
<p>对应前面死锁产生实例2可以使用<code>timed_mutex</code>,因为其<code>try_lock_for</code>函数有个<strong>超时机制</strong>，未在设定时间内获得互斥锁就会返回false</p>
<p>如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其它省略</span></span><br><span class="line"><span class="comment">//线程1入口函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="function">std::unique_lock <span class="title">lock1</span><span class="params">(mtx1, std::defer_lock)</span></span>;</span><br><span class="line">        <span class="function">std::unique_lock <span class="title">lock2</span><span class="params">(cout_mtx, std::defer_lock)</span></span>; <span class="comment">//不在构造的时候锁定互斥量</span></span><br><span class="line">        <span class="comment">//采用try_lock_for来避免死锁，没有获得锁就返回false</span></span><br><span class="line">        <span class="keyword">if</span> (!lock<span class="number">1.</span><span class="built_in">try_lock_for</span>(<span class="number">100</span>ms)) &#123;</span><br><span class="line">       		<span class="keyword">continue</span>;	  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!lock<span class="number">2.</span><span class="built_in">try_lock_for</span>(<span class="number">100</span>ms)) &#123;</span><br><span class="line">       		<span class="keyword">continue</span>;		  	   </span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">        std::cout &lt;&lt;  <span class="string">&quot;[func1]Count=&quot;</span> &lt;&lt; count &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线程2入口函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="function">std::unique_lock <span class="title">lock1</span><span class="params">(cout_mtx, std::defer_lock)</span></span>;</span><br><span class="line">        <span class="function">std::unique_lock <span class="title">lock2</span><span class="params">(mtx1, std::defer_lock)</span></span>; <span class="comment">//不在构造的时候锁定互斥量 	</span></span><br><span class="line">        <span class="comment">//采用try_lock_for来避免死锁，没有获得锁就返回false</span></span><br><span class="line">        <span class="keyword">if</span> (!lock<span class="number">1.</span><span class="built_in">try_lock_for</span>(<span class="number">100</span>ms)) &#123;</span><br><span class="line">       		<span class="keyword">continue</span>;	  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!lock<span class="number">2.</span><span class="built_in">try_lock_for</span>(<span class="number">100</span>ms)) &#123;</span><br><span class="line">       		<span class="keyword">continue</span>;		  	   </span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[func2]Count=&quot;</span> &lt;&lt; count &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行上述代码，<strong>程序输出结果会十分慢</strong>，实际上述会出现”活锁”现象</p>
<h4 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h4><style>.wqlpmjkoxlxz{zoom: 67%;}</style><img src="/2025/04/21/conCurrency__muteManage/image-20250527180708730.png" class="wqlpmjkoxlxz" alt="image-20250527180708730">

<p>如上图所示，<strong>活锁的发生可以为</strong>：线程1先获得mtx1，线程2获得cout_mtx，如果线程1又想获得mtx1，线程2也想获得cout_mtx，由于双方需要的锁都被占用，那么两者就会同时释放自己的锁，然后两者再次重新获取锁，反复循环。</p>
<p><strong>活锁就像是现实中打电话一样，听到忙音都挂断，又再次打电话，又听到忙音</strong></p>
<h3 id="死锁-活锁的解决办法"><a href="#死锁-活锁的解决办法" class="headerlink" title="死锁&#x2F;活锁的解决办法"></a>死锁&#x2F;活锁的解决办法</h3><h4 id="操作系统是如何解决死锁问题的-思路上-？"><a href="#操作系统是如何解决死锁问题的-思路上-？" class="headerlink" title="操作系统是如何解决死锁问题的(思路上)？"></a>操作系统是如何解决死锁问题的(思路上)？</h4><h5 id="1-死锁预防-Deadlock-Prevention"><a href="#1-死锁预防-Deadlock-Prevention" class="headerlink" title="1.死锁预防 (Deadlock Prevention)"></a>1.死锁预防 (Deadlock Prevention)</h5><p>死锁预防是通过在系统设计阶段施加某些限制，以确保死锁发生的四个必要条件中至少有一个不成立，从而从根本上防止死锁的发生。</p>
<ul>
<li><strong>破坏互斥条件</strong>：如果能允许多个进程共享资源，那么死锁就不会发生。但这对于许多资源（如打印机、CPU寄存器）来说是不可能的。对于可以共享的资源（如只读文件），则可以避免因互斥而产生的死锁。</li>
<li>破坏占有并等待条件：<ul>
<li><strong>一次性分配所有资源</strong>：要求进程在开始执行前一次性申请它所需要的所有资源。只有当系统能满足其所有资源请求时，才分配给它。否则，进程就等待。这种策略简单，但资源利用率低，可能导致进程饥饿。</li>
<li><strong>只允许在没有占有资源时申请资源</strong>：进程在申请新的资源前，必须先释放它当前占有的所有资源。然后，它可以一次性申请所有需要的资源。这种策略也会降低资源利用率和系统吞吐量。</li>
</ul>
</li>
<li>破坏不可剥夺条件：<ul>
<li><strong>允许剥夺</strong>：如果一个进程占有某些资源，并且它又申请新的资源而不能立即得到满足时，该进程必须释放它当前占有的所有资源。或者，操作系统可以剥夺其他进程占有的资源分配给当前进程。这种策略实现起来比较复杂，且可能导致前一个进程的工作白费。</li>
</ul>
</li>
<li>破坏循环等待条件：<ul>
<li><strong>资源有序分配法</strong>：将系统中的所有资源类型进行线性排序，并赋予不同的序号。规定每个进程在申请资源时，必须按照序号递增的顺序进行。这样可以防止形成环路。这种策略会限制新设备的增加，并且对用户编程时如何申请资源也造成了不便。</li>
</ul>
</li>
</ul>
<p>死锁预防的优点是可以从根本上杜绝死锁的发生，但其限制条件往往过于严格，会导致系统资源利用率和并发度降低。</p>
<h5 id="2-死锁避免-Deadlock-Avoidance"><a href="#2-死锁避免-Deadlock-Avoidance" class="headerlink" title="2. 死锁避免 (Deadlock Avoidance)"></a>2. 死锁避免 (Deadlock Avoidance)</h5><p>死锁避免是在资源动态分配过程中，通过某种算法来判断本次资源分配是否会导致系统进入****不安全状态*<em><strong>，如果会，则不予分配，让进程等待。如果系统总是处于</strong>安全状态</em>*，那么就不会发生死锁。安全状态是指系统能按某种进程推进顺序，为每个进程分配其所需的资源，直至完成。</p>
<p>最著名的死锁避免算法是**银行家算法 (Banker’s Algorithm)**。该算法要求进程在运行前声明其所需各种资源的最大量。当进程请求一组资源时，系统会进行如下检查：</p>
<ol>
<li>如果请求的资源数量超过了该进程声明的最大需求量，则拒绝请求。</li>
<li>如果请求的资源数量超过了系统当前可用的资源数量，则该进程必须等待。</li>
<li>如果系统有足够的资源满足该进程的请求，系统会假定分配这些资源给该进程，并检查分配后系统是否仍处于安全状态。如果是，则正式分配资源；否则，该进程必须等待。</li>
</ol>
<p>银行家算法的优点是可以获得比死锁预防更高的资源利用率和系统并发度，但它需要预知进程对资源的最大需求量，这在很多情况下难以实现，且算法的开销较大。</p>
<h6 id="补充：银行家算法"><a href="#补充：银行家算法" class="headerlink" title="补充：银行家算法"></a>补充：银行家算法</h6><blockquote>
<ul>
<li><strong>银行家算法的核心思想</strong></li>
</ul>
<p>银行家算法是由Dijkstra提出的避免死锁的经典算法，其核心思想类似于银行放贷：</p>
<ol>
<li><strong>保守策略</strong>：只有当确定贷款能够收回时才放贷</li>
<li><strong>安全状态</strong>：系统能找到一个安全序列，使所有进程都能顺利完成</li>
<li><strong>试探性分配</strong>：在实际分配前先模拟分配，检查是否安全</li>
</ol>
<ul>
<li><p><strong>算法的关键数据结构</strong></p>
</li>
<li><p>**Available[j]**：系统中第j类资源的可用实例数</p>
</li>
<li><p>**Max[i,j]**：进程Pi对第j类资源的最大需求</p>
</li>
<li><p>**Allocation[i,j]**：进程Pi当前已分配的第j类资源数</p>
</li>
<li><p>**Need[i,j]**：进程Pi还需要的第j类资源数 (Need &#x3D; Max - Allocation)</p>
</li>
<li><p><strong>算法执行步骤</strong></p>
<ul>
<li><p>安全性检查算法：</p>
<ol>
<li><p>初始化工作向量Work &#x3D; Available</p>
<p>2.寻找满足条件的进程i：Finish[i] &#x3D; false 且 Need[i] ≤ Work</p>
<p>3.如果找到，则模拟该进程完成：Work &#x3D; Work + Allocation[i]，Finish[i] &#x3D; true</p>
</li>
<li><p>重复步骤2-3，直到所有进程完成或找不到满足条件的进程</p>
</li>
<li><p>如果所有进程都完成，则系统处于安全状态</p>
</li>
</ol>
</li>
<li><p>资源请求处理：</p>
<p>   1.<strong>合法性检查</strong>：Request[i] ≤ Need[i]</p>
<ol start="2">
<li><p><strong>可用性检查</strong>：Request[i] ≤ Available</p>
</li>
<li><p><strong>试探性分配</strong>：临时修改系统状态</p>
</li>
<li><p><strong>安全性检查</strong>：调用安全性算法</p>
<p>5.<strong>决策</strong>：安全则正式分配，否则回滚并拒绝</p>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BankersAlgorithm</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> processes;    <span class="comment">// 进程数量</span></span><br><span class="line">    <span class="type">int</span> resources;    <span class="comment">// 资源类型数量</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 核心数据结构</span></span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; allocation;    <span class="comment">// 分配矩阵：已分配给各进程的资源数量</span></span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; max_need;      <span class="comment">// 最大需求矩阵：各进程声明的最大资源需求</span></span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; need;          <span class="comment">// 需求矩阵：各进程还需要的资源数量</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; available;                  <span class="comment">// 可用资源向量：系统当前可用的各类资源数量</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数：初始化银行家算法</span></span><br><span class="line">    <span class="built_in">BankersAlgorithm</span>(<span class="type">int</span> p, <span class="type">int</span> r) : <span class="built_in">processes</span>(p), <span class="built_in">resources</span>(r) &#123;</span><br><span class="line">        <span class="comment">// 初始化所有矩阵和向量的大小</span></span><br><span class="line">        allocation.<span class="built_in">resize</span>(processes, std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(resources, <span class="number">0</span>));</span><br><span class="line">        max_need.<span class="built_in">resize</span>(processes, std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(resources, <span class="number">0</span>));</span><br><span class="line">        need.<span class="built_in">resize</span>(processes, std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(resources, <span class="number">0</span>));</span><br><span class="line">        available.<span class="built_in">resize</span>(resources, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置系统的可用资源</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setAvailable</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; avail)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (avail.<span class="built_in">size</span>() != resources) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;错误：可用资源数量与资源类型数不匹配！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        available = avail;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;系统可用资源已设置&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置进程的最大资源需求</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setMaxNeed</span><span class="params">(<span class="type">int</span> process_id, <span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; max)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (process_id &gt;= processes || max.<span class="built_in">size</span>() != resources) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;错误：进程ID或资源数量不正确！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        max_need[process_id] = max;</span><br><span class="line">        <span class="comment">// 同时更新需求矩阵 Need = Max - Allocation</span></span><br><span class="line">        <span class="built_in">updateNeed</span>(process_id);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;进程 P&quot;</span> &lt;&lt; process_id &lt;&lt; <span class="string">&quot; 的最大需求已设置&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置进程当前已分配的资源</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setAllocation</span><span class="params">(<span class="type">int</span> process_id, <span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; alloc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (process_id &gt;= processes || alloc.<span class="built_in">size</span>() != resources) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;错误：进程ID或资源数量不正确！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        allocation[process_id] = alloc;</span><br><span class="line">        <span class="comment">// 同时更新需求矩阵</span></span><br><span class="line">        <span class="built_in">updateNeed</span>(process_id);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;进程 P&quot;</span> &lt;&lt; process_id &lt;&lt; <span class="string">&quot; 的已分配资源已设置&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新某个进程的需求矩阵</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updateNeed</span><span class="params">(<span class="type">int</span> process_id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; resources; j++) &#123;</span><br><span class="line">            need[process_id][j] = max_need[process_id][j] - allocation[process_id][j];</span><br><span class="line">            <span class="comment">// 确保需求不为负数</span></span><br><span class="line">            <span class="keyword">if</span> (need[process_id][j] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;警告：进程 P&quot;</span> &lt;&lt; process_id </span><br><span class="line">                         &lt;&lt; <span class="string">&quot; 的分配超过了最大需求！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                need[process_id][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查系统当前状态是否安全</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 工作向量，表示当前可用资源（会在算法中动态变化）</span></span><br><span class="line">        std::vector&lt;<span class="type">int</span>&gt; work = available;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 完成标志数组，标记各进程是否已完成</span></span><br><span class="line">        <span class="function">std::vector&lt;<span class="type">bool</span>&gt; <span class="title">finish</span><span class="params">(processes, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 安全序列，记录进程完成的顺序</span></span><br><span class="line">        std::vector&lt;<span class="type">int</span>&gt; safe_sequence;</span><br><span class="line">        </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;\n=== 开始安全性检查 ===&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;初始可用资源: &quot;</span>;</span><br><span class="line">        <span class="built_in">printVector</span>(work);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 重复查找可以完成的进程，直到所有进程完成或无法找到</span></span><br><span class="line">        <span class="type">int</span> completed = <span class="number">0</span>;  <span class="comment">// 已完成的进程数</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (completed &lt; processes) &#123;</span><br><span class="line">            <span class="type">bool</span> found = <span class="literal">false</span>;  <span class="comment">// 标记本轮是否找到可完成的进程</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 遍历所有进程，寻找可以完成的进程</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; processes; i++) &#123;</span><br><span class="line">                <span class="comment">// 如果进程i未完成，检查其需求是否可以满足</span></span><br><span class="line">                <span class="keyword">if</span> (!finish[i] &amp;&amp; <span class="built_in">canAllocate</span>(i, work)) &#123;</span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;\n进程 P&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; 可以完成:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;  当前需求: &quot;</span>;</span><br><span class="line">                    <span class="built_in">printVector</span>(need[i]);</span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;  可用资源: &quot;</span>;</span><br><span class="line">                    <span class="built_in">printVector</span>(work);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 模拟进程完成，释放其占用的所有资源</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; resources; j++) &#123;</span><br><span class="line">                        work[j] += allocation[i][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;  完成后可用资源: &quot;</span>;</span><br><span class="line">                    <span class="built_in">printVector</span>(work);</span><br><span class="line">                    </span><br><span class="line">                    finish[i] = <span class="literal">true</span>;</span><br><span class="line">                    safe_sequence.<span class="built_in">push_back</span>(i);</span><br><span class="line">                    completed++;</span><br><span class="line">                    found = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;  <span class="comment">// 找到一个就重新开始，确保按顺序处理</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果本轮没有找到任何可完成的进程，说明系统处于不安全状态</span></span><br><span class="line">            <span class="keyword">if</span> (!found) &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;\n系统处于不安全状态！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;未完成的进程：&quot;</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; processes; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!finish[i]) &#123;</span><br><span class="line">                        std::cout &lt;&lt; <span class="string">&quot; P&quot;</span> &lt;&lt; i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                std::cout &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 所有进程都能完成，系统安全</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;\n系统处于安全状态！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;安全序列: &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; safe_sequence.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;P&quot;</span> &lt;&lt; safe_sequence[i];</span><br><span class="line">            <span class="keyword">if</span> (i &lt; safe_sequence.<span class="built_in">size</span>() - <span class="number">1</span>) std::cout &lt;&lt; <span class="string">&quot; -&gt; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查某个进程的需求是否可以被当前可用资源满足</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canAllocate</span><span class="params">(<span class="type">int</span> process_id, <span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; available_resources)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; resources; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (need[process_id][j] &gt; available_resources[j]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理进程的资源请求</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">requestResources</span><span class="params">(<span class="type">int</span> process_id, <span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; request)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;\n=== 处理进程 P&quot;</span> &lt;&lt; process_id &lt;&lt; <span class="string">&quot; 的资源请求 ===&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;请求资源: &quot;</span>;</span><br><span class="line">        <span class="built_in">printVector</span>(request);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第一步：检查请求是否合法</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isValidRequest</span>(process_id, request)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第二步：检查系统是否有足够的可用资源</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; resources; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (request[j] &gt; available[j]) &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;拒绝请求：系统可用资源不足&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;请求资源 &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; request[j] </span><br><span class="line">                         &lt;&lt; <span class="string">&quot;, 可用: &quot;</span> &lt;&lt; available[j] &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第三步：试探性分配资源</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;开始试探性分配...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 保存当前状态，以便回滚</span></span><br><span class="line">        <span class="keyword">auto</span> old_allocation = allocation[process_id];</span><br><span class="line">        <span class="keyword">auto</span> old_need = need[process_id];</span><br><span class="line">        <span class="keyword">auto</span> old_available = available;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 执行试探性分配</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; resources; j++) &#123;</span><br><span class="line">            allocation[process_id][j] += request[j];  <span class="comment">// 增加分配</span></span><br><span class="line">            need[process_id][j] -= request[j];        <span class="comment">// 减少需求</span></span><br><span class="line">            available[j] -= request[j];               <span class="comment">// 减少可用资源</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;试探性分配后的状态:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">printSystemState</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第四步：检查分配后系统是否安全</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isSafe</span>()) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;\n资源请求被批准！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 系统不安全，回滚状态</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;\n资源请求被拒绝！（会导致不安全状态）&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            allocation[process_id] = old_allocation;</span><br><span class="line">            need[process_id] = old_need;</span><br><span class="line">            available = old_available;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查资源请求是否合法</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidRequest</span><span class="params">(<span class="type">int</span> process_id, <span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; request)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检查进程ID是否有效</span></span><br><span class="line">        <span class="keyword">if</span> (process_id &gt;= processes) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;错误：无效的进程ID&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查请求向量大小是否正确</span></span><br><span class="line">        <span class="keyword">if</span> (request.<span class="built_in">size</span>() != resources) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;错误：请求向量大小不正确&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查请求是否超过进程的需求</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; resources; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (request[j] &gt; need[process_id][j]) &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;错误：请求超过了进程的需求&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;资源 &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&quot; - 请求: &quot;</span> &lt;&lt; request[j] </span><br><span class="line">                         &lt;&lt; <span class="string">&quot;, 需求: &quot;</span> &lt;&lt; need[process_id][j] &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 检查请求是否为负数</span></span><br><span class="line">            <span class="keyword">if</span> (request[j] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;错误：请求资源数量不能为负数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放进程的资源（进程完成时调用）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">releaseResources</span><span class="params">(<span class="type">int</span> process_id)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;\n=== 进程 P&quot;</span> &lt;&lt; process_id &lt;&lt; <span class="string">&quot; 完成，释放资源 ===&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;释放的资源: &quot;</span>;</span><br><span class="line">        <span class="built_in">printVector</span>(allocation[process_id]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将分配的资源加回到可用资源中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; resources; j++) &#123;</span><br><span class="line">            available[j] += allocation[process_id][j];</span><br><span class="line">            allocation[process_id][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 重新计算需求（应该变为最大需求）</span></span><br><span class="line">        <span class="built_in">updateNeed</span>(process_id);</span><br><span class="line">        </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;释放后可用资源: &quot;</span>;</span><br><span class="line">        <span class="built_in">printVector</span>(available);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印系统当前状态</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printSystemState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;\n=== 系统当前状态 ===&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 打印表头</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;进程\t&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; resources; j++) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;分配&quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; resources; j++) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;最大&quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; resources; j++) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;需求&quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 打印分隔线</span></span><br><span class="line">        std::cout &lt;&lt; std::<span class="built_in">string</span>(<span class="number">8</span> + resources * <span class="number">24</span>, <span class="string">&#x27;-&#x27;</span>) &lt;&lt; std::endl;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 打印各进程的状态</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; processes; i++) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;P&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 分配矩阵</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; resources; j++) &#123;</span><br><span class="line">                std::cout &lt;&lt; allocation[i][j] &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 最大需求矩阵</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; resources; j++) &#123;</span><br><span class="line">                std::cout &lt;&lt; max_need[i][j] &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 需求矩阵</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; resources; j++) &#123;</span><br><span class="line">                std::cout &lt;&lt; need[i][j] &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            std::cout &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 打印可用资源</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;\n可用资源: &quot;</span>;</span><br><span class="line">        <span class="built_in">printVector</span>(available);</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 辅助函数：打印向量</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            std::cout &lt;&lt; vec[i];</span><br><span class="line">            <span class="keyword">if</span> (i &lt; vec.<span class="built_in">size</span>() - <span class="number">1</span>) std::cout &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 演示程序</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;=== 银行家算法演示程序 ===&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建银行家算法实例</span></span><br><span class="line">    <span class="comment">// 假设有5个进程，3种资源（A, B, C）</span></span><br><span class="line">    <span class="function">BankersAlgorithm <span class="title">banker</span><span class="params">(<span class="number">5</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置系统可用资源</span></span><br><span class="line">    banker.<span class="built_in">setAvailable</span>(&#123;<span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>&#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置各进程的最大需求</span></span><br><span class="line">    banker.<span class="built_in">setMaxNeed</span>(<span class="number">0</span>, &#123;<span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>&#125;);</span><br><span class="line">    banker.<span class="built_in">setMaxNeed</span>(<span class="number">1</span>, &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>&#125;);</span><br><span class="line">    banker.<span class="built_in">setMaxNeed</span>(<span class="number">2</span>, &#123;<span class="number">9</span>, <span class="number">0</span>, <span class="number">2</span>&#125;);</span><br><span class="line">    banker.<span class="built_in">setMaxNeed</span>(<span class="number">3</span>, &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>&#125;);</span><br><span class="line">    banker.<span class="built_in">setMaxNeed</span>(<span class="number">4</span>, &#123;<span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>&#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置各进程当前已分配的资源</span></span><br><span class="line">    banker.<span class="built_in">setAllocation</span>(<span class="number">0</span>, &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    banker.<span class="built_in">setAllocation</span>(<span class="number">1</span>, &#123;<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    banker.<span class="built_in">setAllocation</span>(<span class="number">2</span>, &#123;<span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>&#125;);</span><br><span class="line">    banker.<span class="built_in">setAllocation</span>(<span class="number">3</span>, &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>&#125;);</span><br><span class="line">    banker.<span class="built_in">setAllocation</span>(<span class="number">4</span>, &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>&#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印初始系统状态</span></span><br><span class="line">    banker.<span class="built_in">printSystemState</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查初始状态是否安全</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n=== 检查初始状态安全性 ===&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">if</span> (banker.<span class="built_in">isSafe</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;初始状态安全，系统可以正常运行&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;初始状态不安全，需要调整资源分配&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 模拟资源请求</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n=== 模拟资源请求场景 ===&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 场景1：进程P1请求资源(1,0,2)</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n场景1：进程P1请求资源(1,0,2)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">if</span> (banker.<span class="built_in">requestResources</span>(<span class="number">1</span>, &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>&#125;)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;请求成功！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        banker.<span class="built_in">printSystemState</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 场景2：进程P4请求资源(3,3,0)</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n场景2：进程P4请求资源(3,3,0)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">if</span> (banker.<span class="built_in">requestResources</span>(<span class="number">4</span>, &#123;<span class="number">3</span>, <span class="number">3</span>, <span class="number">0</span>&#125;)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;请求成功！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        banker.<span class="built_in">printSystemState</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 场景3：进程P0请求资源(0,2,0)</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n场景3：进程P0请求资源(0,2,0)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">if</span> (banker.<span class="built_in">requestResources</span>(<span class="number">0</span>, &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>&#125;)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;请求成功！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        banker.<span class="built_in">printSystemState</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="3-死锁检测-Deadlock-Detection"><a href="#3-死锁检测-Deadlock-Detection" class="headerlink" title="3. 死锁检测 (Deadlock Detection)"></a>3. 死锁检测 (Deadlock Detection)</h5><p>死锁检测允许系统在运行过程中发生死锁，但操作系统会周期性地检测系统中是否存在死锁。如果检测到死锁，则采取措施加以解除。</p>
<p>检测死锁通常通过<strong>资源分配图 (Resource-Allocation Graph)</strong> 或类似的机制进行。资源分配图是一个有向图，其中的节点表示进程和资源，有向边表示资源的请求和分配关系。如果图中存在环路，则表示系统中可能存在死锁。</p>
<p>检测算法的执行频率是一个需要权衡的问题：</p>
<ul>
<li><strong>频繁检测</strong>：可以尽早发现死锁，但会增加系统开销。</li>
<li><strong>检测间隔较长</strong>：系统开销小，但可能导致死锁长时间存在，影响系统性能，甚至导致更多进程卷入死锁。</li>
</ul>
<h5 id="4-死锁解除-Deadlock-Recovery"><a href="#4-死锁解除-Deadlock-Recovery" class="headerlink" title="4. 死锁解除 (Deadlock Recovery)"></a>4. 死锁解除 (Deadlock Recovery)</h5><p>当检测到系统中存在死锁时，就需要采取措施来解除死锁。常用的死锁解除方法有：</p>
<ul>
<li>**剥夺资源 (Resource Preemption)**：从一个或多个死锁进程中剥夺一部分资源，并将这些资源分配给其他死锁进程，以打破循环等待。选择哪个进程被剥夺资源以及剥夺哪些资源需要考虑代价最小化原则（如进程优先级、已执行时间、已占用资源等）。被剥夺资源的进程通常需要回滚到之前的某个安全状态。</li>
<li>终止进程 (Process Termination)：<ul>
<li><strong>终止所有死锁进程</strong>：这种方法简单粗暴，但代价很大，因为所有死锁进程的工作都将丢失。</li>
<li><strong>逐个终止死锁进程</strong>：按照某种顺序（如优先级、已执行时间等）逐个终止死锁进程，直到死锁解除。这种方法的代价相对较小，但确定终止顺序比较复杂。</li>
</ul>
</li>
<li>**进程回滚 (Rollback)**：将一个或多个死锁进程回滚到足以避免死锁的某个较早的状态（检查点）。这需要系统保存进程的检查点信息，开销较大。</li>
</ul>
<h4 id="实际应用中的解决方案"><a href="#实际应用中的解决方案" class="headerlink" title="实际应用中的解决方案"></a>实际应用中的解决方案</h4><h5 id="1-多线程函数都按按顺序获取锁"><a href="#1-多线程函数都按按顺序获取锁" class="headerlink" title="(1)多线程函数都按按顺序获取锁"></a>(1)多线程函数都按按顺序获取锁</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock1</span><span class="params">(cout_mtx)</span></span>;</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock2</span><span class="params">(mtx1)</span></span>;</span><br><span class="line">    count++;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Count=&quot;</span> &lt;&lt; count &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock1</span><span class="params">(cout_mtx)</span></span>;</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock2</span><span class="params">(mtx1)</span></span>;</span><br><span class="line">    count--;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Count=&quot;</span> &lt;&lt; count &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是最简单有效的方法</p>
<h5 id="2-）使用标准库提供的std-lock函数或者scoped-lock类。"><a href="#2-）使用标准库提供的std-lock函数或者scoped-lock类。" class="headerlink" title="(2)）使用标准库提供的std::lock函数或者scoped_lock类。"></a>(2)）使用标准库提供的<code>std::lock</code>函数或者<code>scoped_lock</code>类。</h5><ul>
<li><code>std::lock</code>函数</li>
</ul>
<blockquote>
<p>注意<code>std::lock</code>是标准库函数，<code>mutex.lock()</code>锁定互斥量，是这个互斥量的函数</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> L1, <span class="keyword">typename</span> L2, <span class="keyword">typename</span>... L3&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">(L1 &amp;l1, L2 &amp;l2, L3&amp;... _l3)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... MutexTypes&gt; <span class="keyword">class</span> <span class="title class_">scoped_lock</span>;</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    std::<span class="built_in">lock</span>(mtx1, cout_mtx);</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock1</span><span class="params">(mtx1, std::adopt_lock)</span></span>;</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock2</span><span class="params">(cout_mtx, std::adopt_lock)</span></span>;</span><br><span class="line">    count++;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Count=&quot;</span> &lt;&lt; count &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 互斥量传入顺序并不相同，但还是可以避免死锁问题(这里std::lock的算法起作用)，注意这个lock和互斥量的lock不是一个函数</span></span><br><span class="line">    std::<span class="built_in">lock</span>(cout_mtx, mtx1);</span><br><span class="line"></span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock1</span><span class="params">(cout_mtx, std::adopt_lock)</span></span>;</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock2</span><span class="params">(mtx1, std::adopt_lock)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>以下为gcc中lock的实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> L1, <span class="keyword">typename</span> L2, <span class="keyword">typename</span>... L3&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">(L1 &amp;l1, L2 &amp;l2, L3 &amp;...l3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(is_same_v&lt;L1, L2&gt; &amp;&amp; (is_same_v&lt;L1, L3&gt; &amp;&amp; ...))</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">2</span> + <span class="keyword">sizeof</span>...(L3);</span><br><span class="line">        unique_lock&lt;L1&gt; locks[] = &#123;</span><br><span class="line">            &#123;l1, defer_lock&#125;, &#123;l2, defer_lock&#125;, &#123;l3, defer_lock&#125;...&#125;;</span><br><span class="line">        <span class="type">int</span> first = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            locks[first].<span class="built_in">lock</span>(); <span class="comment">//实际上是unique_lock再调用管理的互斥量的lock函数 </span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; N; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">const</span> <span class="type">int</span> idx = (first + j) % N;</span><br><span class="line">                <span class="keyword">if</span> (!locks[idx].<span class="built_in">try_lock</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> k = j; k != <span class="number">0</span>; --k)</span><br><span class="line">                        locks[(first + k - <span class="number">1</span>) % N].<span class="built_in">unlock</span>();</span><br><span class="line">                    first = idx;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!locks[first].<span class="built_in">owns_lock</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;l : locks)</span><br><span class="line">            l.<span class="built_in">release</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        __detail::<span class="built_in">lock_impl</span>(i, @, l1, l2, l<span class="number">3.</span>..);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color='cornflowerblue'>实现原理</font>：任何一个线程阻塞等待获取资源时，<strong>都不能获取资源(如果已经获取资源，必须将其获取的资源全部释放再进入阻塞等待状态)</strong></p>
<ul>
<li><code>std::scoped_lock</code>模板类</li>
</ul>
<p><code>scoped_lock</code>类模板在构造时，会自动调用<code>std::lock</code>函数，析构时会释放这些资源。<code>scoped_lock</code>可以同时管理多个资源(互斥量)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">       <span class="comment">//使用scoped_lock来避免死锁，更加简洁</span></span><br><span class="line">        <span class="function">std::scoped_lock <span class="title">lock</span><span class="params">(mtx1, cout_mtx)</span></span>; <span class="comment">//scoped_lock构造函数可以传递多个互斥量</span></span><br><span class="line">        count++;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;count=&quot;</span> &lt;&lt; count &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">       <span class="comment">//使用scoped_lock来避免死锁，更加简洁</span></span><br><span class="line">        <span class="comment">//不用在乎锁的顺序，一样可以避免死锁</span></span><br><span class="line">        <span class="function">std::scoped_lock <span class="title">lock</span><span class="params">(cout_mtx, mtx1)</span></span>;</span><br><span class="line">      count *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="死锁检测工具"><a href="#死锁检测工具" class="headerlink" title="死锁检测工具"></a>死锁检测工具</h3><h4 id="Java-中的死锁检测工具"><a href="#Java-中的死锁检测工具" class="headerlink" title="Java 中的死锁检测工具"></a>Java 中的死锁检测工具</h4><p>Java 平台提供了多种内置和外部工具来帮助检测和诊断死锁：</p>
<ol>
<li><p><strong><code>jstack</code> (JDK 命令行工具):</strong></p>
<ul>
<li><strong>功能:</strong> <code>jstack</code> 用于打印指定 Java 进程的 Java 线程堆栈跟踪信息。当发生死锁时，<code>jstack</code> 能够自动检测到 Java 级别的死锁（通常是由于 <code>synchronized</code> 关键字或 <code>java.util.concurrent.locks.Lock</code> 实现的锁引起的），并在输出的末尾明确指出 “Found one Java-level deadlock:”，并列出涉及的线程、它们持有的锁以及正在等待的锁。</li>
<li><strong>使用:</strong> 在命令行中执行 <code>jstack &lt;pid&gt;</code>，其中 <code>&lt;pid&gt;</code> 是 Java 进程的 ID。</li>
</ul>
</li>
<li><p><strong><code>ThreadMXBean</code> (JMX API):</strong></p>
<ul>
<li><p>功能:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.management.ThreadMXBean</span><br></pre></td></tr></table></figure>

<p> 是 Java 管理扩展 (JMX) 的一部分，它提供了一系列用于监控和管理线程的方法。其中：</p>
<ul>
<li><code>findDeadlockedThreads()</code>: 检测因对象监视器（<code>synchronized</code> 块）和可拥有同步器（如 <code>ReentrantLock</code>）而产生的死锁。</li>
<li><code>findMonitorDeadlockedThreads()</code>: (在较早版本中，主要关注对象监视器) 检测因对象监视器（<code>synchronized</code> 块）而产生的死锁。</li>
</ul>
</li>
<li><p><strong>使用:</strong> 可以在 Java 代码中通过 <code>ManagementFactory.getThreadMXBean()</code> 获取 <code>ThreadMXBean</code> 实例，并调用上述方法来以编程方式检测死锁。这对于构建自定义的监控和报警系统非常有用。</p>
</li>
</ul>
</li>
<li><p><strong>IDE 调试器 (如 IntelliJ IDEA, Eclipse, NetBeans):</strong></p>
<ul>
<li><strong>功能:</strong> 现代 Java IDE 的调试器通常集成了强大的线程分析功能。在调试会话中，你可以暂停程序，查看所有线程的状态、它们当前持有的锁以及正在等待的锁。一些 IDE 甚至可以直接高亮显示死锁的线程。</li>
<li><strong>使用:</strong> 在 IDE 中启动调试会话，当程序出现挂起或疑似死锁时，暂停程序并检查线程视图。</li>
</ul>
</li>
<li><p><strong>可视化分析工具 (Profilers，如 JProfiler, YourKit, VisualVM):</strong></p>
<ul>
<li><strong>功能:</strong> 这些专业的分析工具提供了更深入的运行时分析能力，包括线程活动监控、锁竞争分析、死锁检测等。它们通常以图形化的方式展示线程状态和锁信息，使得定位死锁更加直观。VisualVM 是 JDK 自带的工具，功能相对基础但非常实用。</li>
<li><strong>使用:</strong> 将分析工具附加到正在运行的 Java 进程，或在启动时通过 JVMTI 代理启动程序。然后通过工具的 UI 界面进行监控和分析。</li>
</ul>
</li>
</ol>
<h4 id="C-中的死锁检测工具"><a href="#C-中的死锁检测工具" class="headerlink" title="C++ 中的死锁检测工具"></a>C++ 中的死锁检测工具</h4><p>C++ 本身语言标准层面并没有像 Java 那样内置统一的死锁检测机制，主要依赖于操作系统提供的调试工具、第三方库以及编译器的特性：</p>
<ol>
<li><p><strong>调试器 (GDB, LLDB, Visual Studio Debugger):</strong></p>
<ul>
<li><p>功能:</p>
<p> 这些是通用的程序调试器，对于 C++ 死锁检测至关重要。当程序因死锁而挂起时，可以附加调试器到进程，检查：</p>
<ul>
<li>各个线程的状态（是否阻塞）。</li>
<li>每个线程的调用栈（了解线程在哪个锁上等待）。</li>
<li>锁对象的状态（如果锁的实现允许并且有调试符号）。 通过手动分析这些信息，可以推断出是否存在循环等待。</li>
</ul>
</li>
<li><p><strong>使用:</strong> 在程序挂起时，使用 <code>gdb &lt;program_name&gt; &lt;pid&gt;</code> (或 <code>attach &lt;pid&gt;</code> 在 GDB 内部)，然后使用 <code>info threads</code>，<code>thread apply all bt</code> 等命令分析。Visual Studio Debugger 提供了图形化的线程和调用栈窗口。</p>
</li>
</ul>
</li>
<li><p><strong>Valgrind (Helgrind &#x2F; DRD):</strong></p>
<ul>
<li><p>功能:</p>
<p> Valgrind 是一个强大的动态分析工具框架。</p>
<ul>
<li><strong>Helgrind:</strong> 是 Valgrind 的一个工具，专门用于检测多线程程序中的同步错误，包括锁的错误使用、潜在的死锁和数据竞争。它通过跟踪锁的获取和释放顺序来发现问题。</li>
<li><strong>DRD (Data Race Detector):</strong> 另一个 Valgrind 工具，也能够检测数据竞争和与锁相关的错误，有时也能间接帮助发现死锁的条件。</li>
</ul>
</li>
<li><p><strong>使用:</strong> 使用 <code>-g</code> 选项编译你的 C++ 程序以包含调试信息，然后通过 Valgrind 运行程序：<code>valgrind --tool=helgrind ./your_program</code>。Helgrind 会报告它发现的潜在问题。</p>
</li>
</ul>
</li>
<li><p><strong>Thread Sanitizer (TSan):</strong></p>
<ul>
<li><strong>功能:</strong> TSan 是一个由 Google 开发的运行时错误检测器，集成在 GCC (从 4.8 版本开始) 和 Clang (从 3.2 版本开始) 编译器中。它能够高效地检测数据竞争和死锁。TSan 通过在编译时插桩代码来监控内存访问和同步操作。</li>
<li><strong>使用:</strong> 在编译和链接 C++ 程序时，添加特定的编译器标志，例如对于 GCC&#x2F;Clang：<code>g++ -fsanitize=thread -g your_program.cpp -o your_program</code>。然后正常运行程序，如果 TSan 检测到死锁，它会输出详细的报告。</li>
</ul>
</li>
<li><p><strong>静态分析工具 (如 Clang Static Analyzer, Coverity, PVS-Studio):</strong></p>
<ul>
<li><strong>功能:</strong> 一些高级的静态分析工具能够通过分析源代码来检测潜在的死锁风险，例如不一致的锁获取顺序。它们在不运行程序的情况下进行检查。</li>
<li><strong>使用:</strong> 根据具体工具的说明配置和运行分析。</li>
</ul>
</li>
<li><p><strong>特定库的机制:</strong></p>
<ul>
<li>一些 C++ 并发库或框架可能提供自己的调试或死锁检测机制。例如，某些 actor 模型的实现可能有工具来检测 actor 之间的消息传递死锁。</li>
</ul>
</li>
</ol>
<h4 id="Linux-的-lockdep"><a href="#Linux-的-lockdep" class="headerlink" title="Linux 的 lockdep"></a>Linux 的 lockdep</h4><p><strong>Lockdep (Lock Dependency Validator)</strong> 是 Linux 内核中的一个运行时锁验证系统。它的主要目的是在内核开发和测试期间检测潜在的锁依赖问题，从而预防死锁的发生。</p>
<ul>
<li><strong>功能:</strong><ol>
<li><strong>跟踪锁的获取顺序:</strong> Lockdep 会记录每个锁被获取和释放的历史，以及在持有某个锁的同时尝试获取其他锁的情况。</li>
<li><strong>检测不一致的锁顺序 (Lock Inversions):</strong> 如果内核代码在不同的路径上以不同的顺序获取同一组锁，这可能导致死锁。Lockdep 可以检测到这种不一致的锁获取顺序。例如，如果一个路径是先锁 A 再锁 B，而另一个路径是先锁 B 再锁 A，Lockdep 会发出警告。</li>
<li><strong>检测锁的递归获取 (Incorrect Recursive Locking):</strong> 对于非递归锁，如果同一个上下文尝试多次获取同一个锁实例，Lockdep 会报告错误。</li>
<li><strong>锁的上下文验证:</strong> 它可以检查锁是否在正确的上下文（例如，中断上下文、进程上下文）中被获取和释放。</li>
<li><strong>死锁模拟:</strong> Lockdep 通过维护一个锁依赖图来工作。当一个新的锁依赖关系被添加时，它会检查这个新关系是否会在图中形成环路。如果形成环路，就意味着存在潜在的死锁场景。</li>
</ol>
</li>
<li><strong>如何工作 (简要):</strong><ul>
<li>当一个锁被获取时，Lockdep 会记录当前持有的其他锁。</li>
<li>它为每个锁类（lock class，通常基于锁的初始化站点）维护获取这个锁之前已经持有哪些其他锁类的信息。</li>
<li>如果发现一个锁类 A 在被获取时，之前已经持有锁类 B；而在另一个执行路径上，锁类 B 在被获取时，之前已经持有锁类 A，这就形成了一个潜在的死锁场景（ABBA 死锁），Lockdep 会打印详细的警告信息，包括相关的代码路径。</li>
</ul>
</li>
<li><strong>目的和用途:</strong><ul>
<li><strong>内核开发和调试:</strong> Lockdep 主要供内核开发者使用，帮助他们在开发过程中尽早发现和修复锁相关的 bug，从而提高内核的稳定性和可靠性。</li>
<li><strong>运行时验证:</strong> 它在内核运行时进行检查，而不是静态分析，因此可以捕获实际执行路径中出现的问题。</li>
<li><strong>预防性:</strong> 虽然它报告的是“潜在”死锁，但这些警告通常指示了设计上的缺陷，如果不修复，在特定条件下很可能导致真正的死锁。</li>
</ul>
</li>
<li><strong>如何启用和使用:</strong><ul>
<li>Lockdep 通常通过内核配置选项 (如 <code>CONFIG_LOCKDEP</code>, <code>CONFIG_PROVE_LOCKING</code>) 来启用。</li>
<li>当它检测到问题时，会在内核日志 (dmesg) 中打印详细的警告信息，包括锁的名称、获取顺序、涉及的函数调用栈等，帮助开发者定位问题。</li>
</ul>
</li>
</ul>
<p>总结来说，Java 提供了相对标准化的内置死锁检测工具，而 C++ 更依赖于通用的调试器、第三方动态&#x2F;静态分析工具以及编译器的支持。Linux 的 lockdep 则是内核层面的一个强大的运行时锁依赖验证器，专注于预防和检测内核代码中的死锁问题。</p>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/%E6%AD%BB%E9%94%81/" rel="tag"><i class="fa fa-tag"></i> 死锁</a>
              <a href="/tags/%E6%B4%BB%E9%94%81/" rel="tag"><i class="fa fa-tag"></i> 活锁</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2025/04/21/concurrentServer__Net_IOmodel/" rel="prev" title="网络IO复用模型">
      <i class="fa fa-chevron-left"></i> 网络IO复用模型
    </a></div>
      <div class="post-nav-item">
    <a href="/2025/04/22/linux_bashCmd02/" rel="next" title="linux命令02">
      linux命令02 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E7%AE%A1%E7%90%86"><span class="nav-number">1.</span> <span class="nav-text">锁的管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#lock-guard"><span class="nav-number">1.1.</span> <span class="nav-text">lock_guard</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#unique-lock"><span class="nav-number">1.2.</span> <span class="nav-text">unique_lock</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%80%E5%8C%96%E7%89%88%E6%9C%AC%E6%BA%90%E7%A0%81"><span class="nav-number">1.2.1.</span> <span class="nav-text">简化版本源码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#timed-mutex"><span class="nav-number">1.2.2.</span> <span class="nav-text">timed_mutex</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.2.3.</span> <span class="nav-text">示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E4%B8%8E%E6%B4%BB%E9%94%81"><span class="nav-number">2.</span> <span class="nav-text">死锁与活锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">2.1.</span> <span class="nav-text">死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">2.1.1.</span> <span class="nav-text">死锁的概念</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E6%9D%A1%E4%BB%B6"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">互斥条件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%81%E6%9C%89%E5%B9%B6%E7%AD%89%E5%BE%85%E6%9D%A1%E4%BB%B6"><span class="nav-number">2.1.1.2.</span> <span class="nav-text">持有并等待条件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E5%89%A5%E5%A4%BA%E6%9D%A1%E4%BB%B6"><span class="nav-number">2.1.1.3.</span> <span class="nav-text">不可剥夺条件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%8E%AF%E8%B7%AF%E7%AD%89%E5%BE%85%E6%9D%A1%E4%BB%B6"><span class="nav-number">2.1.1.4.</span> <span class="nav-text">环路等待条件</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E5%AE%9E%E4%BE%8B"><span class="nav-number">2.1.2.</span> <span class="nav-text">死锁产生实例</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%9C%A8%E5%8D%95%E4%B8%80%E7%BA%BF%E7%A8%8B%E4%B8%AD%E5%A4%9A%E6%AC%A1%E9%94%81%E5%AE%9A%E5%90%8C%E4%B8%80%E4%BA%92%E6%96%A5%E9%87%8F"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">(1)在单一线程中多次锁定同一互斥量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%90%8C%E6%97%B6%E5%AF%B9%E5%A4%9A%E4%B8%AA%E4%BA%92%E6%96%A5%E9%87%8F%E8%BF%9B%E8%A1%8C%E8%8E%B7%E5%8F%96%E5%92%8C%E9%87%8A%E6%94%BE%E6%97%B6%EF%BC%8C%E7%94%B1%E4%BA%8E%E8%8E%B7%E5%BE%97%E5%92%8C%E9%87%8A%E6%94%BE%E7%9A%84%E9%A1%BA%E5%BA%8F%E4%B8%8D%E5%90%8C%EF%BC%8C%E4%B9%9F%E5%8F%AF%E8%83%BD%E5%AF%BC%E8%87%B4%E6%AD%BB%E9%94%81"><span class="nav-number">2.1.2.2.</span> <span class="nav-text">(2)同时对多个互斥量进行获取和释放时，由于获得和释放的顺序不同，也可能导致死锁</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B4%BB%E9%94%81"><span class="nav-number">2.2.</span> <span class="nav-text">活锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90"><span class="nav-number">2.2.1.</span> <span class="nav-text">原因分析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81-%E6%B4%BB%E9%94%81%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="nav-number">2.3.</span> <span class="nav-text">死锁&#x2F;活锁的解决办法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%E7%9A%84-%E6%80%9D%E8%B7%AF%E4%B8%8A-%EF%BC%9F"><span class="nav-number">2.3.1.</span> <span class="nav-text">操作系统是如何解决死锁问题的(思路上)？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2-Deadlock-Prevention"><span class="nav-number">2.3.1.1.</span> <span class="nav-text">1.死锁预防 (Deadlock Prevention)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D-Deadlock-Avoidance"><span class="nav-number">2.3.1.2.</span> <span class="nav-text">2. 死锁避免 (Deadlock Avoidance)</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A1%A5%E5%85%85%EF%BC%9A%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95"><span class="nav-number">2.3.1.2.1.</span> <span class="nav-text">补充：银行家算法</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B-Deadlock-Detection"><span class="nav-number">2.3.1.3.</span> <span class="nav-text">3. 死锁检测 (Deadlock Detection)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E6%AD%BB%E9%94%81%E8%A7%A3%E9%99%A4-Deadlock-Recovery"><span class="nav-number">2.3.1.4.</span> <span class="nav-text">4. 死锁解除 (Deadlock Recovery)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E4%B8%AD%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">2.3.2.</span> <span class="nav-text">实际应用中的解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%87%BD%E6%95%B0%E9%83%BD%E6%8C%89%E6%8C%89%E9%A1%BA%E5%BA%8F%E8%8E%B7%E5%8F%96%E9%94%81"><span class="nav-number">2.3.2.1.</span> <span class="nav-text">(1)多线程函数都按按顺序获取锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%EF%BC%89%E4%BD%BF%E7%94%A8%E6%A0%87%E5%87%86%E5%BA%93%E6%8F%90%E4%BE%9B%E7%9A%84std-lock%E5%87%BD%E6%95%B0%E6%88%96%E8%80%85scoped-lock%E7%B1%BB%E3%80%82"><span class="nav-number">2.3.2.2.</span> <span class="nav-text">(2)）使用标准库提供的std::lock函数或者scoped_lock类。</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7"><span class="nav-number">2.4.</span> <span class="nav-text">死锁检测工具</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Java-%E4%B8%AD%E7%9A%84%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7"><span class="nav-number">2.4.1.</span> <span class="nav-text">Java 中的死锁检测工具</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-%E4%B8%AD%E7%9A%84%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7"><span class="nav-number">2.4.2.</span> <span class="nav-text">C++ 中的死锁检测工具</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Linux-%E7%9A%84-lockdep"><span class="nav-number">2.4.3.</span> <span class="nav-text">Linux 的 lockdep</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Liu Jiahua"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Liu Jiahua</p>
  <div class="site-description" itemprop="description">无限进步</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liu Jiahua</span>
</div>

<!-- 隐藏网页底部 -->
<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>
-->

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : 'dCP6GAJDyowRBa9GJQvHV1DP-gzGzoHsz',
      appKey     : 'X5yKePRt6xj4dR7tuVhlsZXL',
      placeholder: "留下一个评论吧",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
