<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AI提示词</title>
    <url>/2025/03/25/blog_AIprompt/</url>
    <content><![CDATA[<h2 id="提示词基本结构"><a href="#提示词基本结构" class="headerlink" title="提示词基本结构"></a>提示词基本结构</h2><p>即：角色+指令+上下文+输入问题+约束+例子+输出格式 。</p>
<span id="more"></span>

<p>1.角色(role) </p>
<blockquote>
<p>交互时通过给AI大模型设定某种角色，根据经验可以获得意想不到的效果，可以使大模型的输出更加具有个性化，专业化，同时能够增加模型输出的准确性。</p>
</blockquote>
<p>2.指示或者指令</p>
<blockquote>
<p> 是指示AI大模型需要完成的任务。</p>
</blockquote>
<p>3.上下文（context）</p>
<blockquote>
<p> 当你给出与任务相关的背景或细节时，可以帮助AI大模型更好的理解任务的具体情况，使得输出更加精确。</p>
</blockquote>
<p>4.输入或者问题</p>
<blockquote>
<p> 需要大模型执行具体的任务，或者具体的问题, 有时候如果指令部分描述的是具体的任务时，则指令部分就是输入。</p>
</blockquote>
<p>5.约束</p>
<blockquote>
<p> 有时候需要限制AI大模型的输出范围，设定一些约束条件，可以对输出进行控制。</p>
</blockquote>
<p>6.输出格式：</p>
<blockquote>
<p>主要给大模型指明，输出特定内容时的格式。</p>
</blockquote>
<p>7.例子：</p>
<blockquote>
<p>提供例子可以供AI大模型进行参考，可以有效的提高输出的准确度</p>
</blockquote>
<h2 id="更好的建议"><a href="#更好的建议" class="headerlink" title="更好的建议"></a>更好的建议</h2><ul>
<li><p>如果需求比较复杂，可以将其拆分为几个步骤，逐一提问。</p>
</li>
<li><p>开放式问题往往能够激发更多的想象空间和创造性答案。</p>
</li>
<li><p>在得到AI的回答后，如果不符合预期，可以给出反馈并修正提示词。(训练与测试的过程)</p>
</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="基本模板"><a href="#基本模板" class="headerlink" title="基本模板"></a>基本模板</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 角色设定</span><br><span class="line">你是一位资深流媒体架构师，精通视频传输协议（如HLS/DASH/WebRTC）、媒体编解码（H.264/HEVC/AV1）、CDN优化和实时通信技术。请用分步骤方案解决我的开发问题。</span><br><span class="line"></span><br><span class="line">## 开发背景</span><br><span class="line">当前项目使用[编程语言/框架，如Golang+FFmpeg]开发[具体功能，如低延迟直播系统]，运行在[部署环境，如AWS EC2 g4dn实例]。已实现[现有方案，如基于WebRTC的P2P传输]，但遇到[具体问题描述，如1080p视频在200ms延迟要求下出现5%的丢包率]。</span><br><span class="line"></span><br><span class="line">## 核心需求</span><br><span class="line">1. 优化[具体指标，如端到端延迟]到[目标值，如&lt;200ms]</span><br><span class="line">2. 提升[质量指标，如视频QoE]同时保持[约束条件，如带宽利用率&lt;8Mbps]</span><br><span class="line">3. 解决[具体异常现象，如iOS客户端首帧时间超过2s]</span><br><span class="line"></span><br><span class="line">## 请求格式</span><br><span class="line">请按以下结构给出建议：</span><br><span class="line">1. 诊断分析：可能导致问题的3个技术因素</span><br><span class="line">2. 优化方案：分网络传输、编解码、服务端三个层面的改进措施</span><br><span class="line">3. 配置示例：关键参数的推荐值（如WebRTC的sdp中设置a=goog-latency-experimental:100）</span><br><span class="line">4. 验证方法：建议的AB测试方案或监控指标</span><br><span class="line"></span><br><span class="line">## 补充信息</span><br><span class="line">[相关日志片段/抓包数据特征/硬件配置详情]</span><br></pre></td></tr></table></figure>

<h4 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h4><ol>
<li><strong>技术参数具体化</strong>：避免模糊表述，将”提高画质”改为”在HLS分片时长2s约束下优化SSIM≥0.92”</li>
<li><strong>上下文增强</strong>：附带关键代码段或网络拓扑图描述</li>
<li><strong>渐进式提问</strong>：复杂问题拆分为”协议选型→架构设计→参数调优”多轮对话</li>
<li><strong>验证驱动</strong>：要求AI给出可量化的验证方案（如：建议通过tc命令模拟20%丢包测试抗性）</li>
</ol>
<h3 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">场景：直播卡顿优化（核心需求）</span><br><span class="line">请分析基于NGINX-RTMP的直播系统在万人并发时出现的卡顿问题。当前配置： </span><br><span class="line">- 服务器：8核16G带宽1Gbps</span><br><span class="line">- 客户端观测：20%用户缓冲时间&gt;2s</span><br><span class="line">- 当前CDN配置：静态分片+单源站架构</span><br><span class="line"></span><br><span class="line">期望输出：</span><br><span class="line">1. 瓶颈定位：从协议栈/服务器架构/分发策略角度列出可能瓶颈</span><br><span class="line">2. 扩容方案：推荐边缘节点部署策略及成本估算</span><br><span class="line">3. 自适应码率方案：提供HLS动态分片配置示例</span><br><span class="line">4. 监控建议：关键性能指标的埋点方案</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>AI prompt</tag>
      </tags>
  </entry>
  <entry>
    <title>遍历排序与分治排序</title>
    <url>/2025/02/27/Algo_Sort/</url>
    <content><![CDATA[<p>总结了3种遍历排序与三种分治排序算法</p>
<p><strong>排序算法性质</strong>：</p>
<p><strong>自适应性</strong>：自适应排序能够利用输入已有的顺序信息来减少计算量，达到更优的时间效率</p>
<p><strong>稳定性</strong>：排序完成后，相等元素在数组中的顺序不发生改变</p>
<span id="more"></span>

<h2 id="遍历排序"><a href="#遍历排序" class="headerlink" title="遍历排序"></a>遍历排序</h2><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>思路：每次查找未排序区间的最小值，并与排序区间的尾部(实际这个位置是每轮外循环未排序区间的第一个位置)交换位置</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//外循环，未排序区间为[i,n-1],每轮未排序区间长度减1</span></span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++) &#123;<span class="comment">//最后一个不用排了</span></span><br><span class="line">    	<span class="type">int</span> k = i; <span class="comment">//未排序区间最小元素索引</span></span><br><span class="line">        <span class="comment">//内循环找未排序区间最小值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i<span class="number">+1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[k] &lt; nums[j]) &#123;</span><br><span class="line">                k = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[k]); <span class="comment">//将最小元素与未排序区间最小值交换</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度o(n^2),空间复杂度o(1)，非稳定性排序</li>
</ul>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>思路：每次冒泡都得到未排序区间的最大值，并交换至未排序区间的尾部，n个数冒泡n-1次即可(外循环次数),</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">//外循环，未排序区间[0,i]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n<span class="number">-1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>; <span class="comment">//标志</span></span><br><span class="line">   		<span class="comment">//内循环，交换最大值至未排序区间的末尾</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j<span class="number">+1</span>] &lt; nums[j]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[j],numss[j<span class="number">+1</span>]);</span><br><span class="line">                flage = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//本轮没有交换说明已经有序了，直接推出即可</span></span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;<span class="keyword">break</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度o(n^2), 有flag的情况下最佳时间复杂度o(n), 空间复杂度o(1)，稳定排序</li>
</ul>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>思路：在未排序区间选择一个基准元素，将其与左边的已排序区间比较，一直到左边元素不大于基准元素为止</p>
<style>.tidrrsmwqseh{zoom:33%;}</style><img src="/2025/02/27/Algo_Sort/image-20250227120737150.png" class="tidrrsmwqseh" alt="image-20250227120737150">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertionSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//外循环，已排序区间为[0,i-1]</span></span><br><span class="line">    <span class="comment">//初始状态，第一个元素已完成排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> base = nums[i], j = i<span class="number">-1</span>; </span><br><span class="line">    	<span class="comment">//内循环，将base插入到已排序区间</span></span><br><span class="line">		<span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &gt; base) &#123;</span><br><span class="line">            nums[j<span class="number">+1</span>] = nums[j]; <span class="comment">//右移一位</span></span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[j<span class="number">+1</span>] = base; <span class="comment">//插入base</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最差时间复杂度为o(n^2)，数据完全有序的情况下时间复杂度为o(n)，空间复杂度为o(1),稳定排序</p>
<img src="/2025/02/27/Algo_Sort/image-20250227132530692.png" class="" title="image-20250227132530692">

<hr>
<h2 id="分治排序"><a href="#分治排序" class="headerlink" title="分治排序"></a>分治排序</h2><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>思路：</p>
<ul>
<li><p>在未优化的情况下，快速排序的思路为先进行哨兵划分：即将数组最左边的元素nums[left]作为基准值，定义定义两个指针i,j,并分别初始化指向数组左边left和右边right，i从左往右找大于基准值的位置，j从右往左找小于基准值的位置，随后交换对应位置的值，并继续循环。  </p>
</li>
<li><p>进过哨兵划分之后，数组分成了两个子数组，接着递归这两个子数组即可。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//哨兵划分</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = left, j = right;</span><br><span class="line">    <span class="comment">//以nums[left]为基准值</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">    	<span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] &lt;= nums[left]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] &gt;= nums[left]) &#123;</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[j]);   															 	   	 </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//i==j时，将基准值交换到i的位置</span></span><br><span class="line">    <span class="built_in">swap</span>(nums[left], nums[i]);</span><br><span class="line">    <span class="keyword">return</span> i; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//哨兵划分</span></span><br><span class="line">    <span class="comment">//左闭右闭</span></span><br><span class="line">    <span class="type">int</span> pivot = <span class="built_in">partition</span>(nums, left, right);</span><br><span class="line">    <span class="built_in">quickSort</span>(nums, left, pivot<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">queickSort</span>(nums, pivot<span class="number">+1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优化：</strong>在数组倒序的情况下，基准数左边或者右边数组长度为n-1，每次递归都会出现有一个子数组长度为0的情况，快速排序退化为类似冒泡排序，时间复杂度劣化为o(n^2)。同样正序的情况下，也会出现有一个子数组长度为0的情况，每次递归长度为n-1的数组都只减少一个元素，递归深度为n-1，需要占用o(n)的栈帧空间</p>
<p>因此要对基准值和递归区间的选取进行优化：即选择数组左，中，右值的中位数作为基准值，选择对长度更短的子数组递归</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//选择基准数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">medianThree</span><span class="params">(vector&lt;<span class="type">int</span>&gt; nums, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = nums[left], m = nums[mid], r = nums[right];</span><br><span class="line">    <span class="keyword">if</span> ((l &lt;= m &amp;&amp; m &lt;= r) || (r &lt;= m &amp;&amp; m &lt;= l)) &#123;</span><br><span class="line">   		<span class="keyword">return</span> m;		     </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((m &lt;= l &amp;&amp; l &lt;= r) || (r &lt;= l &amp;&amp; l &lt;= m)) &#123;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//哨兵划分</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> median = <span class="built_in">medianThree</span>(nums, left, left+(right-left)/<span class="number">2</span> ,right); 	 </span><br><span class="line"> 	<span class="comment">//将数组交换至数组最左端</span></span><br><span class="line">    <span class="built_in">swap</span>(median, nums[left]);</span><br><span class="line">   	<span class="comment">//后面一样，省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 子数组长度为1 时终止</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="comment">// 哨兵划分操作</span></span><br><span class="line">        <span class="type">int</span> pivot = <span class="built_in">partition</span>(nums, left, right);</span><br><span class="line">        <span class="comment">// 对两个子数组中较短的那个执行快速排序</span></span><br><span class="line">        <span class="keyword">if</span> (pivot - left &lt; right - pivot) &#123;</span><br><span class="line">            <span class="built_in">quickSort</span>(nums, left, pivot - <span class="number">1</span>); <span class="comment">// 递归排序左子数组</span></span><br><span class="line">            left = pivot + <span class="number">1</span>; <span class="comment">// 剩余未排序区间为[pivot + 1, right]</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">quickSort</span>(nums, pivot + <span class="number">1</span>, right); <span class="comment">// 递归排序右子数组</span></span><br><span class="line">            right = pivot - <span class="number">1</span>; <span class="comment">// 剩余未排序区间为[left, pivot - 1]  </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2025/02/27/Algo_Sort/image-20250227153337619.png" class="" title="image-20250227153337619">

<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序的递归顺序和二叉树的后序遍历是一样的，即先递归左数组，再递归右数组，最后合并，注意合并时的子数组是有序的。一图总结如下：</p>
<style>.vdrcgaevqxts{zoom: 67%;}</style><img src="/2025/02/27/Algo_Sort/image-20250227153030239.png" class="vdrcgaevqxts" alt="image-20250227153030239">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//合并左右子数组,左数组[left, mid], 右数组[mid+1, right]</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = left, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//创建临时数组存放合并后数组</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tmp</span><span class="params">(right- left <span class="number">+1</span>)</span></span>;</span><br><span class="line">    <span class="comment">//左右数组都还有元素时进行比较</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">        <span class="comment">//将较小元素放入tmp</span></span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt;= nums[j]) &#123;</span><br><span class="line">            tmp[k++] = nums[i++]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp[k++] = nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将剩下元素放入tmp,注意i,j往后移动</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">        tmp[k++] = nums[i++]; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= right) &#123;</span><br><span class="line">        tmp[k++] = nums[j++]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将合并后放回到原数组对应位置</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; tmp.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        nums[left+i] = tmp[i]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//子数组长度为1时终止</span></span><br><span class="line">	<span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">//子数组划分</span></span><br><span class="line">    <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">mergeSort</span>(nums, left, mid); <span class="comment">//左</span></span><br><span class="line">    <span class="built_in">mergeSort</span>(nums, mid<span class="number">+1</span>, right); <span class="comment">//右</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对子数组进行合并</span></span><br><span class="line">    <span class="built_in">merge</span>(nums, left, mid, right);  <span class="comment">//中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度为o(n*logn)，递归深度logn,每层操作n次。  空间复杂度为o(n)，具体：栈帧空间占o(logn), 创建临时数组空间为o(n)</li>
</ul>
<p><font color='red'>归并排序特别适合链表排序</font>，在划分阶段可以使用迭代来代替递归，在合并阶段也不用创建额外的辅助数据，因为链表的合并只需要操作指针</p>
<h4 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148 排序链表"></a>148 排序链表</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//找到链表中点</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">findListMid</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast-&gt;next != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并左右子链表</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* left, ListNode* right)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>();<span class="comment">//虚拟头节点用于链表合并</span></span><br><span class="line">        ListNode* cur = dummyNode;</span><br><span class="line">        <span class="keyword">while</span> (left &amp;&amp; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left-&gt;val &lt;= right-&gt;val) &#123;</span><br><span class="line">                cur-&gt;next = left;</span><br><span class="line">                left = left-&gt;next;<span class="comment">//右移</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur-&gt;next = right;</span><br><span class="line">                right = right-&gt;next;</span><br><span class="line">            &#125;  </span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//链接剩下的节点</span></span><br><span class="line">        <span class="comment">//注意直接if链接就行，不用while</span></span><br><span class="line">        <span class="keyword">if</span> (left) cur-&gt;next = left;</span><br><span class="line">        <span class="keyword">if</span> (right) cur-&gt;next = right;</span><br><span class="line"></span><br><span class="line">        ListNode* result = dummyNode-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummyNode;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//归并排序</span></span><br><span class="line">        <span class="comment">//终止条件，空链表或者只有一个节点时终止</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* mid = <span class="built_in">findListMid</span>(head);</span><br><span class="line">        ListNode* right = mid-&gt;next;</span><br><span class="line">        mid-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        ListNode* leftSortedList = <span class="built_in">sortList</span>(head); <span class="comment">//递归左链表</span></span><br><span class="line">        ListNode* righSortedtList = <span class="built_in">sortList</span>(right); <span class="comment">//递归右链表</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">merge</span>(leftSortedList, righSortedtList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度为o(nlogn)</li>
<li>空间复杂度为栈帧空间o(logn)</li>
</ul>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>思路：</p>
<ul>
<li>先建立一个大顶堆，对数组执行堆化处理</li>
<li>交换堆顶元素和堆底元素,此时堆长度-1，已排序元素+1</li>
<li>堆顶元素从顶向下堆化</li>
<li>循环<strong>n-1</strong>次交换和堆化的过程</li>
</ul>
<p><strong>完全二叉树非常适合使用数组来表示</strong>，而堆就是一种特殊的完全二叉树，所以其底层实现就是数组。</p>
<style>.essrfhascgtv{zoom: 50%;}</style><img src="/2025/02/27/Algo_Sort/image-20250227171531676.png" class="essrfhascgtv" alt="image-20250227171531676">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//堆的长度为n，从节点i开始，从顶至底执行堆化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">siftDown</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> n, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">//索引i的左子节点为2i+1,右子节点为2i+2, 父节点索引为(i-1)/2</span></span><br><span class="line">        <span class="type">int</span> l = <span class="number">2</span>i<span class="number">+1</span>, r = <span class="number">2</span>i<span class="number">+2</span>;</span><br><span class="line">        <span class="type">int</span> ma = i; <span class="comment">//ma为i,l,r中值最大的节点索引</span></span><br><span class="line">        <span class="keyword">if</span> (l &lt; n &amp;&amp; nums[l] &gt;= nums[ma]) &#123;</span><br><span class="line">            ma = l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; n &amp;&amp; nums[r] &gt;= nums[ma]) &#123;</span><br><span class="line">           ma = r; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如节点i最大或l，r越界则无需继续堆化</span></span><br><span class="line">        <span class="keyword">if</span> (ma == i) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[ma]);</span><br><span class="line">        i = ma; <span class="comment">//循环进行堆化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">haepSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//建堆，堆化除叶子节点外所有节点</span></span><br><span class="line">    <span class="comment">//建堆的循环语句还可以从最后一个节点的父节点开始，即for (int i = (nums.size()- 1 - 1) / 2; i &gt;= 0; --i) &#123;&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = nums.<span class="built_in">size</span>() / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="comment">//从索引i开始从顶至底的执行堆化</span></span><br><span class="line">    	<span class="built_in">siftDown</span>(nums, nums.<span class="built_in">size</span>(), i); 	   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//循环n-1次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;<span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="comment">//交换堆顶元素与堆底元素</span></span><br><span class="line">        <span class="built_in">swap</span>(nums[<span class="number">0</span>], nums[i]); <span class="comment">//堆长度减1</span></span><br><span class="line">        <span class="built_in">siftDown</span>(nums, i, <span class="number">0</span>); <span class="comment">//从堆顶开始堆化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度o(nlogn)。输入列表并建堆操作的事件复杂度为o(n); 从堆中提取最大元素的时间复杂度为o(logn)(<strong>其实就是堆化的时间复杂度为o(logn)</strong>)。 </p>
<p><strong>补充</strong>：像堆排序这样直接将一个数组进行建堆是从底至顶的，而对于每个节点(除开叶子节点)来说，堆化却是从顶至底的。相比一个个输入元素再每次进行堆化(建堆时间复杂度为o(nlogn))的时间复杂度要小，因为叶子节点不用堆化。</p>
</li>
<li><p>原地排序，空间复杂度为o(1)</p>
</li>
</ul>
<p>引用</p>
<p>[1] hello-algo: 《Hello 算法》(<a href="https://github.com/krahets/hello-algo">https://github.com/krahets/hello-algo</a>)</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>排序</category>
      </categories>
  </entry>
  <entry>
    <title>智能指针</title>
    <url>/2025/03/10/Cpp11__inteligent_ptr/</url>
    <content><![CDATA[<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p><strong>c++11之后引入智能指针的目的</strong>：动态分配的内存空间如果不进行释放，就会导致内存泄露。智能指针是一个模板类，其离开作用域时就会销毁，这时就会调用其析构函数来释放所指向的动态分配对象的空间。<font color='red'>即智能指针就是用来解决内存泄露问题的。</font></p>
<p>本文重在实现简化版的智能指针的模板类，其它概念不多介绍。</p>
<p>阅读前请确保已了解右值引用和移动语义相关知识。</p>
<span id="more"></span>

<h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><p><strong>shared_ptr和其指向的动态分配对象可以实现多对一，即可以多个shared_ptr指向同一个动态分配的对象。</strong></p>
<p>​	<strong>首先需要列出实现的内容：</strong></p>
<ul>
<li>构造函数(默认构造函数，有参构造函数，拷贝构造函数)</li>
<li>析构函数</li>
<li>赋值运算符”&#x3D;”的重载</li>
<li>operator * 的重载</li>
<li>operator -&gt; 的重载</li>
<li>指向动态分配对象的原始指针<code>m_ptr</code></li>
<li>引用计数指针<code>m_count</code></li>
<li>成员函数get(), reset(), use_count()</li>
<li>make_shared函数模板</li>
</ul>
<style>.uxyebigqwhgh{zoom:50%;}</style><img src="/2025/03/10/Cpp11__inteligent_ptr/image-20250310211607484.png" class="uxyebigqwhgh" alt="image-20250310211607484">

<blockquote>
<p><strong>为什么图中使用<code>int* m_count</code>而不是<code>int m_count</code>?</strong></p>
<p><strong>答：为了共享引用计数值</strong></p>
<p><strong>更具体的</strong>：使用指针m_count而不是整型m_count保证了不同的shared_ptr可以指向同一个引用计数值(因为m_count的地址值是一样的)。如果每个<code>shared_ptr</code>实例都有自己的<code>int m_count</code>成员变量，那么当一个实例增加或减少计数时，其他实例不会知道这个变化。</p>
</blockquote>
<h4 id="具体代码实现"><a href="#具体代码实现" class="headerlink" title="具体代码实现"></a>具体代码实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*	</span></span><br><span class="line"><span class="comment">	shared_ptr.h</span></span><br><span class="line"><span class="comment">	实现一个简化版的shared_ptr模板类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SHARED_PTR_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHARED_PTR_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySharedPtr</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//指向动态分配对象的原始指针</span></span><br><span class="line">	T* m_ptr;	</span><br><span class="line">	<span class="comment">//共享的引用计数指针</span></span><br><span class="line">	<span class="type">int</span>* m_count;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//释放函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//注意要保证已经指向了动态对象，即m_count不为空</span></span><br><span class="line">		<span class="keyword">if</span> (m_count) &#123;</span><br><span class="line">			--(*m_count);</span><br><span class="line">			<span class="comment">//只有引用计数为0，才释放管理的对象内存空间</span></span><br><span class="line">			<span class="keyword">if</span> ((*m_count) == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">delete</span> m_ptr;</span><br><span class="line">				<span class="keyword">delete</span> m_count;</span><br><span class="line">				m_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">				m_count = <span class="literal">nullptr</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//默认构造函数</span></span><br><span class="line">	<span class="built_in">MySharedPtr</span>(): <span class="built_in">m_ptr</span>(<span class="literal">nullptr</span>), <span class="built_in">m_count</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//有参构造函数,最好使用显式构造，避免出现在栈区隐式调用智能指针构造函数，导致智能指针提前销毁</span></span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">MySharedPtr</span><span class="params">(T* ptr)</span>: m_ptr(ptr), m_count(new int(<span class="number">1</span>)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//拷贝构造函数</span></span><br><span class="line">	<span class="comment">//MySharedptr&lt;T&gt; p2(p1);</span></span><br><span class="line">	<span class="built_in">MySharedPtr</span>(<span class="type">const</span> MySharedPtr &amp;other): <span class="built_in">m_ptr</span>(other.m_ptr), <span class="built_in">m_count</span>(other.m_count) &#123;</span><br><span class="line">		<span class="comment">//引用计数加1</span></span><br><span class="line">		<span class="keyword">if</span> (m_count) &#123;</span><br><span class="line">			++(*m_count);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//析构函数</span></span><br><span class="line">	~<span class="built_in">MySharedPtr</span>() &#123;</span><br><span class="line">		<span class="built_in">release</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//赋值运算符&quot;=&quot;重载</span></span><br><span class="line">	<span class="comment">//MySharedptr&lt;T&gt; p2 = p1; 不能给shared_ptr赋裸指针的原因</span></span><br><span class="line">	MySharedPtr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MySharedPtr &amp;other) &#123;</span><br><span class="line">		<span class="comment">//other这里是个实例,而this是指向p2的指针，所以要加个&quot;&amp;&quot;</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">			<span class="built_in">release</span>();</span><br><span class="line">			m_ptr = other.m_ptr;</span><br><span class="line">			m_count = other.m_count;</span><br><span class="line">			<span class="keyword">if</span> (m_count) &#123;</span><br><span class="line">				++(*m_count);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//解引用&quot;*&quot;的重载</span></span><br><span class="line">	T&amp; <span class="keyword">operator</span>*() &#123;</span><br><span class="line">		<span class="keyword">return</span> *m_ptr; <span class="comment">//返回管理的对象</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//&quot;-&gt;&quot;的重载</span></span><br><span class="line">	T* <span class="keyword">operator</span>-&gt;() &#123;</span><br><span class="line">		<span class="keyword">return</span> m_ptr; </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//reset函数</span></span><br><span class="line">	<span class="comment">//重置指针，如果调用该函数的shared_ptr对象没有初始化且ptr不为空则让裸指针指向动态对象，并将引用计数加1</span></span><br><span class="line">	<span class="comment">//如果shared_ptr对象已经初始化，则根据reset是否传参：即ptr有值则重新指向该对象；ptr为空，则让引用计数减1</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(T* ptr = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (m_ptr != ptr) &#123;</span><br><span class="line">			<span class="built_in">release</span>();</span><br><span class="line">			<span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">				m_ptr = ptr;</span><br><span class="line">				++(*m_count);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//get函数,获取原始指针</span></span><br><span class="line">	<span class="function">T* <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_ptr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//use_count函数，返回引用计数的值</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">use_count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//注意管理对象可以已经销毁再调用use_count查看的</span></span><br><span class="line">		<span class="keyword">return</span> m_count ? *m_count : <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//make_shared&lt;T&gt;() 函数模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">MySharedPtr&lt;T&gt; <span class="title">make_shared</span><span class="params">(Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//std::forward&lt;&gt; 在模板代码中用于完美转发</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">MySharedPtr</span>&lt;T&gt;(<span class="keyword">new</span> <span class="built_in">T</span>(std::forward&lt;Args&gt;(args)...)); <span class="comment">//有参构造</span></span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br></pre></td></tr></table></figure>

<p>测试函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;shared_ptr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">/****************shared_ptr的测试*******************************/</span></span><br><span class="line">	<span class="comment">/*测试简化版的shared_ptr模板类*/</span></span><br><span class="line">	<span class="function">MySharedPtr&lt;<span class="type">int</span>&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">50</span>))</span></span>;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;the use_count: &quot;</span> &lt;&lt; sp<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;sp1: &quot;</span> &lt;&lt; *sp1 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//测试赋值运算重载</span></span><br><span class="line">	MySharedPtr&lt;<span class="type">int</span>&gt; sp2 = sp1; </span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;After copy, use_count(): &quot;</span> &lt;&lt; sp<span class="number">2.</span><span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 修改值</span></span><br><span class="line">	*sp1 = <span class="number">100</span>;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;*the value of sp2: &quot;</span> &lt;&lt; *sp2 &lt;&lt; std::endl;  <span class="comment">// sp2也会看到更改</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用make_shared</span></span><br><span class="line">	<span class="keyword">auto</span> sp3 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">200</span>);</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;*sp3: &quot;</span> &lt;&lt; *sp3 &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;after sp3,  use_count of sp3 &quot;</span> &lt;&lt; sp<span class="number">3.</span><span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;after sp3, use_count of sp2,sp1 &quot;</span> &lt;&lt; sp<span class="number">2.</span><span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重置指针</span></span><br><span class="line">	sp<span class="number">1.</span><span class="built_in">reset</span>();</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;After sp1.reset(), sp2.use_count(): &quot;</span> &lt;&lt; sp<span class="number">2.</span><span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/****************shared_ptr测试函数到此结束***********************/</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">the use_count: 1</span><br><span class="line">sp1: 50</span><br><span class="line">After copy, use_count(): 2</span><br><span class="line">*the value of sp2: 100</span><br><span class="line">*sp3: 200</span><br><span class="line">after sp3,  use_count of sp3 1</span><br><span class="line">after sp3, use_count of sp2,sp1 2</span><br><span class="line">After sp1.reset(), sp2.use_count(): 1</span><br></pre></td></tr></table></figure>

<h4 id="难点以及“坑”解析"><a href="#难点以及“坑”解析" class="headerlink" title="难点以及“坑”解析"></a>难点以及“坑”解析</h4><ul>
<li><p>一、<strong>释放函数release必须要先判断引用计数指针m_count是否为空！</strong></p>
</li>
<li><p>二、<strong>赋值运算符重载这里需要考虑如下情况</strong></p>
<ul>
<li>1.<font color='mediumseagreen'>如果不加this !&#x3D; &amp;other</font></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">SharedPtr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">p1 = p1;  <span class="comment">// ❌ 如果没有 this != &amp;other，p1 可能释放掉自己正在管理的资源</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>2.<font color='mediumseagreen'>为什么先release()减少引用计数，而不是直接给赋值，并增加引用计数</font></p>
<p>如下假如不先执行release()</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">    m_ptr = other.m_ptr;</span><br><span class="line">    m_count = other.m_count;</span><br><span class="line">    <span class="keyword">if</span> (m_count) &#123;</span><br><span class="line">        ++(*m_count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	那么如果测试函数中出现如下情况，<font color='red'>则会导致p2原来指向的动态对象空间int(20)永远不会被释放，导致内存泄露</font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">MySharedPtr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;  <span class="comment">// p1: *m_count = 1</span></span><br><span class="line"><span class="function">MySharedPtr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">20</span>))</span></span>;  <span class="comment">// p2: *m_count = 1</span></span><br><span class="line">p2 = p1;  <span class="comment">// p2 放弃原来的对象，指向 p1 的对象</span></span><br></pre></td></tr></table></figure>

<p>​	正常的MySharedPtr赋值如下：</p>
<blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">MySharedPtr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;  <span class="comment">// p1: *m_count = 1</span></span><br><span class="line">MySharedPtr&lt;<span class="type">int</span>&gt; p2;  <span class="comment">// p2 为空，m_count = nullptr</span></span><br><span class="line">p2 = p1;  <span class="comment">// p2 变成 p1 的拷贝</span></span><br></pre></td></tr></table></figure>

<p><strong>步骤解析：</strong></p>
<p><code>p2.release();</code> <strong>不会释放任何东西</strong>（因为 <code>p2</code> 为空）。</p>
<p><code>p2.m_ptr = p1.m_ptr;</code>（指向相同对象）</p>
<p><code>p2.m_count = p1.m_count;</code>（共享相同引用计数）</p>
<p><code>++(*p2.m_count);</code>  引用计数 <code>1 → 2</code>。</p>
</blockquote>
<ul>
<li><ol start="3">
<li><font color='mediumseagreen'>返回类型为该模板类<code>*this</code>的引用</font></li>
</ol>
</li>
</ul>
<blockquote>
<p>这里这么做的作用主要是如果函数返回类型不加引用，那么实际上返回值是一个拷贝了原对象<code>*this</code>的新智能指针p2’，在需要<strong>链式编程</strong>的场景下就不可行了，所以我们直接加引用“&amp;”返回原对象即可。</p>
</blockquote>
</li>
<li><p>三、<strong>有参构造函数要加explicit关键字，保证是显式构造</strong></p>
<blockquote>
<p>如果没有 <code>explicit</code> 关键字，以下代码将被允许：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(SharedPtr&lt;<span class="type">int</span>&gt; ptr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 ptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* rawPtr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">func</span>(rawPtr);  <span class="comment">// 编译器会隐式地将 rawPtr 转换为 SharedPtr&lt;int&gt;</span></span><br><span class="line">    <span class="comment">// 可能导致内存泄漏，因为 func 结束后，临时创建的 SharedPtr 被销毁，会释放 rawPtr</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<p>补充：</p>
<blockquote>
<p>在 C++ 中，<code>const</code> 限定符有几个重要的用途：</p>
<ol>
<li><strong>保证接口安全</strong>：当函数声明为 <code>const</code> 时（例如 <code>T* get() const</code>），它承诺不会修改对象的状态。这使调用者知道调用该函数是安全的，不会改变对象的内部数据。</li>
<li><strong>编译时检查</strong>：编译器会检查并阻止在 <code>const</code> 方法中对对象成员变量的修改，这有助于防止意外的数据修改。</li>
<li><strong>更广泛的使用场景</strong>：<code>const</code> 方法可以被 <code>const</code> 对象和非 <code>const</code> 对象调用，而非 <code>const</code> 方法只能被非 <code>const</code> 对象调用。这增加了类的灵活性。</li>
<li><strong>代码自文档化</strong>：<code>const</code> 关键字明确告诉其他开发者哪些操作不会修改对象状态，增强了代码的可读性和可维护性。</li>
<li><strong>编译器优化</strong>：编译器可以对 <code>const</code> 方法进行更积极的优化，因为它知道这些方法不会修改对象状态。</li>
</ol>
</blockquote>
<p>此外，<font color='red'>还需注意标准库中的shared_ptr的reset函数在智能指针对象指向了动态分配对象的前提下使用且不传参，引用计数减1的同时，还会销毁该对象</font></p>
<h4 id="线程安全的引用计数"><a href="#线程安全的引用计数" class="headerlink" title="线程安全的引用计数"></a>线程安全的引用计数</h4><p><strong>注意在shared_ptr中引用计数是线程安全的，但是管理的数据不是线程安全的</strong>。我们上面的实现并不能保证引用计数是线程安全的，因为多个线程可能同时操作引用计数指针<code>m_count</code>，导致动态对象被提前释放或永远不被释放。</p>
<p>下面将采用互斥锁来实现引用计数线程安全（可以参考下图实现，这里我们就不考虑weak_count了）</p>
<style>.kfqwlbypfiaq{zoom:50%;}</style><img src="/2025/03/10/Cpp11__inteligent_ptr/image-20250310221101442.png" class="kfqwlbypfiaq" alt="image-20250310221101442">

<p>具体代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* shared_ptr.h</span></span><br><span class="line"><span class="comment">* 实现一个线程安全的shared_ptr模板类，不考虑weak_ptr</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SHARED_PTR_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHARED_PTR_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySharedPtr</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 控制块结构</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ControlBlock</span> &#123;</span><br><span class="line">        <span class="type">int</span> ref_count; <span class="comment">// 引用计数</span></span><br><span class="line">        std::mutex mutex; <span class="comment">// 互斥锁，保证线程安全</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">        <span class="built_in">ControlBlock</span>() : <span class="built_in">ref_count</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向管理对象的原始指针</span></span><br><span class="line">    T* raw_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向控制块的指针</span></span><br><span class="line">    ControlBlock* control_block;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加引用计数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add_count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (control_block) &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(control_block-&gt;mutex)</span></span>;</span><br><span class="line">            ++(control_block-&gt;ref_count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 减少引用计数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sub_count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (control_block) &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(control_block-&gt;mutex)</span></span>;</span><br><span class="line">            --(control_block-&gt;ref_count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (control_block) &#123;</span><br><span class="line">            <span class="built_in">sub_count</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查是否为最后一个引用</span></span><br><span class="line">            <span class="type">bool</span> delete_resources = <span class="literal">false</span>;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(control_block-&gt;mutex)</span></span>;</span><br><span class="line">                delete_resources = (control_block-&gt;ref_count == <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 只有当引用计数为零时才删除资源</span></span><br><span class="line">            <span class="keyword">if</span> (delete_resources) &#123;</span><br><span class="line">                <span class="keyword">delete</span> raw_ptr;</span><br><span class="line">                <span class="keyword">delete</span> control_block;</span><br><span class="line">                raw_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">                control_block = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">MySharedPtr</span>() : <span class="built_in">raw_ptr</span>(<span class="literal">nullptr</span>), <span class="built_in">control_block</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有参构造，从原始指针构造</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MySharedPtr</span><span class="params">(T* ptr)</span>: raw_ptr(ptr), control_block(ptr ? new ControlBlock() : nullptr) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MySharedPtr</span>(<span class="type">const</span> MySharedPtr&amp; other): <span class="built_in">raw_ptr</span>(other.raw_ptr), <span class="built_in">control_block</span>(other.control_block) &#123;</span><br><span class="line">        <span class="built_in">add_count</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">MySharedPtr</span>(MySharedPtr&amp;&amp; other) <span class="keyword">noexcept</span>: <span class="built_in">raw_ptr</span>(other.raw_ptr), <span class="built_in">control_block</span>(other.control_block) &#123;</span><br><span class="line">        other.raw_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        other.control_block = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">MySharedPtr</span>() &#123;</span><br><span class="line">        <span class="built_in">release</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝赋值运算符重载</span></span><br><span class="line">    <span class="comment">//这里不能给shared_ptr赋裸指针</span></span><br><span class="line">    MySharedPtr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MySharedPtr&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="built_in">release</span>();</span><br><span class="line">            raw_ptr = other.raw_ptr;</span><br><span class="line">            control_block = other.control_block;</span><br><span class="line">            <span class="built_in">add_count</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动赋值运算符重载</span></span><br><span class="line">    MySharedPtr&amp; <span class="keyword">operator</span>=(MySharedPtr&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="built_in">release</span>();</span><br><span class="line">            raw_ptr = other.raw_ptr;</span><br><span class="line">            control_block = other.control_block;</span><br><span class="line">            other.raw_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">            other.control_block = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解引用运算符重载</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> *raw_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 箭头运算符重载</span></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> raw_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(T* ptr = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (raw_ptr != ptr) &#123;</span><br><span class="line">            <span class="built_in">release</span>();</span><br><span class="line">            <span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">                raw_ptr = ptr;</span><br><span class="line">                control_block = <span class="keyword">new</span> <span class="built_in">ControlBlock</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取原始指针</span></span><br><span class="line">    <span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> raw_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取引用计数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">use_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (control_block) &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(control_block-&gt;mutex)</span></span>;</span><br><span class="line">            <span class="keyword">return</span> control_block-&gt;ref_count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查指针是否是唯一拥有者（只有一个引用）</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">unique</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">use_count</span>() == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// make_shared函数模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">MySharedPtr&lt;T&gt; <span class="title">make_shared</span><span class="params">(Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">MySharedPtr</span>&lt;T&gt;(<span class="keyword">new</span> <span class="built_in">T</span>(std::forward&lt;Args&gt;(args)...));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>同样的测试用例下，代码无误</p>
<p><strong>补充：为什么<code>make_shared&lt;int&gt;</code>创建shared_ptr会比<code>shared_ptr&lt;int&gt; p(new int())</code>更优</strong></p>
<blockquote>
<p>简单来说就是make_shared内存分配效率更高(性能更好)，安全性更好，代码可读性更强</p>
<p>具体的：</p>
<p>（1）性能更优</p>
<p><code>std::make_shared&lt;T&gt;(...)</code> 在堆上只分配 <strong>一次内存</strong>，而 <code>std::shared_ptr&lt;T&gt;(new T(...))</code> 会进行 <strong>两次分配</strong>：</p>
<ul>
<li><code>make_shared</code> 会把 <strong>引用计数控制块</strong> 和 <strong>实际对象 T</strong> 一起分配在一块连续的内存中。</li>
<li>而 <code>shared_ptr&lt;T&gt;(new T(...))</code> 会先分配对象的内存，再分配引用计数控制块的内存。</li>
</ul>
<p>（2）安全性更好</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> Widget(), custom_deleter)</span></span>;</span><br></pre></td></tr></table></figure>

<p>如果 <code>new Widget()</code> 和 <code>custom_deleter</code> 之间抛异常，<code>Widget</code> 的指针就泄露了（因为 <code>shared_ptr</code> 构造尚未完成）。</p>
<p>而 <code>make_shared</code> 是原子操作，整个过程由内部管理，不存在这种中间状态导致的泄漏问题。</p>
<p>(3) 代码可读性更强</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = std::<span class="built_in">make_shared</span>&lt;MyClass&gt;(arg1, arg2);  <span class="comment">// 简洁明了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> p = std::<span class="built_in">shared_ptr</span>&lt;MyClass&gt;(<span class="keyword">new</span> <span class="built_in">MyClass</span>(arg1, arg2));  <span class="comment">// 啰嗦且容易出错</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>再加了weak_ptr之后的实现可以参考下图，具体代码省略</p>
<style>.vfnqajnuxrmz{zoom:50%;}</style><img src="/2025/03/10/Cpp11__inteligent_ptr/image-20250310230603480.png" class="vfnqajnuxrmz" alt="image-20250310230603480">

<h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p><strong>unique_ptr和其管理的动态分配对象必须一对一。</strong></p>
<ul>
<li><p>unique_ptr只有一个原始指针和一个删除器，<strong>占的内存空间和原始裸指针相当</strong></p>
</li>
<li><p>unique_ptr确保同一时间只有一个指针可以管理动态分配的对象，<strong>通过禁用拷贝构造函数和拷贝赋值运算符实现</strong></p>
</li>
<li><p><strong>如果要指定删除器，应当在unique_ptr创建时指定</strong></p>
</li>
<li><p>成员函数get(), release(),</p>
</li>
</ul>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* uniquex_ptr的实现</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Deleter = std::default_delete&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> UniquePtr &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//指向管理对象的原始指针</span></span><br><span class="line">	T* raw_ptr; </span><br><span class="line"></span><br><span class="line">	<span class="comment">//删除器</span></span><br><span class="line">	Deleter deleter;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">UniquePtr</span><span class="params">(T* ptr = <span class="literal">nullptr</span>)</span>: raw_ptr(ptr) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 移动构造函数</span></span><br><span class="line">	<span class="built_in">UniquePtr</span>(UniquePtr&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">raw_ptr</span>(other.raw_ptr) &#123;</span><br><span class="line">		other.raw_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 移动赋值运算符, std::move返回值就是右值，即测试函数中的&quot;=&quot;将会调用该移动拷贝函数</span></span><br><span class="line">	UniquePtr&amp; <span class="keyword">operator</span>=(UniquePtr&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">			<span class="keyword">if</span> (raw_ptr) <span class="built_in">deleter</span>(raw_ptr);</span><br><span class="line">			raw_ptr = other.raw_ptr;</span><br><span class="line">			other.raw_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//析构函数</span></span><br><span class="line">	~<span class="built_in">UniquePtr</span>() &#123;</span><br><span class="line">		<span class="keyword">if</span> (raw_ptr) &#123;</span><br><span class="line">			<span class="comment">//释放对象内存空间</span></span><br><span class="line">			<span class="built_in">deleter</span>(raw_ptr);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关键：禁用赋值拷贝和拷贝构造函数</span></span><br><span class="line">	UniquePtr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> UniquePtr&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">	<span class="built_in">UniquePtr</span>(<span class="type">const</span> UniquePtr&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//运算符重载</span></span><br><span class="line">	T&amp; <span class="keyword">operator</span>*() <span class="type">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> *raw_ptr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	T* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> raw_ptr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//get函数</span></span><br><span class="line">	<span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> raw_ptr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//reset函数,释放原管理对象空间，重置原始指针指向新对象</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(T* uptr = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (raw_ptr) &#123; </span><br><span class="line">			<span class="built_in">deleter</span>(raw_ptr); </span><br><span class="line">		&#125;</span><br><span class="line">		raw_ptr = uptr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//释放所有权release()</span></span><br><span class="line">	<span class="function">T* <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		T* tmp = raw_ptr;</span><br><span class="line">		raw_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>测试用例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简单测试类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> value;</span><br><span class="line">	<span class="built_in">Test</span>(<span class="type">int</span> v) : <span class="built_in">value</span>(v) &#123; std::cout &lt;&lt; <span class="string">&quot;Test(&quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot;) constructed\n&quot;</span>; &#125;</span><br><span class="line">	~<span class="built_in">Test</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Test(&quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot;) destructed\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************unique_ptr测试函数开始***********************/</span></span><br><span class="line">	<span class="comment">// 测试基本功能</span></span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;=== 测试基本功能 ===\n&quot;</span>;</span><br><span class="line">		<span class="function">UniquePtr&lt;Test&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> Test(<span class="number">1</span>))</span></span>;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;p1-&gt;value: &quot;</span> &lt;&lt; p1-&gt;value &lt;&lt; std::endl;</span><br><span class="line">	&#125; <span class="comment">// p1析构，Test(1)也析构</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 测试release</span></span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;\n=== 测试release ===\n&quot;</span>;</span><br><span class="line">		<span class="function">UniquePtr&lt;Test&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> Test(<span class="number">3</span>))</span></span>;</span><br><span class="line">		Test* raw = p<span class="number">1.</span><span class="built_in">release</span>();</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;release后p1是否为空: &quot;</span> &lt;&lt; (p<span class="number">1.</span><span class="built_in">get</span>() == <span class="literal">nullptr</span> ? <span class="string">&quot;是&quot;</span> : <span class="string">&quot;否&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;raw-&gt;value: &quot;</span> &lt;&lt; raw-&gt;value &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">delete</span> raw; <span class="comment">// 手动释放资源</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;\n=== 测试reset函数 ===\n&quot;</span>;</span><br><span class="line">		<span class="function">UniquePtr&lt;Test&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> Test(<span class="number">1</span>))</span></span>;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;原始p1-&gt;value: &quot;</span> &lt;&lt; p1-&gt;value &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 重置为新对象</span></span><br><span class="line">		p<span class="number">1.</span><span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Test</span>(<span class="number">2</span>));</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;reset后p1-&gt;value: &quot;</span> &lt;&lt; p1-&gt;value &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 重置为nullptr</span></span><br><span class="line">		p<span class="number">1.</span><span class="built_in">reset</span>();</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;reset为nullptr后，p1是否为空: &quot;</span> &lt;&lt; (p<span class="number">1.</span><span class="built_in">get</span>() == <span class="literal">nullptr</span> ? <span class="string">&quot;是&quot;</span> : <span class="string">&quot;否&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 测试移动构造</span></span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;\n=== 测试移动构造 ===\n&quot;</span>;</span><br><span class="line">		<span class="function">UniquePtr&lt;Test&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> Test(<span class="number">1</span>))</span></span>;</span><br><span class="line">		<span class="comment">//注意UniquePtr的拷贝赋值运算符重载被禁用了</span></span><br><span class="line">         <span class="comment">//这里std::move将p1转换为右值引用，所以这里会调用移动拷贝复制运算符重载函数</span></span><br><span class="line">		UniquePtr&lt;Test&gt; p2 = std::<span class="built_in">move</span>(p1);</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;移动后p2-&gt;value: &quot;</span> &lt;&lt; p2-&gt;value &lt;&lt; std::endl;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;p1是否为空: &quot;</span> &lt;&lt; (p<span class="number">1.</span><span class="built_in">get</span>() == <span class="literal">nullptr</span> ? <span class="string">&quot;是&quot;</span> : <span class="string">&quot;否&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************unique_ptr测试函数结束***********************/</span></span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">=== 测试基本功能 ===</span><br><span class="line">Test(1) constructed</span><br><span class="line">p1-&gt;value: 1</span><br><span class="line">Test(1) destructed</span><br><span class="line"></span><br><span class="line">=== 测试release ===</span><br><span class="line">Test(3) constructed</span><br><span class="line">release后p1是否为空: 是</span><br><span class="line">raw-&gt;value: 3</span><br><span class="line">Test(3) destructed</span><br><span class="line"></span><br><span class="line">=== 测试reset函数 ===</span><br><span class="line">Test(1) constructed</span><br><span class="line">原始p1-&gt;value: 1</span><br><span class="line">Test(2) constructed</span><br><span class="line">Test(1) destructed</span><br><span class="line">reset后p1-&gt;value: 2</span><br><span class="line">Test(2) destructed</span><br><span class="line">reset为nullptr后，p1是否为空: 是</span><br><span class="line"></span><br><span class="line">=== 测试移动构造 ===</span><br><span class="line">Test(1) constructed</span><br><span class="line">移动后p2-&gt;value: 1</span><br><span class="line">p1是否为空: 是</span><br><span class="line">Test(1) destructed</span><br></pre></td></tr></table></figure>

<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><ul>
<li><p>move函数要加<code>static</code>关键字(在模板类中实现move函数要注意的点，展示的代码用的标准库的move函数)</p>
<blockquote>
<p>原因：</p>
<ul>
<li><p><strong>静态成员函数不属于某个实例，而是属于类</strong>，这意味着它不绑定到特定的 <code>unique_ptr</code> 实例上，也不需要通过特定实例来调用。所以这里才允许使用 <code>unique_ptr&lt;T&gt;::move(ptr)</code> 这样的调用方式，而不是如<code>UniquePtr&lt;Test&gt; p2 = p1.move(p1);</code>这样来调用</p>
</li>
<li><p>将函数定义为静态成员函数可以将其限定在类的作用域内，<strong>避免与全局命名空间中的其他 <code>move</code> 函数冲突。</strong></p>
</li>
</ul>
</blockquote>
</li>
<li><p>移动构造函数及<code>noexcept</code>作用</p>
<blockquote>
<p>移动构造函数(Move Constructor)是C++11中引入的一个特性，它允许在创建新对象时”窃取”已有对象的资源，而不是复制这些资源。</p>
<p>移动构造函数的基本形式是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ClassName</span>(ClassName&amp;&amp; other) <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure>

<p>这里的关键是双引用符号<code>&amp;&amp;</code>，它表示一个右值引用，允许函数接收临时对象或即将被销毁的对象(<strong>都是右值</strong>)。</p>
<p><strong>移动构造函数的主要优点是：</strong></p>
<ol>
<li><strong>提高性能</strong>：对于包含大量数据的对象（如向量、字符串等），<strong>移动比复制快得多。</strong></li>
<li><strong>避免不必要的资源分配和释放</strong>：使用移动语义优化了临时变量创建、复制、转移的过程。</li>
</ol>
<p><strong>补充</strong>：<font color='red'>在移动语义中，一个临时变量的创建、复制、转移过程都被省略优化掉了(拷贝省略优化)</font>，即直接在目标对象的空间中完成构造。<strong>在上面的代码中，并没有实现指针赋值的深拷贝，而在需要深拷贝以避免同一内存多次释放的情况下，使用移动拷贝构造函数和移动拷贝赋值运算符可以避免申请大量资源，从而提高引用程序的效率。</strong></p>
<p>我们在设计和实现类时，对于需要动态申请大量资源的类，应该设计右值引用的拷贝构造函数和赋值函数，以提高应用程序的效率。</p>
<p><strong>noexcept作用</strong></p>
<p><code>noexcept</code> 关键字在 C++ 中用来指定函数不会抛出异常，它有几个重要作用：</p>
<ol>
<li><strong>性能优化</strong>：当编译器知道函数不会抛出异常时，可以生成更高效的代码。特别是对于移动构造函数和移动赋值运算符，标记为 <code>noexcept</code> 可以显著提高性能。</li>
<li><strong>标准容器优化</strong>：标准库容器（如 <code>std::vector</code>）会根据移动操作是否标记为 <code>noexcept</code> 来决定在扩容时使用移动还是复制操作。如果移动构造函数标记为 <code>noexcept</code>，<code>std::vector</code> 会使用移动操作，否则会退回到复制操作以保证异常安全性。</li>
<li><strong>异常安全保证</strong>：向调用者明确表明函数不会抛出异常，有助于编写更可靠的代码和进行异常处理设计。</li>
<li><strong>编译时检查</strong>：编译器会检查标记为 <code>noexcept</code> 的函数是否真的不会抛出异常。如果函数内部可能抛出异常（直接或通过调用可能抛出异常的函数），则会产生编译错误。</li>
</ol>
<p><code>noexcept</code> 可以有两种形式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无条件指定函数不会抛出异常</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有条件指定，表达式为 true 时函数不会抛出异常</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(表达式)</span></span>;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p><strong>weak_ptr主要用来观测shared_ptr所管理的动态分配对象，其不会导致引用计数变化。</strong></p>
]]></content>
      <categories>
        <category>c++11</category>
        <category>智能指针</category>
      </categories>
  </entry>
  <entry>
    <title>cmake</title>
    <url>/2025/03/10/DevTools__cmake/</url>
    <content><![CDATA[<h2 id="从零开始写一个CMakeLists-txt文件"><a href="#从零开始写一个CMakeLists-txt文件" class="headerlink" title="从零开始写一个CMakeLists.txt文件"></a>从零开始写一个CMakeLists.txt文件</h2><p>从零开始写CMakeLists.txt的基本步骤和结构：</p>
<ol>
<li><strong>第一步：基础设置</strong><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定CMake最低版本</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目名称</span></span><br><span class="line"><span class="keyword">project</span>(你的项目名称)</span><br></pre></td></tr></table></figure></li>
</ol>
<span id="more"></span>

<ol start="2">
<li><strong>第二步：设置编译选项</strong></li>
</ol>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置C++标准</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -std=c++11&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置编译类型（Debug/Release）</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_BUILD_TYPE Debug)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p><strong>第三步：设置头文件和库文件路径</strong></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果有额外的头文件目录</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="keyword">include</span>)</span><br><span class="line"><span class="comment"># 如果有额外的库文件目录</span></span><br><span class="line"><span class="keyword">link_directories</span>(lib)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>第四步：添加源文件</strong></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方法1：直接列出所有源文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(项目名称 </span><br><span class="line">    src/main.cpp</span><br><span class="line">    src/other.cpp</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法2：使用变量收集源文件</span></span><br><span class="line"><span class="keyword">set</span>(SOURCES</span><br><span class="line">    src/main.cpp</span><br><span class="line">    src/other.cpp</span><br><span class="line">)</span><br><span class="line"><span class="keyword">add_executable</span>(项目名称 <span class="variable">$&#123;SOURCES&#125;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>第五步：如果需要链接外部库</strong></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 链接库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(项目名称</span><br><span class="line">    库名称<span class="number">1</span></span><br><span class="line">    库名称<span class="number">2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
</ol>
<p>一些实用的建议：</p>
<ol>
<li>保持结构清晰，按照上述步骤组织你的CMakeLists.txt</li>
<li>使用注释说明每个部分的作用</li>
<li>对于大型项目，可以使用子目录的CMakeLists.txt</li>
<li>养成良好的变量命名习惯</li>
<li>建议使用现代CMake的命令和特性</li>
</ol>
<p>创建一个最简单的CMakeLists.txt，可以参考这个模板：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 最低CMake版本要求</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目名称</span></span><br><span class="line"><span class="keyword">project</span>(MyProject)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将所有源文件添加到可执行文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(MyProject main.cpp)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>开发工具</category>
        <category>构建</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2025/02/23/concurrentServer__Net_IOmodel/</url>
    <content><![CDATA[<p>总结了一些linux中常用的基本命令和项目中常用的命令</p>
<span id="more"></span>

<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><ul>
<li>shell ：即命令解释器，是用户和linux内核交互的桥梁，通过在shell终端输入命令让linux内核相应部分识别用户命令并处理。</li>
</ul>
<p>​	shell命令的基本格式为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">命令 [option] 参数 </span><br></pre></td></tr></table></figure>
<p>​	其中加”[]”符号表示可以不输入这个选项</p>
<p><strong>tips</strong>: </p>
<ul>
<li><p>对于不熟悉的命令可以使用<code>man 1 命令</code>或者<code>命令 --help</code>来查看说明</p>
</li>
<li><p>注意如果想要在windows复制并粘贴到linux虚拟机中，就要安装open-vm-tools，而vm-tools是老版的，重复安装这两个就会冲突，所以只安装open-vm-tools即可。对应命令为：</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install open-vm-tools-desktop</span><br></pre></td></tr></table></figure>

<p>​	以下给出几个vm-tools的区别</p>
<blockquote>
<p><strong>open-vm-tools</strong>：开源工具集，主要用于 Linux 虚拟机。</p>
<p><strong>vm-tools</strong>：VMware 提供的专有工具集，通常用于 VMware 产品。</p>
<p><strong>open-vm-tools-desktop</strong>：<code>open-vm-tools</code> 的桌面扩展版，专为桌面环境（有图形界面的 Linux）优化，提供更多图形相关的功能。</p>
</blockquote>
<h2 id="基本常用命令"><a href="#基本常用命令" class="headerlink" title="基本常用命令"></a>基本常用命令</h2><ol>
<li>切换用户权限组</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo su //切换为管理员</span><br><span class="line">exit //推出管理员权限</span><br></pre></td></tr></table></figure>

<p>在命令前加<code>sudo</code>也可以使用管理员权限</p>
<ol start="2">
<li>创建目录</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -m 目录名</span><br><span class="line">mkdir -r /home/hh # -r 可以递归的创建目录</span><br></pre></td></tr></table></figure>

<p>3.删除目录或者文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -i 文件名</span><br><span class="line">rm -r 目录名 #主要用来删除目录</span><br><span class="line">rm -f 文件名 #强制删除</span><br></pre></td></tr></table></figure>

<p>4.切换路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /  #切换到根目录</span><br><span class="line">cd ~  #切换到家目录</span><br><span class="line">cd /home/xxx  </span><br></pre></td></tr></table></figure>

<p>5.gedit 记事本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gedit main.c</span><br></pre></td></tr></table></figure>

<p>6.查看文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat main.c #查看文件内容并输出到shell终端</span><br><span class="line">cat -A 文件名  #隐藏的字符也可以查看</span><br></pre></td></tr></table></figure>

<p>7.复制</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp -r 源文件 目标文件 #可以复制目录的所有文件</span><br></pre></td></tr></table></figure>

<p>8.移动或重命名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv [选项] 源文件 目标文件</span><br><span class="line">mv old.txt new.txt #重命名单个文件</span><br><span class="line">mv old_folder new_folder #重命名目录</span><br><span class="line">mv file.txt /home/user/documents/newfile.txt #移动文件到其他目录并重命名</span><br></pre></td></tr></table></figure>

<p>9.查看当前路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></table></figure>

<p>10.查看当前目录文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls [option]</span><br><span class="line">ls -a #查看所有文件，包括隐藏的</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="项目常用命令"><a href="#项目常用命令" class="headerlink" title="项目常用命令"></a>项目常用命令</h2><ul>
<li>解压缩</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf xx.tar.gz # 解压缩tar.gz文件，x为提取，v为详细信息，f即file</span><br></pre></td></tr></table></figure>

<ul>
<li>查看进程</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps au #查看所有进程</span><br><span class="line">ps aux|grep xx*</span><br></pre></td></tr></table></figure>

<ul>
<li>查找文件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">基本语法：find 搜索路径 选项 表达式</span></span><br><span class="line">find /path/to/search -name &quot;filename&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在当前目录及子目录查找名为<span class="string">&quot;example.txt&quot;</span>的文件</span></span><br><span class="line">find . -name &quot;example.txt&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用通配符查找所有.<span class="built_in">log</span>文件</span></span><br><span class="line">find /var/log -name &quot;*.log&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找指定用户拥有的文件</span></span><br><span class="line">find /home -user username</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找过去7天内修改的文件</span></span><br><span class="line">find /home/user -mtime -7</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用 find 命令查找最近修改的文件</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果你刚刚安装了软件，可以查找系统中最近被修改的文件：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找过去30分钟内修改的文件</span></span><br><span class="line">sudo find / -type f -mmin -30 2&gt;/dev/null</span><br></pre></td></tr></table></figure>

<p>查找文件还可以使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">whereis xx</span><br></pre></td></tr></table></figure>

<ul>
<li>安装软件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i 文件名.deb #安装的默认路径为：/opt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看 dpkg 日志找出最近安装的包</span></span><br><span class="line">bashCopygrep &quot;install &quot; /var/log/dpkg.log | tail</span><br></pre></td></tr></table></figure>

<ul>
<li>挂载共享文件夹</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mount -t fuse.vmhgfs-fuse .host:/ /mnt/hgfs -o allow_other</span><br></pre></td></tr></table></figure>

<p><img src="/linux_BasicShellCmd/image-20250302110137834.png" alt="image-20250302110137834"></p>
<ul>
<li>安装和卸载</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install </span><br><span class="line">apt-get autoremove </span><br></pre></td></tr></table></figure>

<ul>
<li>编译和链接</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">编译c源码,以创建线程为例</span></span><br><span class="line">gcc thread1.c -o trl -lphread</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>gcc</code>: GNU编译器集合(GNU Compiler Collection)，这是一个常用的C&#x2F;C++编译器</p>
<p><code>thread1.c</code>: 源代码文件名，这是要被编译的C语言源文件</p>
<p><code>-o tr1</code>: 输出选项，指定编译后生成的可执行文件名为”tr1”</p>
<p><code>-lpthread</code>: 链接选项，告诉编译器链接POSIX线程库(pthread库)</p>
<p><strong>为什么要链接</strong>：</p>
<ul>
<li>当编译器看到你的代码引用了 pthread 库中的函数时，它需要知道这些函数的实现在哪里</li>
<li><code>-lpthread</code> 告诉链接器去寻找并链接 pthread 库</li>
<li>如果不链接这个库，链接器会报”未定义的引用”(undefined reference)错误</li>
</ul>
<p><strong>具体作用</strong></p>
<ul>
<li><code>-l</code> 是链接库的标志</li>
<li><code>pthread</code> 是库的名称（省略了前缀”lib”和后缀”.so”或”.a”）</li>
<li>实际上链接器会寻找 <code>libpthread.so</code>（共享库）或 <code>libpthread.a</code>（静态库）文件</li>
</ul>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>typora+hexo-asset-img插入文章图片</title>
    <url>/2025/02/18/blog_typora&amp;hexo-asset-img/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在使用hexo部署博客文章时，发现hexo默认的上传文件方式不太方便(如下)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% asset_img image.png name %&#125;</span><br></pre></td></tr></table></figure>

<p>于是上网搜索方案，发现typora配合其它转图片路径的插件的方案很方便，但是在试过<code>hexo-asset-image</code>和<code>hexo-renderer-marked</code>之后，发现直接在typora中粘贴图片(即markdown格式)还是无法在网页上显示图片。</p>
<p>以下是遇到的主要问题及解决方法</p>
<span id="more"></span>

<h2 id="问题1："><a href="#问题1：" class="headerlink" title="问题1："></a>问题1：</h2><p><strong>_post目录下如果在生成的.md目录插入图片就会生成两个同名的文件夹(实际上有一个后面多了一个空格)，导致默认的图片上传方式都出问题</strong></p>
<p><strong>原因及解决方案</strong>：在修改_config.yml文件中的<strong>post_asset_folder为true</strong>之后，如果使用<code>hexo new xxx</code>的方式生成.md文件和同名文件夹，且同时还将typora的偏好设置为<code>./$&#123;filename&#125;</code>，那么就会出现这样的问题，解决办法就是直接手动创建一个.md文件，只要插入图片，typora就自动会生成一个同名文件夹，并加图片放入。（<font color='red'>注意不要将post_asset_folder又设回false了</font>）</p>
<h2 id="问题2："><a href="#问题2：" class="headerlink" title="问题2："></a>问题2：</h2><p><strong>按照网上许多方法仍然无法直接使用<code>![](xx.png)</code>这种markdown格式插入图片</strong></p>
<p><strong>原因分析</strong>：<font color='red'>该问题的主要原因在于插件版本和hexo版本不一致</font>。在本地生成的静态网页中我们可以按”F12”查看图片路径是否转换成功。</p>
<img src="/2025/02/18/blog_typora&hexo-asset-img/image-20250218221232758.png" class="" title="F12查看图片路径">

<p>如图所示，&#x2F;2025&#x2F;02&#x2F;18&#x2F;player&#x2F;xx这个目录就是<code>hexo g</code>执行后生成到public目录下的。</p>
<ul>
<li>从文件中查看，如果该目录下没有我们文章中出现的图片，则说明图片上传失败；</li>
<li>而从网页端查看则如图所示，即图片源路径指向了对应的目录。</li>
</ul>
<p>上面两种方式都可以用来判断图片是否上传成功</p>
<p><strong>解决办法:</strong></p>
<p>由于我们使用的是hexo6.3.0版本，<code>hexo-asset-image</code>插件已经无法适配，所以这里直接下载另外一个<code>hexo-asset-img</code>插件即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-asset-img --save</span><br></pre></td></tr></table></figure>

<p>随后，按照问题1的方式创建.md文件，直接在typora中粘贴图片，即可实现图片和文章一起上传至博客网站.</p>
<p>在typora中图片插入的具体的格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![命名](与.md同名文件夹/logo.png)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>linux常用命令总结</title>
    <url>/2025/02/23/linux_BasicShellCmd/</url>
    <content><![CDATA[<p>总结了一些linux中常用的基本命令和项目中常用的命令</p>
<span id="more"></span>

<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><ul>
<li>shell ：即命令解释器，是用户和linux内核交互的桥梁，通过在shell终端输入命令让linux内核相应部分识别用户命令并处理。</li>
</ul>
<p>​	shell命令的基本格式为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">命令 [option] 参数 </span><br></pre></td></tr></table></figure>
<p>​	其中加”[]”符号表示可以不输入这个选项</p>
<p><strong>tips</strong>: </p>
<ul>
<li><p>对于不熟悉的命令可以使用<code>man 1 命令</code>或者<code>命令 --help</code>来查看说明</p>
</li>
<li><p>注意如果想要在windows复制并粘贴到linux虚拟机中，就要安装open-vm-tools，而vm-tools是老版的，重复安装这两个就会冲突，所以只安装open-vm-tools即可。对应命令为：</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install open-vm-tools-desktop</span><br></pre></td></tr></table></figure>

<p>​	以下给出几个vm-tools的区别</p>
<blockquote>
<p><strong>open-vm-tools</strong>：开源工具集，主要用于 Linux 虚拟机。</p>
<p><strong>vm-tools</strong>：VMware 提供的专有工具集，通常用于 VMware 产品。</p>
<p><strong>open-vm-tools-desktop</strong>：<code>open-vm-tools</code> 的桌面扩展版，专为桌面环境（有图形界面的 Linux）优化，提供更多图形相关的功能。</p>
</blockquote>
<p>linux磁盘相关文件系统，扩容等：<a href="https://blog.csdn.net/zhanhjxxx/article/details/123232402">Linux磁盘分区详解（新建分区，现有分区扩容，分区减容）_linux分区-CSDN博客</a></p>
<h2 id="基本常用命令"><a href="#基本常用命令" class="headerlink" title="基本常用命令"></a>基本常用命令</h2><ol>
<li>切换用户权限组</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo su //切换为管理员</span><br><span class="line">exit //推出管理员权限</span><br></pre></td></tr></table></figure>

<p>在命令前加<code>sudo</code>也可以使用管理员权限</p>
<ol start="2">
<li>创建目录</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -m 目录名</span><br><span class="line">mkdir -r /home/hh # -r 可以递归的创建目录</span><br></pre></td></tr></table></figure>

<p>3.删除目录或者文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -i 文件名</span><br><span class="line">rm -r 目录名 #主要用来删除目录</span><br><span class="line">rm -f 文件名 #强制删除</span><br></pre></td></tr></table></figure>

<p>4.切换路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /  #切换到根目录</span><br><span class="line">cd ~  #切换到家目录</span><br><span class="line">cd /home/xxx  </span><br></pre></td></tr></table></figure>

<p>5.gedit 记事本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gedit main.c</span><br></pre></td></tr></table></figure>

<p>6.查看文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat main.c #查看文件内容并输出到shell终端</span><br><span class="line">cat -A 文件名  #隐藏的字符也可以查看</span><br></pre></td></tr></table></figure>

<p>7.复制</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp -r 源文件 目标文件 #可以复制目录的所有文件</span><br></pre></td></tr></table></figure>

<p>8.移动或重命名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv [选项] 源文件 目标文件</span><br><span class="line">mv old.txt new.txt #重命名单个文件</span><br><span class="line">mv old_folder new_folder #重命名目录</span><br><span class="line">mv file.txt /home/user/documents/newfile.txt #移动文件到其他目录并重命名</span><br></pre></td></tr></table></figure>

<p>9.查看当前路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></table></figure>

<p>10.查看当前目录文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls [option]</span><br><span class="line">ls -a #查看所有文件，包括隐藏的</span><br></pre></td></tr></table></figure>

<ol start="11">
<li>显示磁盘空间使用情况</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">df -h</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="项目常用命令"><a href="#项目常用命令" class="headerlink" title="项目常用命令"></a>项目常用命令</h2><ul>
<li>解压缩</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf xx.tar.gz # 解压缩tar.gz文件，x为提取，v为详细信息，f即file</span><br></pre></td></tr></table></figure>

<ul>
<li>查看进程</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps au #查看所有进程</span><br><span class="line">ps aux|grep xx*</span><br></pre></td></tr></table></figure>

<ul>
<li>查找文件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">基本语法：find 搜索路径 选项 表达式</span></span><br><span class="line">find /path/to/search -name &quot;filename&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在当前目录及子目录查找名为<span class="string">&quot;example.txt&quot;</span>的文件</span></span><br><span class="line">find . -name &quot;example.txt&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用通配符查找所有.<span class="built_in">log</span>文件</span></span><br><span class="line">find /var/log -name &quot;*.log&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找指定用户拥有的文件</span></span><br><span class="line">find /home -user username</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找过去7天内修改的文件</span></span><br><span class="line">find /home/user -mtime -7</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用 find 命令查找最近修改的文件</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果你刚刚安装了软件，可以查找系统中最近被修改的文件：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找过去30分钟内修改的文件</span></span><br><span class="line">sudo find / -type f -mmin -30 2&gt;/dev/null</span><br></pre></td></tr></table></figure>

<p>查找文件还可以使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">whereis xx</span><br></pre></td></tr></table></figure>

<ul>
<li>安装软件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i 文件名.deb #安装的默认路径为：/opt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看 dpkg 日志找出最近安装的包</span></span><br><span class="line">grep &quot;install &quot; /var/log/dpkg.log | tail</span><br></pre></td></tr></table></figure>

<ul>
<li>挂载共享文件夹</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mount -t fuse.vmhgfs-fuse .host:/ /mnt/hgfs -o allow_other</span><br></pre></td></tr></table></figure>

<p>开机自动挂载共享文件夹参考下图：</p>
<img src="/2025/02/23/linux_BasicShellCmd/image-20250302110137834.png" class="" title="image-20250302110137834">

<ul>
<li>安装和卸载</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install </span><br><span class="line">apt-get autoremove </span><br></pre></td></tr></table></figure>

<ul>
<li>编译和链接</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">编译c源码,以创建线程为例</span></span><br><span class="line">gcc thread1.c -o trl -lphread</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>gcc</code>: GNU编译器集合(GNU Compiler Collection)，这是一个常用的C&#x2F;C++编译器</p>
<p><code>thread1.c</code>: 源代码文件名，这是要被编译的C语言源文件</p>
<p><code>-o tr1</code>: 输出选项，指定编译后生成的可执行文件名为”tr1”</p>
<p><code>-lpthread</code>: 链接选项，告诉编译器链接POSIX线程库(pthread库)</p>
<p><strong>为什么要链接</strong>：</p>
<ul>
<li>当编译器看到你的代码引用了 pthread 库中的函数时，它需要知道这些函数的实现在哪里</li>
<li><code>-lpthread</code> 告诉链接器去寻找并链接 pthread 库</li>
<li>如果不链接这个库，链接器会报”未定义的引用”(undefined reference)错误</li>
</ul>
<p><strong>具体作用</strong></p>
<ul>
<li><code>-l</code> 是链接库的标志</li>
<li><code>pthread</code> 是库的名称（省略了前缀”lib”和后缀”.so”或”.a”）</li>
<li>实际上链接器会寻找 <code>libpthread.so</code>（共享库）或 <code>libpthread.a</code>（静态库）文件</li>
</ul>
</blockquote>
<ul>
<li><p>软链接</p>
<p>作用1：允许从不同位置访问同一个文件或目录，而不需要复制数据，相当于创建快捷方式</p>
<p>作用2：，比如先转移文件到其它目录，再删除原路径的文件，这时创建一个软链接，确保依赖于旧路径的程序继续正常工作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果已有Downloads目录且有内容，先移动</span></span><br><span class="line">mv ~/Downloads/* /data/Downloads/ # 仅当Downloads有内容时</span><br><span class="line">rm -rf ~/Downloads # 删除原Downloads目录</span><br><span class="line">ln -s /data/Downloads ~/Downloads # 创建软链接</span><br></pre></td></tr></table></figure>

</li>
<li><p>网络相关</p>
<ul>
<li>查看网络的配置和状态</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure>

<ul>
<li>查看 socket、网络协议栈、网口以及路由表的信息</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-n表示以数字方式显示ip和端口</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-l表示只显示listen状态的socket</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-p表示显示进程信息</span></span><br><span class="line">netstat -nlp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#######################################</span></span></span><br><span class="line">ss -ntlp</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-n表示以数字方式显示ip和端口</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-t表示只显示tcp连接</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-l表示只显示listen状态的socket</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-p表示显示进程信息</span></span><br></pre></td></tr></table></figure>

<ul>
<li>查看协议栈的统计信息</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -s</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##或者</span></span></span><br><span class="line">ss -s</span><br></pre></td></tr></table></figure>

<ul>
<li><p>查看网络吞吐率和pps</p>
<blockquote>
<p><strong>网络吞吐率</strong>：单位事件内成功传输的数据量</p>
<p><strong>pps</strong>：packet per second</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sar -n DEV  #显示网口的统计数据</span><br><span class="line">sar -n EDEV	#显示关于网络错误的统计数据</span><br><span class="line">sar -n TCP	#显示 TCP 的统计数据</span><br><span class="line">ethtool eth0 | grep Speed	#查看eth0网卡带宽，单位为Mb/s</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
</li>
</ul>
<p>​	</p>
]]></content>
      <categories>
        <category>linux</category>
        <category>shell命令</category>
      </categories>
  </entry>
  <entry>
    <title>生产者-消费者模式</title>
    <url>/2025/03/07/thread__comsumer&amp;producer/</url>
    <content><![CDATA[<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>在介绍生产者-消费者模式之前，首先讲讲线程与进程的区别，以及互斥锁和条件变量、信号量</p>
<ul>
<li>线程：进程执行流的最小单元</li>
<li>进程：操作系统执行流的最小单元</li>
<li><strong>进程与线程的区别</strong>：<font color='mediumseagreen'>每个进程都有独立的内存空间，因此多进程将耗费大量系统资源，而线程只有栈区是独立的，堆区和数据都是共享的。</font>如下图所示</li>
</ul>
<span id="more"></span>

<img src="/2025/03/07/thread__comsumer&producer/image-20250307230213904.png" class="" title="image-20250307230213904">

<ul>
<li><p>线程销毁：在c中使用<code>pthread_detach()</code>来引导线程销毁，一般服务端不使用<code>pthread_join()</code>，因为该函数会一直阻塞等待线程终止，而对于服务端来说是不能这样阻塞的。</p>
</li>
<li><p>互斥锁：主要用于线程安全，可以通过创建互斥锁，并将需要保护的临界区使用<code>lock</code>和<code>unlock</code>围住，<strong>当前线程在执行临界区代码时，其它线程会进入阻塞状态。</strong><font color='red'>防止同一变量被多个线程同时操作，导致混乱</font></p>
</li>
<li><p>条件变量：和互斥锁配合使用，主要用于消费者-生产者模式，实现线程同步</p>
</li>
<li><p>信号量: 定义两个信号量，并将初值分别初始化为0，1，也可以实现线程同步. 调用一次<code>sem_wait()</code>对应的信号量就减1，当信号量值已经为0了，如果又运行到<code>sem_wait()</code>就会阻塞，直到<code>sem_post()</code>运行，给该信号量值+1。</p>
</li>
</ul>
<h2 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h2><p>我们直接通过代码来进行分析</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生产者-消费者问题</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 共享缓冲区</span></span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; buffer;</span><br><span class="line"><span class="comment">// 最大缓冲区大小</span></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> BUFFER_SIZE = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 互斥锁和条件变量</span></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv_producer;</span><br><span class="line">std::condition_variable cv_consumer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者线程函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> product = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待缓冲区有空位</span></span><br><span class="line">        cv_producer.<span class="built_in">wait</span>(lock, []() &#123; <span class="keyword">return</span> buffer.<span class="built_in">size</span>() &lt; BUFFER_SIZE; &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生产数据并放入缓冲区</span></span><br><span class="line">        product++;</span><br><span class="line">        buffer.<span class="built_in">push</span>(product);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Producer &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; produced: &quot;</span> &lt;&lt; product &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知消费者有数据可取</span></span><br><span class="line">        cv_consumer.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放锁，生产间隔一段时间（模拟生产过程）</span></span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者线程函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待缓冲区有数据</span></span><br><span class="line">        cv_consumer.<span class="built_in">wait</span>(lock, []() &#123; <span class="keyword">return</span> !buffer.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费数据</span></span><br><span class="line">        <span class="type">int</span> consumed_product = buffer.<span class="built_in">front</span>();</span><br><span class="line">        buffer.<span class="built_in">pop</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Consumer &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; consumed: &quot;</span> &lt;&lt; consumed_product &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知生产者缓冲区有空位</span></span><br><span class="line">        cv_producer.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放锁，消费间隔一段时间（模拟消费过程）</span></span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">150</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建生产者和消费者线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">producer1</span><span class="params">(producer, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">producer2</span><span class="params">(producer, <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">consumer1</span><span class="params">(consumer, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">consumer2</span><span class="params">(consumer, <span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让主线程等待生产者和消费者线程（通常不会结束）</span></span><br><span class="line">    producer<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    producer<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    consumer<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    consumer<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的输出结果为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Producer 1 produced: 1</span><br><span class="line">Producer 2 produced: 1</span><br><span class="line">Consumer 1 consumed: 1</span><br><span class="line">Consumer 2 consumed: 1</span><br><span class="line">Producer 2 produced: 2</span><br><span class="line">Producer 1 produced: 2</span><br><span class="line">Consumer 1 consumed: 2</span><br><span class="line">Consumer 2 consumed: 2</span><br><span class="line">Producer 1 produced: 3</span><br><span class="line">Producer 2 produced: 3</span><br><span class="line">Consumer 1 consumed: 3</span><br><span class="line">Consumer 2 consumed: 3</span><br><span class="line">Producer 1 produced: 4</span><br><span class="line">Producer 2 produced: 4</span><br><span class="line">.....</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>执行流程</strong></li>
</ul>
<blockquote>
<p><strong><font color='mediumseagreen'>假设消费者先获得锁：</font></strong></p>
<ol>
<li><p>消费者调用<code>std::unique_lock&lt;std::mutex&gt; lock(mtx)</code>获取锁</p>
</li>
<li><p>消费者执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cv_consumer.wait(lock, []() &#123; return !buffer.empty(); &#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>由于<code>buffer.empty()</code>为真，<code>!buffer.empty()</code>为假</li>
<li>消费者会释放锁并进入等待状态</li>
</ul>
</li>
<li><p>此时锁被释放，生产者可以获取锁</p>
</li>
</ol>
<p><strong><font color='mediumseagreen'>生产者获得锁：</font></strong></p>
<ol>
<li><p>生产者调用<code>std::unique_lock&lt;std::mutex&gt; lock(mtx)</code>获取锁</p>
</li>
<li><p>生产者执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cv_producer.wait(lock, []() &#123; return buffer.size() &lt; BUFFER_SIZE; &#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>由于<code>buffer.size() &lt; BUFFER_SIZE</code>为真（缓冲区为空）</li>
<li>生产者不阻塞，继续执行</li>
</ul>
</li>
<li><p>生产者放入数据：<code>buffer.push(product)</code></p>
</li>
<li><p>生产者调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cv_consumer.notify_all()</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>关键点</strong>：这里仅发送通知，不会立即唤醒消费者线程</li>
<li>消费者线程仍在等待状态，只有当锁被释放后才会被唤醒</li>
</ul>
</li>
<li><p>生产者通过<code>lock.unlock()</code>释放锁</p>
</li>
<li><p><strong>这时</strong>消费者线程才会被唤醒并尝试重新获取锁</p>
</li>
</ol>
<p><strong><font color='mediumseagreen'>消费者被唤醒：</font></strong></p>
<ol>
<li><p>消费者获取锁</p>
</li>
<li><p>消费者重新检查条件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">!buffer.empty()</span><br></pre></td></tr></table></figure>

<ul>
<li>由于缓冲区现在有数据，条件为真</li>
</ul>
</li>
<li><p>消费者从缓冲区取出数据并处理</p>
</li>
<li><p>消费者调用<code>cv_producer.notify_all()</code>通知生产者</p>
</li>
<li><p>消费者通过<code>lock.unlock()</code>释放锁</p>
</li>
</ol>
</blockquote>
<p><strong>在这里我们使用了互斥锁保护了临界区</strong>，如下所示，在多线程运行的情况下，通过互斥锁保证了buffer中数据是正常的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//生产者中</span></span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line"><span class="comment">// 等待缓冲区有空位</span></span><br><span class="line">cv_producer.<span class="built_in">wait</span>(lock, []() &#123; <span class="keyword">return</span> buffer.<span class="built_in">size</span>() &lt; BUFFER_SIZE; &#125;);</span><br><span class="line"><span class="comment">// 生产数据并放入缓冲区</span></span><br><span class="line">product++;</span><br><span class="line">buffer.<span class="built_in">push</span>(product);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Producer &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; produced: &quot;</span> &lt;&lt; product &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">// 通知消费者有数据可取</span></span><br><span class="line">cv_consumer.<span class="built_in">notify_all</span>();</span><br><span class="line"><span class="comment">// 释放锁，生产间隔一段时间（模拟生产过程）</span></span><br><span class="line">lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者中</span></span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line"><span class="comment">// 等待缓冲区有数据</span></span><br><span class="line">cv_consumer.<span class="built_in">wait</span>(lock, []() &#123; <span class="keyword">return</span> !buffer.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line"><span class="comment">// 消费数据</span></span><br><span class="line"><span class="type">int</span> consumed_product = buffer.<span class="built_in">front</span>();</span><br><span class="line">buffer.<span class="built_in">pop</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Consumer &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; consumed: &quot;</span> &lt;&lt; consumed_product &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">// 通知生产者缓冲区有空位</span></span><br><span class="line">cv_producer.<span class="built_in">notify_all</span>();</span><br><span class="line"><span class="comment">// 释放锁，消费间隔一段时间（模拟消费过程）</span></span><br><span class="line">lock.<span class="built_in">unlock</span>();</span><br></pre></td></tr></table></figure>

<p>此外，我们还需要注意以下几点：</p>
<blockquote>
<p><strong>条件变量通知后不会立即执行</strong>：当线程A调用<code>notify_all()</code>时，线程B不会立即从等待状态恢复执行。线程B只有在线程A释放锁后才有机会获取锁并检查条件。</p>
<p><strong>条件变量始终与锁配合使用</strong>：</p>
<ul>
<li><code>wait()</code>操作会自动释放锁</li>
<li>被通知唤醒后，线程会重新尝试获取锁</li>
<li>获取锁成功后，会再次检查条件</li>
</ul>
<p><strong>条件变量防止虚假唤醒</strong>：<code>wait()</code>函数的谓词参数(lambda函数)用于防止虚假唤醒。即使线程被错误地唤醒，它也会检查条件是否真的满足。</p>
<p><strong>通知只是发信号，不会立即触发执行</strong>：通知只是告诉等待的线程”可能满足条件了”，被通知的线程仍然需要:</p>
<ul>
<li>等待当前持有锁的线程释放锁</li>
<li>获取锁</li>
<li>重新检查条件是否满足</li>
</ul>
<p><strong>线程的栈区是独立的</strong>，所以两个生产者输出的produced才会是独立的，而其它全局区数据是多线程共享的</p>
</blockquote>
]]></content>
      <categories>
        <category>线程</category>
        <category>线程同步</category>
      </categories>
  </entry>
</search>
