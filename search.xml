<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>播放器总结</title>
    <url>/2025/02/18/AVDev_player/</url>
    <content><![CDATA[<h2 id="1-播放器实现概述"><a href="#1-播放器实现概述" class="headerlink" title="1. 播放器实现概述"></a>1. 播放器实现概述</h2><p>[<strong>搬运请标注出处</strong>⚠]一个播放器实现大致可以分为两块，即ui主界面，播放器功能模块。这两个模块之间还可以添加其它的模块进行解耦等，例如bilibili的开源项目ijkplayer的框架就是: UI主界面—ijkplayer核心—ffplayer。其中ijkplayer作为ui主界面和ffplayer之间的中转站(<strong>实际ijkplayer核心中也可以处理部分回调的消息，并不需要所有的消息都回到主界面的消息循环函数中处理</strong>)。下文将提炼ijkplayer和ffplay的源码，并主要谈谈qt环境下ijkplayer与ffplay两者不同之处以及相同之处 。(后续对音视频理解更深了会继续更新)</p>
<blockquote>
<p>qt中实现ijkplayer：<a href="https://blog.csdn.net/yan_chenglong/article/details/136422632">超详细讲解IJKPlayer的播放器实战和源码分析-CSDN博客</a></p>
</blockquote>
<span id="more"></span>

<img src="/2025/02/18/AVDev_player/image-20250218222315603.png" class="" title="image-20250218222315603">

<h3 id="1-1-按下播放按钮到视频播放的过程"><a href="#1-1-按下播放按钮到视频播放的过程" class="headerlink" title="1.1 按下播放按钮到视频播放的过程"></a>1.1 按下播放按钮到视频播放的过程</h3><p>播放按钮到视频播放这一个功能实现大概分为以下过程</p>
<blockquote>
<ul>
<li><p>按钮按下，发送信号给对应的响应函数(这其中包含了qt的信号槽机制，即信号的传递过程为：按钮点击 -&gt; QPushButton::clicked信号触发 -&gt; 控件对应响应函数执行，emit自定义信号SigPlayOrPauseBtnClicked-&gt; 主界面对应响应函数执行)</p>
<p>注意：connect在响应函数对应文件中完成.</p>
</li>
<li><p>主界面对应的(PlayOrPause)响应函数执行，完成创建播放器，设置播放源，准备播放(调用ijkmp_prepare_async函数)</p>
</li>
<li><p>在准备播放函数中(prepare_async())启用消息队列并创建消息循环线程(<strong>消息循环队列有解耦的作用</strong>)，接着调用真正的播放器ffplay的众多接口</p>
</li>
<li><p>在ffplay.cpp中调用stream_open(该函数主要完成初始化工作),接下来就是ffplay框架的一系列执行动作了，即完成解复用，解码，音频输出，视频图像显示，AVDev_同步等等（注意ffplay播放器read_thread还完成了将相关消息放到消息队列的过程，这样消息循环线程就可以取相应消息并让播放器完成相应的动作。）</p>
</li>
</ul>
</blockquote>
<p>整个ffplay的执行过程一图流如下：(参考八小时码字员)</p>
<img src="/2025/02/18/AVDev_player/image-20250218222358324.png" class="" title="image-20250218222358324">

<h3 id="1-2-ijkplayer主要的改进之处–消息循环机制"><a href="#1-2-ijkplayer主要的改进之处–消息循环机制" class="headerlink" title="1.2 ijkplayer主要的改进之处–消息循环机制"></a>1.2 ijkplayer主要的改进之处–消息循环机制</h3><p>相比于ffplay播放器，ijkplayer主要增加了一个独立的消息队列，在播放按键被按下后便会有一个消息循环线程一直执行。这里也给出一个qt环境下该机制的总结图解。</p>
<img src="/2025/02/18/AVDev_player/image-20250220210418225.png" class="" title="image-20250220210418225">

<p>上面循环机制中牵涉到了状态的转换，而播放器状态的检查主要在ijkplayer的<code>ijkmp_prepare_async_l</code>和<code>ikjmp_chkst_start_l</code>函数中，即如果状态为错误状态，那么就会释放内存并结束，下面这张状态机图，描述了播放器状态转换的流程。</p>
<style>.aauwliobsofm{zoom: 50%;}</style><img src="/2025/02/18/AVDev_player/image-20250220210507008.png" class="aauwliobsofm" alt="image-20250220210507008">

<p>qt环境中，消息队列中的消息在message中被取出来，并通知上层ui主界面 ，而ijkplayer也需要通知上层的app处理消息，因此这里也给出添加注释后ijkplayer中的消息循环函数，以便读者区分。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//相当于主界面的消息循环函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">media_AVDev_player_msg_loop</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    @autoreleasepool &#123;<span class="comment">// 创建自动释放池以管理内存</span></span><br><span class="line">        IjkMediaAVDev_player *mp = (IjkMediaAVDev_player*)arg; </span><br><span class="line">        <span class="comment">// 创建一个弱引用的播放器控制器，避免循环引用</span></span><br><span class="line">        __weak IJKFFMovieAVDev_playerController *ffpController = <span class="built_in">ffplayerRetain</span>(<span class="built_in">ijkmp_set_weak_thiz</span>(mp, <span class="literal">NULL</span>));</span><br><span class="line">        <span class="comment">// 消息循环主体，当控制器存在时持续运行</span></span><br><span class="line">        <span class="keyword">while</span> (ffpController) &#123;</span><br><span class="line">            @autoreleasepool &#123;<span class="comment">// 为每次循环创建独立的自动释放池</span></span><br><span class="line">                <span class="comment">// 获取一个新的消息对象</span></span><br><span class="line">                IJKFFMovieAVDev_playerMessage *msg = [ffpController obtainMessage];</span><br><span class="line">                <span class="keyword">if</span> (!msg)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                </span><br><span class="line">			   <span class="comment">// 从消息队列中获取消息，timeout为1</span></span><br><span class="line">                <span class="type">int</span> retval = <span class="built_in">ijkmp_get_msg</span>(mp, &amp;msg-&gt;_msg, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// block-get should never return 0</span></span><br><span class="line">                <span class="built_in">assert</span>(retval &gt; <span class="number">0</span>);	<span class="comment">// 确保消息获取成功</span></span><br><span class="line">                <span class="comment">// 通知app上层处理消息. 在主线程上异步处理消息事件</span></span><br><span class="line">                [ffpController performSelectorOnMainThread:@<span class="built_in">selector</span>(postEvent:) withObject:msg waitUntilDone:NO];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 减少播放器引用计数并释放资源</span></span><br><span class="line">        <span class="comment">// retained in prepare_async, before SDL_CreateThreadEx</span></span><br><span class="line">        <span class="built_in">ijkmp_dec_ref_p</span>(&amp;mp);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-解复用"><a href="#2-解复用" class="headerlink" title="2.解复用"></a>2.解复用</h2><blockquote>
<p>因为从read_thread开始，ijkplayer主要是按照ffplay的流程写的，所以下面也基本按照ffplay的总结了。</p>
</blockquote>
<p>在stream_open函数中创建读数据线程read_thread();解复用在该线程中完成</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">is-&gt;read_tid = <span class="built_in">SDL_CreateThreadEx</span>(&amp;is-&gt;_read_tid, read_thread, ffp, <span class="string">&quot;ff_read&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>—-&gt;来到read_thread()中</p>
<blockquote>
<p>引用<a href="https://www.jianshu.com/p/daf0a61cc1e0">ijkplayer框架深入剖析 - 简书</a></p>
<p><strong>read_thread主要完成解复用，并得到解码前AVDev_流分开后各自的包队列。</strong></p>
<ol>
<li><p>创建上下文结构体，这个结构体是最上层的结构体，表示输入上下文</p>
   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ic = <span class="built_in">avformat_alloc_context</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置中断函数，如果出错或者退出，就可以立刻退出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ic-&gt;interrupt_callback.callback = decode_interrupt_cb;</span><br><span class="line">  ic-&gt;interrupt_callback.opaque = is;</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开文件，主要是探测协议类型，如果是网络文件则创建网络链接等</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">err = <span class="built_in">avformat_open_input</span>(&amp;ic, is-&gt;filename, is-&gt;iformat, &amp;ffp-&gt;format_opts);</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>探测媒体类型，可得到当前文件的封装格式，AVDev_编码参数等信息</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">err = <span class="built_in">avformat_find_stream_info</span>(ic, opts);</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开视频、音频解码器。在此会打开相应解码器，并创建相应的解码线程。</p>
   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stream_component_open</span>(ffp, st_index[AVMEDIA_TYPE_AUDIO]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>读取媒体数据，<strong>得到的是AVDev_分离的解码前数据</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ret = <span class="built_in">av_read_frame</span>(ic, pkt);</span><br><span class="line">  <span class="comment">//被读取出来的数据如果不入包队列PacketQueue就要释放,而且必须要手动释放packet的数据</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将AVDev_数据分别送入相应的queue中</p>
</li>
</ol>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (pkt-&gt;stream_index == is-&gt;audio_stream &amp;&amp; pkt_in_play_range) &#123;</span><br><span class="line">   <span class="built_in">packet_queue_put</span>(&amp;is-&gt;audioq, pkt);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pkt-&gt;stream_index == is-&gt;video_stream &amp;&amp; pkt_in_play_range &amp;&amp; !(is-&gt;video_st &amp;&amp; (is-&gt;video_st-&gt;disposition &amp; AV_DISPOSITION_ATTACHED_PIC))) &#123;</span><br><span class="line">   <span class="built_in">packet_queue_put</span>(&amp;is-&gt;videoq, pkt);</span><br><span class="line">    ......</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">av_packet_unref</span>(pkt);<span class="comment">//释放pkt的数据</span></span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p>重复6、7步，即可不断获取待播放的数据。</p>
</blockquote>
<h2 id="3-解码"><a href="#3-解码" class="headerlink" title="3. 解码"></a>3. 解码</h2><style>.udmgehfkdyhj{zoom: 67%;}</style><img src="/2025/02/18/AVDev_player/image-20250220224325219.png" class="udmgehfkdyhj" alt="image-20250220224325219">

<ul>
<li>解码定义：<strong>将压缩的视频&#x2F;音频数据转换回原始的未压缩格式</strong></li>
</ul>
<p>在stream_component_open()中启动了几个解码线程,分别为音频解码线程audio_thread, 视频解码线程video_thread，字母解码线程subtitle_thread</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实际线程创建是在decoder_start中</span></span><br><span class="line"><span class="comment">//static int decoder_start(Decoder *d, int (*fn)(void *), const char *thread_name, void* arg)</span></span><br><span class="line">d-&gt;decoder_tid = <span class="built_in">SDL_CreateThread</span>(fn, thread_name, arg);    <span class="comment">// 创建解码线程</span></span><br></pre></td></tr></table></figure>

<p><strong>stream_component_open函数作用：</strong></p>
<ul>
<li><p>包含decode_init和decoder_start</p>
</li>
<li><p><strong>打开对应的解码器</strong>并作初始化</p>
</li>
<li><p><strong>创建和启动解码线程(audio_thread, video_thread)</strong></p>
</li>
<li><p><strong>初始化音频或视频输出设备(audio_open)</strong></p>
</li>
</ul>
<h3 id="3-1视频解码线程video-thread"><a href="#3-1视频解码线程video-thread" class="headerlink" title="3.1视频解码线程video_thread"></a>3.1视频解码线程video_thread</h3><p>该线程的总体流程为：</p>
<blockquote>
<ol>
<li>获取stream timebase，以便将frame的pts转成秒为单位(注意这里frame定义为<code>AVFrame *frame = av_frame_alloc();</code>，即解码后的帧数据)</li>
<li>获取帧率，以便计算每帧picture的duration</li>
<li>获取解码后的视频帧，具体调⽤**get_video_frame()**实现</li>
<li>计算帧持续时间和换算pts值为秒</li>
<li>将解码后的视频帧插⼊队列，具体调⽤queue_picture()实现</li>
<li><strong>释放frame对应的数据</strong>(<code>av_frame_free(&amp;frame);</code>)</li>
</ol>
</blockquote>
<ul>
<li><p>get_video_frame()函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">get_video_frame</span><span class="params">(VideoState *is, AVFrame *frame)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> got_picture;</span><br><span class="line">	<span class="comment">// 1. 获取解码后的视频帧</span></span><br><span class="line">	<span class="keyword">if</span> ((got_picture = <span class="built_in">decoder_decode_frame</span>(&amp;is-&gt;viddec, frame, <span class="literal">NULL</span></span><br><span class="line">)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 返回-1意味着要退出解码线程, 所以要分析decoder_decode_frame什么情况下返回-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (got_picture) &#123;</span><br><span class="line">	<span class="comment">//分析获取到的该帧是否要drop掉, 该机制的⽬的是在放⼊帧队列前先drop掉过时的视频帧</span></span><br><span class="line">		.....</span><br><span class="line"> 	&#125;</span><br><span class="line">	<span class="keyword">return</span> got_picture;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>​	其中<code>decoder_decode_frame</code>是ffplay封装好的函数,其中就有了<code>avcodec_send_packet</code>往解码器发送解复用后的包队列数据，和<code>avcodec_receive_frame</code>接收解码后的帧</p>
<ul>
<li>get_video_frame()函数的流程为：</li>
</ul>
<blockquote>
<p>1.调⽤decoder_decode_frame 解码并获取解码后的视频帧；(要拿到⼀帧解码数据，或解码出错、⽂件结束，才会返回。)</p>
<p>2.分析如果获取到帧是否需要drop掉（逻辑就是如果刚解出来就落后主时钟，那就没有必要放⼊Frame队<br>列，再拿去播放，但是丢帧也是有⼀定的条件的.</p>
<p><strong>即需要以下因素都成立才丢帧</strong></p>
<ul>
<li><p>!isnan(diff)：当前pts和主时钟的差值是有效值</p>
</li>
<li><p>fabs(diff) &lt; AV_NOSYNC_THRESHOLD：差值在可同步范围内，这⾥设置的是10秒，意思是如果差<br>值太⼤这⾥就不管了了，可能流本身录制的时候就有问题，这⾥不能随便把帧都drop掉；</p>
</li>
<li><p>diff - is-&gt;frame_last_filter_delay &lt; 0：和过滤器有关系，不设置过滤器时简化为 diff &lt; 0;</p>
</li>
<li><p>is-&gt;viddec.pkt_serial &#x3D;&#x3D; is-&gt;vidclk.serial：解码器的serial和时钟的serial相同，即是⾄少显示了<br>⼀帧图像，因为只有显示的时候才调⽤update_video_pts()设置到video clk的serial；</p>
</li>
<li><p>is-&gt;videoq.nb_packets：⾄少packetqueue有1个包。</p>
</li>
</ul>
</blockquote>
<ul>
<li>decoder_decode_frame函数</li>
</ul>
<p>​	该函数内部有一个循环，循环主要分成以下3个步骤</p>
<blockquote>
<ol>
<li><p>同⼀播放序列流连续的情况下(即d-&gt;queue-&gt;serial &#x3D;&#x3D; d-&gt;pkt_serial)，不断调⽤avcodec_receive_frame获取解码后的frame。取到帧就直接返回1，错误返回0</p>
</li>
<li><p>获取⼀个packet，如果播放序列不⼀致(数据不连续，即d-&gt;queue-&gt;serial !&#x3D; d-&gt;pkt_serial)则过滤掉“过时”的packet。这个过滤操作具体为</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 2.1 如果没有数据可读则唤醒read_thread, 实际是continue_read_thread SDL_cond</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;queue-&gt;nb_packets == <span class="number">0</span>)  <span class="comment">// 没有数据可读</span></span><br><span class="line">        <span class="built_in">SDL_CondSignal</span>(d-&gt;empty_queue_cond);<span class="comment">// 通知read_thread(生产者线程)放入packet</span></span><br><span class="line">    <span class="comment">// 阻塞式读取packet,这里就对应“过滤”操作</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    packet_queue_get内部有一个等待线程，即SDL_CondWait(q-&gt;cond, q-&gt;mutex);（设置block=1了，所以是阻塞模式，需要等待数据）。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">packet_queue_get</span>(d-&gt;queue, &amp;pkt, <span class="number">1</span>, &amp;d-&gt;pkt_serial) &lt; <span class="number">0</span>) <span class="comment">// block=1 表示使用阻塞模式</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//返回-1表示队列被标记为中止了</span></span><br><span class="line">&#125; <span class="keyword">while</span> (d-&gt;queue-&gt;serial != d-&gt;pkt_serial);<span class="comment">// 如果不是同一播放序列(流不连续)则继续读取</span></span><br></pre></td></tr></table></figure>

<p>补充：packet_queue_get函数</p>
<p>​	packet_queue_get 返回小于0的情况：</p>
<ul>
<li>队列被标记为中止（abort_request &#x3D; 1）</li>
<li>队列被销毁或无效</li>
<li>发生了系统错误</li>
<li>播放器请求停止</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">packet_queue_get</span><span class="params">(PacketQueue *q, AVPacket *pkt, <span class="type">int</span> block, <span class="type">int</span> *serial)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="built_in">SDL_LockMutex</span>(q-&gt;mutex);  <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 检查队列状态</span></span><br><span class="line">        <span class="keyword">if</span> (q-&gt;abort_request) &#123;</span><br><span class="line">            ret = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 尝试获取数据包</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">av_fifo_size</span>(q-&gt;pkt_list) &gt;= <span class="built_in">sizeof</span>(MyAVPacketList)) &#123;</span><br><span class="line">            <span class="comment">// 有数据可读，读取数据包</span></span><br><span class="line">            ret = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没有数据可读</span></span><br><span class="line">        <span class="keyword">if</span> (!block) &#123;  <span class="comment">// 非阻塞模式</span></span><br><span class="line">            ret = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 阻塞模式：等待数据</span></span><br><span class="line">        <span class="built_in">SDL_CondWait</span>(q-&gt;cond, q-&gt;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SDL_UnlockMutex</span>(q-&gt;mutex);  <span class="comment">// 解锁</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将packet送⼊解码器</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">avcodec_send_packet</span>(d-&gt;avctx, &amp;pkt);</span><br></pre></td></tr></table></figure></li>
</ol>
</blockquote>
<h3 id="3-2-音频解码线程audio-thread"><a href="#3-2-音频解码线程audio-thread" class="headerlink" title="3.2 音频解码线程audio_thread"></a>3.2 音频解码线程audio_thread</h3><p>解码后的音频帧frame放入音频帧队列sampq。音频解码流程和视频相差不大</p>
<p>注意几个frame结构体的区别：</p>
<ul>
<li><p>AVFrame(结构体): 可以看作解码后数据的最基本单位</p>
</li>
<li><p>Frame(结构体)：还包含了视频控制信息，其中包含了AVFrame</p>
</li>
<li><p>FrameQueue(结构体):其中包含了一个数据队列，用于存放Frame类型数据</p>
</li>
</ul>
<p>下面为audio_thread中代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((got_frame = <span class="built_in">decoder_decode_frame</span>(&amp;is-&gt;auddec, frame, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> the_end;</span><br><span class="line">    <span class="keyword">if</span> (got_frame) &#123;</span><br><span class="line">        tb = &#123; <span class="number">1</span>, frame-&gt;sample_rate &#125;; <span class="comment">//采样率一般是44.1khz</span></span><br><span class="line">        <span class="comment">//af是队列中的一个槽slot）作为队列中的一个容器，用于存储解码后的帧信息（如 pts、duration</span></span><br><span class="line">        <span class="keyword">if</span> (!(af = <span class="built_in">frame_queue_peek_writable</span>(&amp;is-&gt;sampq)))</span><br><span class="line">            <span class="keyword">goto</span> the_end;</span><br><span class="line">        <span class="comment">// 计算 PTS（显示时间戳</span></span><br><span class="line">        <span class="comment">// 将解码后的PTS 从采样点数转换为秒，即af-&gt;pts = 当前对应采样点* 1/采样率</span></span><br><span class="line">        af-&gt;pts = (frame-&gt;pts == AV_NOPTS_VALUE) ? NAN : frame-&gt;pts * <span class="built_in">av_q2d</span>(tb);<span class="comment">//av_q2d(tb)前一个除以后一个数</span></span><br><span class="line">        <span class="comment">// 设置帧位置和序列号</span></span><br><span class="line">        af-&gt;pos = <span class="built_in">av_frame_get_pkt_pos</span>(frame);<span class="comment">//获取帧对应的数据包在文件中的字节位置</span></span><br><span class="line">        af-&gt;serial = is-&gt;auddec.pkt_serial;</span><br><span class="line">        <span class="comment">// 计算帧持续时间（样本数/采样率）</span></span><br><span class="line">        af-&gt;duration = <span class="built_in">av_q2d</span>(&#123; frame-&gt;nb_samples, frame-&gt;sample_rate &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//AVframe和AVpacket都是结构体，一般定义一个指向其的指针。引用计数主要就是为了避免不同的指针指向同一空间(浅拷贝问题)时</span></span><br><span class="line">        <span class="comment">// 会导致的内存重复释放问题。</span></span><br><span class="line">        <span class="built_in">av_frame_move_ref</span>(af-&gt;frame, frame); <span class="comment">//frame是解码后得到的帧(数据类型为指向AVFrame的指针)，af-&gt;frame是Frame结构体中的指向AVFrame的指针，这里将解码后的帧数据全都转移到Frame中去</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//解码后的帧传递给播放线程</span></span><br><span class="line">        <span class="built_in">frame_queue_push</span>(&amp;is-&gt;sampq); <span class="comment">//进入该函数唤醒msg_queue_get()取消息</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (ret &gt;= <span class="number">0</span> || ret == <span class="built_in">AVERROR</span>(EAGAIN) || ret == AVERROR_EOF);<span class="comment">//AVERROR(EAGAIN)需要更多数据</span></span><br></pre></td></tr></table></figure>

<p>注意音频解码中，设置时间基<code>tb = (AVRational)&#123;1, frame-&gt;sample_rate&#125;;</code> ，而视频解码中设置时间基为<code>stream-&gt;base_base</code>。实际上在decoder_decode_frame()函数中</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//decoder_decode_frame()函数中	</span></span><br><span class="line"><span class="keyword">case</span> AVMEDIA_TYPE_AUDIO:</span><br><span class="line">    ret = <span class="built_in">avcodec_receive_frame</span>(d-&gt;avctx, frame);</span><br><span class="line">    <span class="keyword">if</span> (ret &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        AVRational tb = &#123;<span class="number">1</span>, frame-&gt;sample_rate&#125;;    <span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span> (frame-&gt;pts != AV_NOPTS_VALUE) &#123;</span><br><span class="line">            <span class="comment">// 如果frame-&gt;pts正常则先将其从pkt_timebase转成&#123;1, frame-&gt;sample_rate&#125;</span></span><br><span class="line">            <span class="comment">// pkt_timebase实质就是stream-&gt;time_base</span></span><br><span class="line">            frame-&gt;pts = <span class="built_in">av_rescale_q</span>(frame-&gt;pts, d-&gt;avctx-&gt;pkt_timebase, tb);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (d-&gt;next_pts != AV_NOPTS_VALUE) &#123;</span><br><span class="line">            <span class="comment">// 如果frame-&gt;pts不正常则使用上一帧更新的next_pts和next_pts_tb</span></span><br><span class="line">            <span class="comment">// 转成&#123;1, frame-&gt;sample_rate&#125;</span></span><br><span class="line">            frame-&gt;pts = <span class="built_in">av_rescale_q</span>(d-&gt;next_pts, d-&gt;next_pts_tb, tb);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (frame-&gt;pts != AV_NOPTS_VALUE) &#123;</span><br><span class="line">            <span class="comment">// 根据当前帧的pts和nb_samples预估下一帧的pts</span></span><br><span class="line">            d-&gt;next_pts = frame-&gt;pts + frame-&gt;nb_samples;</span><br><span class="line">            d-&gt;next_pts_tb = tb; <span class="comment">// 设置timebase</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>从上可以看出来，将audio frame从decoder_decode_frame取出来后，已由stream-&gt;time_base转成了{1, frame-&gt;sample_rate}作为time_base。</p>
<h2 id="4-AVDev-输出"><a href="#4-AVDev-输出" class="headerlink" title="4. AVDev_输出"></a>4. AVDev_输出</h2><h3 id="4-1-音频输出"><a href="#4-1-音频输出" class="headerlink" title="4.1 音频输出"></a>4.1 音频输出</h3><p>播放流程总结：</p>
<blockquote>
<p>[SDL音频设备] -&gt; [需要数据] -&gt; [调用sdl_audio_callback] -&gt; [从音频队列获取数据] -&gt; [填充到设备缓冲区] -&gt; [播放]</p>
</blockquote>
<p>在ffplay中，音频输出的函数调用结构为</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在read_thread()函数中</span></span><br><span class="line">--&gt;stream_componet_open</span><br><span class="line">	--&gt;audio_open   <span class="comment">//SDL_OpenAudio,打开音频输出设备</span></span><br><span class="line">    	--&gt;sdl_audio_callback <span class="comment">//音频pcm数据回调函数</span></span><br><span class="line">       		--&gt;audio_decode_frame <span class="comment">//该函数从解码后的帧队列中取一帧并放到audio_buf中，以供sdl回调函数取数据</span></span><br></pre></td></tr></table></figure>

<p>而在ijkplayer中，ffplay.c这部分是将“音频输出”这个消息放到消息队列，并由主界面的message_loop读取消息。</p>
<p>下面一步步分析这几个函数的流程</p>
<ul>
<li><p>stream_component_open中</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* prepare audio output */</span></span><br><span class="line"><span class="comment">//打开音频流</span></span><br><span class="line"><span class="keyword">if</span> ((ret = <span class="built_in">audio_open</span>(is, channel_layout, nb_channels, sample_rate, &amp;is-&gt;audio_tgt)) &lt; <span class="number">0</span>)<span class="comment">//调用audio_open,其中有sdl回调函数</span></span><br><span class="line">    <span class="keyword">goto</span> fail;</span><br><span class="line">is-&gt;audio_hw_buf_size = ret;<span class="comment">//音频硬件设备的缓冲区大小.</span></span><br><span class="line">is-&gt;audio_src = is-&gt;audio_tgt; <span class="comment">////暂且将数据源参数等同于⽬标输出参数</span></span><br><span class="line"><span class="comment">//初始化audio_buf相关参数</span></span><br><span class="line">is-&gt;audio_buf_size = <span class="number">0</span>;</span><br><span class="line">is-&gt;audio_buf_index = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>在这里牵涉了几个缓存区</p>
<blockquote>
<ul>
<li>audio_buf</li>
</ul>
<p>​    audio_decode_frame从解码后的音频帧队列sampq取pcm数据，并存入audio_buf指向的内存空间</p>
<ul>
<li>audio_buf1</li>
</ul>
<p>​    audio_decode_frame函数重采样机制定义的指针，audio_buf1指向重采样后的数据</p>
<ul>
<li>audio_hw_buf</li>
</ul>
<p>​    SDL_audio_callback取数据就存入该音频设备缓存区(在该函数中audio_decode_frame取的pcm是数据后面都会拷贝到stream指向的内存空间，这个内存空间就是音频设备缓存区)</p>
<hr>
<p>对应的几个size</p>
<ul>
<li>audio_buf_size: audio_buf的总⼤⼩，有效的PCMsize</li>
<li>audio_buf_index: 下⼀次可读的audio_buf的index位置。</li>
<li>audio_write_buf_size：audio_buf剩余的buffer⻓度，即audio_buf_size - audio_buf_index</li>
<li>audio_buf1_size:  在audio_decode_frame中申请的缓冲区大小(所以该大小代表最初buf的上限大小)，经过重采样后得到缓存区大小就是audio_buf_size</li>
</ul>
</blockquote>
</li>
<li><p>audio_open()函数中</p>
</li>
</ul>
<p>​	设置期望的输出参数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">wanted_spec.format = AUDIO_S16SYS; <span class="comment">//sdl支持的音频采样点格式</span></span><br><span class="line">wanted_spec.silence = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//sample是一次回调处理的采样点数</span></span><br><span class="line"><span class="comment">//例如1024表示一次回调处理1024个采样点</span></span><br><span class="line">wanted_spec.samples = <span class="built_in">FFMAX</span>(SDL_AUDIO_MIN_BUFFER_SIZE, <span class="number">2</span> &lt;&lt; <span class="built_in">av_log2</span>(wanted_spec.freq / <span class="built_in">SDL_AoutGetAudioPerSecondCallBacks</span>(ffp-&gt;aout)));</span><br><span class="line">wanted_spec.callback = sdl_audio_callback; <span class="comment">//回调</span></span><br><span class="line">wanted_spec.userdata = opaque; <span class="comment">//用户数据</span></span><br></pre></td></tr></table></figure>

<p>​	打开音频设备</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SDL_OpenAudio 是 SDL 1.2 的接口，较为简单;</span></span><br><span class="line"><span class="comment">//SDL_AoutOpenAudio 是 SDL 2.0 中更先进的音频设备管理接口</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">SDL_AoutOpenAudio</span>(ffp-&gt;aout, &amp;wanted_spec, &amp;spec) &lt; <span class="number">0</span>) &#123;<span class="comment">//打开音频设备</span></span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	设置重采样要输出的格式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//audio_hw_params就是做重采样要输出的参数格式</span></span><br><span class="line">audio_hw_params-&gt;fmt = AV_SAMPLE_FMT_S16;</span><br><span class="line">audio_hw_params-&gt;freq = spec.freq;</span><br><span class="line">audio_hw_params-&gt;channel_layout = wanted_channel_layout;</span><br><span class="line">audio_hw_params-&gt;channels =  spec.channels;</span><br><span class="line"><span class="comment">//frame_size为一个音频样本点的大小(单位为字节)</span></span><br><span class="line">audio_hw_params-&gt;frame_size = <span class="built_in">av_samples_get_buffer_size</span>(<span class="literal">NULL</span>, audio_hw_params-&gt;channels, <span class="number">1</span>, audio_hw_params-&gt;fmt, <span class="number">1</span>);</span><br><span class="line"><span class="comment">//计算每秒的字节数</span></span><br><span class="line">audio_hw_params-&gt;bytes_per_sec = <span class="built_in">av_samples_get_buffer_size</span>(<span class="literal">NULL</span>, audio_hw_params-&gt;channels, audio_hw_params-&gt;freq, audio_hw_params-&gt;fmt, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>​	返回输出设备缓存区的大小（这个缓冲区在音频需要变速的场景下很有用，因为回调函数每次获取的数据量是固定的，但是变速后音频帧队列每帧的采样点数量会改变，从而导致输出设备变速的数据大小和SDL回调取的数据大小不一致）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> spec.size; <span class="comment">//单位为字节</span></span><br></pre></td></tr></table></figure>

<p><code>spec.size = wanted_sepc.sample * channels * frame_size</code></p>
<p>例如一帧采样点为1024，双通道，音频格式为是s16，则<code>spec.size = 1024*2*2</code></p>
<ul>
<li>回调函数sdl_audio_callback</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//stream 拷贝pcm数据的指针</span></span><br><span class="line"><span class="comment">//len    需要拷贝的长度</span></span><br><span class="line"><span class="comment">//static void sdl_audio_callback(void *opaque, Uint8 *stream, int len)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//主要逻辑</span></span><br><span class="line"><span class="comment">//len初始长度就是spec.size</span></span><br><span class="line"><span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;<span class="comment">//循环取数据，直接达到要求的大小</span></span><br><span class="line">    <span class="comment">//音频缓冲区已经被读取完，需要重新从队列（sampq）中获取新的音频数据来继续播放。</span></span><br><span class="line">    <span class="keyword">if</span> (is-&gt;audio_buf_index &gt;= is-&gt;audio_buf_size) &#123;</span><br><span class="line">        <span class="comment">//从音频帧队列sampq中取pcm数据，大小为audio_size，注意单位是字节，输出不是采样点个数</span></span><br><span class="line">        audio_size = <span class="built_in">audio_decode_frame</span>(ffp); <span class="comment">//真正有效的pcm数据大小</span></span><br><span class="line">        <span class="keyword">if</span> (audio_size &lt; <span class="number">0</span>) &#123;<span class="comment">//没有数据了</span></span><br><span class="line">            <span class="comment">/* if error, just output silence */</span></span><br><span class="line">            <span class="comment">//静音</span></span><br><span class="line">            is-&gt;audio_buf = <span class="literal">NULL</span>;</span><br><span class="line">            is-&gt;audio_buf_size = SDL_AUDIO_MIN_BUFFER_SIZE / is-&gt;audio_tgt.frame_size * is-&gt;audio_tgt.frame_size;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (is-&gt;show_mode != SHOW_MODE_VIDEO)</span><br><span class="line">                <span class="built_in">update_sample_display</span>(is, (<span class="type">int16_t</span> *)is-&gt;audio_buf, audio_size);</span><br><span class="line">            <span class="comment">//audio_size即为audio_decode_frame返回的(重采样)实际输出数据大小(单位为字节)</span></span><br><span class="line">            is-&gt;audio_buf_size = audio_size; <span class="comment">//audio_buf的大小</span></span><br><span class="line">        &#125;</span><br><span class="line">        is-&gt;audio_buf_index = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (is-&gt;auddec.pkt_serial != is-&gt;audioq.serial) &#123;</span><br><span class="line">        is-&gt;audio_buf_index = is-&gt;audio_buf_size;</span><br><span class="line">        <span class="built_in">memset</span>(stream, <span class="number">0</span>, len);</span><br><span class="line">        <span class="comment">// stream += len;</span></span><br><span class="line">        <span class="comment">// len = 0;</span></span><br><span class="line">        <span class="built_in">SDL_AoutFlushAudio</span>(ffp-&gt;aout);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// len1就是目前audio_buf还剩下的长度</span></span><br><span class="line">    len1 = is-&gt;audio_buf_size - is-&gt;audio_buf_index; </span><br><span class="line">    <span class="keyword">if</span> (len1 &gt; len) <span class="comment">//如果还剩下的长度比还要取的数据长度大</span></span><br><span class="line">        len1 = len; <span class="comment">//需要多少给多少</span></span><br><span class="line">    <span class="comment">//如果不需要静音且audio_buf不为空且音量最大则直接拷贝数据</span></span><br><span class="line">    <span class="keyword">if</span> (!is-&gt;muted &amp;&amp; is-&gt;audio_buf &amp;&amp; is-&gt;audio_volume == SDL_MIX_MAXVOLUME)</span><br><span class="line">        <span class="built_in">memcpy</span>(stream, (<span class="type">uint8_t</span> *)is-&gt;audio_buf + is-&gt;audio_buf_index, len1);<span class="comment">//数据拷贝</span></span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//调整音频</span></span><br><span class="line">        <span class="built_in">memset</span>(stream, <span class="number">0</span>, len1);</span><br><span class="line">        <span class="keyword">if</span> (!is-&gt;muted &amp;&amp; is-&gt;audio_buf)</span><br><span class="line">            <span class="built_in">SDL_MixAudio</span>(stream, (<span class="type">uint8_t</span> *)is-&gt;audio_buf + is-&gt;audio_buf_index, len1, is-&gt;audio_volume);</span><br><span class="line">    &#125;</span><br><span class="line">    len -= len1;  <span class="comment">//减去每次读取的数据</span></span><br><span class="line">    stream += len1; <span class="comment">//stream拷贝数据的位置也做相应的位移</span></span><br><span class="line">    is-&gt;audio_buf_index += len1; <span class="comment">//audio_buf_index位置也更新</span></span><br><span class="line">&#125;</span><br><span class="line">is-&gt;audio_write_buf_size = is-&gt;audio_buf_size - is-&gt;audio_buf_index;</span><br><span class="line"> <span class="comment">/* Let&#x27;s assume the audio driver that is used by SDL has two periods. */</span></span><br><span class="line"><span class="comment">//设置音频同步的时钟  </span></span><br><span class="line"><span class="comment">//set_clock_at</span></span><br><span class="line">    <span class="keyword">if</span> (!std::<span class="built_in">isnan</span>(is-&gt;audio_clock)) &#123;</span><br><span class="line">        <span class="type">double</span> audio_clock = is-&gt;audio_clock / pVideoCtl-&gt;<span class="built_in">ffp_get_playback_rate</span>();</span><br><span class="line">        pVideoCtl-&gt;<span class="built_in">set_clock_at</span>(&amp;is-&gt;audclk, audio_clock  - (<span class="type">double</span>)(<span class="number">2</span> * is-&gt;audio_hw_buf_size + is-&gt;audio_write_buf_size) / is-&gt;audio_tgt.bytes_per_sec, is-&gt;audio_clock_serial, audio_callback_time / <span class="number">1000000.0</span>);</span><br><span class="line">        pVideoCtl-&gt;<span class="built_in">sync_clock_to_slave</span>(&amp;is-&gt;extclk, &amp;is-&gt;audclk);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>audio_decode_frame</li>
</ul>
<p>​	该函数主要完成的功能为：</p>
<p>1.从sampq取⼀帧，必要时丢帧。如发⽣了seek，此时serial会不连续，就需要丢帧处理</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(af = <span class="built_in">frame_queue_peek_readable</span>(&amp;is-&gt;sampq)))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">frame_queue_next</span>(&amp;is-&gt;sampq); <span class="comment">//获取下一帧，丢帧的前提就是下一帧存在</span></span><br><span class="line">&#125; <span class="keyword">while</span> (af-&gt;serial != is-&gt;audioq.serial); <span class="comment">//数据不连续</span></span><br></pre></td></tr></table></figure>

<p>2.计算这⼀帧的字节数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">data_size = <span class="built_in">av_samples_get_buffer_size</span>(<span class="literal">NULL</span>, af-&gt;frame-&gt;channels,</span><br><span class="line">                                       af-&gt;frame-&gt;nb_samples,   <span class="comment">//af指向Frame类型结构体</span></span><br><span class="line">                                       af-&gt;frame-&gt;format, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>3.获取这⼀帧的数据。对于frame格式和输出设备不同的，需要重采样；如果格式相同，则直接拷⻉指针输出即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//，重采样是否需要初始化在前面有进行判断，如果sdl支持的格式和采的解码音频帧格式不同就重采样</span></span><br><span class="line"><span class="keyword">if</span> (is-&gt;swr_ctx) &#123;</span><br><span class="line"> ....<span class="comment">//省略前面的   </span></span><br><span class="line">	is-&gt;audio_buf = is-&gt;audio_buf1;</span><br><span class="line">        <span class="type">int</span> bytes_per_sample = <span class="built_in">av_get_bytes_per_sample</span>(is-&gt;audio_tgt.fmt);</span><br><span class="line">    <span class="comment">//重采样后返回的实际数据大小resampled_data_size。单位为字节，len2是重采样后单个声道的采样点数</span></span><br><span class="line">    resampled_data_size = len2 * is-&gt;audio_tgt.channels * bytes_per_sample; </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">//如果不需要重采样</span></span><br><span class="line">	 is-&gt;audio_buf = af-&gt;frame-&gt;data[<span class="number">0</span>];</span><br><span class="line">      resampled_data_size = data_size;	    </span><br><span class="line">&#125;</span><br><span class="line">is-&gt;audio_buf = is-&gt;audio_buf1;</span><br></pre></td></tr></table></figure>

<hr>
<p>该部分重采样的逻辑可阅读阅读查看，这里省略</p>
<p>最后返回的resampled_data_size就是重采样后实际的audio_buf大小。</p>
<p>4.更新audio_clock，audio_clock_serial。⽤于设置audclk.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* update the audio clock with the pts */</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">isnan</span>(af-&gt;pts))</span><br><span class="line">    is-&gt;audio_clock = af-&gt;pts + (<span class="type">double</span>) af-&gt;frame-&gt;nb_samples / af-&gt;frame-&gt;sample_rate;<span class="comment">//audio_clock指向这一帧的末尾</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    is-&gt;audio_clock = NAN;</span><br><span class="line">is-&gt;audio_clock_serial = af-&gt;serial;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-视频输出"><a href="#4-2-视频输出" class="headerlink" title="4.2 视频输出"></a>4.2 视频输出</h3><p>在ffplay中，视频输出的函数调用结构为</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//主函数中</span></span><br><span class="line">--&gt;<span class="built_in">event_loop</span>() <span class="comment">//</span></span><br><span class="line">	--&gt;<span class="built_in">refresh_loop_wait_event</span>() <span class="comment">//视频在这里显示</span></span><br><span class="line">		 --&gt;<span class="built_in">video_refresh</span>() </span><br><span class="line">			 --&gt;<span class="built_in">video_display</span>() </span><br><span class="line">				 --&gt;<span class="built_in">video_image_display</span>() </span><br><span class="line">					 --&gt;<span class="built_in">upload_texture</span>()    </span><br></pre></td></tr></table></figure>

<p>ffplay中使用可以跨平台的SDL作为显示的SDK</p>
<p>因此第一步就是SDL初始化—即先<code>SDL_Init</code>,创建窗口(<code>SDL_CreateWindow</code>)，创建渲染器(<code>SDL_CreateRenderer</code>)</p>
<p>随后主函数调用stream_open，开启<strong>read_thread()<strong>数据读取线程,并调用播放控制相应循环</strong>event_loop</strong></p>
<p>与视频画面输出有关的函数解析如下</p>
<ul>
<li>read_thread中（包含画面窗口的设置）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//7 从待处理流中获取相关参数，设置显示窗口的宽度、高度及宽高比</span></span><br><span class="line"><span class="keyword">if</span> (st_index[AVMEDIA_TYPE_VIDEO] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    AVStream *st = ic-&gt;streams[st_index[AVMEDIA_TYPE_VIDEO]];</span><br><span class="line">    AVCodecParameters *codecpar = st-&gt;codecpar;</span><br><span class="line">    <span class="comment">//根据流和帧宽高比猜测视频帧单个像素宽高比（像素的宽高比，注意不是图像的）</span></span><br><span class="line">    AVRational sar = <span class="built_in">av_guess_sample_aspect_ratio</span>(ic, st, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (codecpar-&gt;width) &#123;</span><br><span class="line">        <span class="comment">// 设置显示窗口的大小和宽高比</span></span><br><span class="line">        <span class="built_in">set_default_window_size</span>(codecpar-&gt;width, codecpar-&gt;height, sar);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> set_default_window_size设置了窗口的宽，高，同时还调用<code>calculate_display_rect(&amp;rect, 0, 0, max_width,max_height, width, height, sar);</code>获取了显示区域的起始坐标和大小</p>
<ul>
<li>refresh_loop_wait_event()</li>
</ul>
<p>视频画面显示逻辑部分，在event_loop()被调用。</p>
<p>设置休眠等待时间</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> remaining_time = <span class="number">0.0</span>;</span><br></pre></td></tr></table></figure>

<p>抽取输入设备的事件到事件队列中,并再次通过参数SDL_GETEVENT⾮阻塞查询队列中是否有事件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">SDL_PumpEvents</span>();</span><br><span class="line"><span class="comment">////////</span></span><br><span class="line"><span class="built_in">SDL_PeepEvents</span>(event, <span class="number">1</span>, SDL_GETEVENT, SDL_FIRSTEVENT, S</span><br><span class="line">DL_LASTEVENT)</span><br></pre></td></tr></table></figure>

<p>如果返回值不为0则有时间发生，函数要返回让event_loop处理事件，否则就调用video_refresh显示画面</p>
<ul>
<li>video_refresh</li>
</ul>
<p>该函数图解如下</p>
<style>.evggqbmuijvm{zoom: 67%;}</style><img src="/2025/02/18/AVDev_player/image-20250221174757834.png" class="evggqbmuijvm" alt="image-20250221174757834">

<p>几个时间戳关系如下：</p>
<p>(<strong>注意丢帧之前一定要保证下一帧存在</strong>)</p>
<style>.fztveorbpbsi{zoom:50%;}</style><img src="/2025/02/18/AVDev_player/image-20250221174324289.png" class="fztveorbpbsi" alt="image-20250221174324289">

<ul>
<li>video_display</li>
</ul>
<p>其中调用的下层函数不再过多介绍，主要的显示逻辑就要使用<code>video_image_display(is)</code>来显示一帧视频画面.该函数先<code>frame_queue_peek_last</code>取要显示的帧，然后upload_texture 更新图像数据到SDL_Texture(如果是解码图片帧队列像素格式不是sdl支持的像素格式，就要做图像格式转换<code>sws_scale</code>)，最后通过SDL_RenderCopyEx 拷⻉纹理给render显示。</p>
<p><strong>tips:</strong></p>
<ul>
<li><p>当改变播放器窗口大小时，视频的显示宽高比能保持正常的原因就在于—–利用视频解码层保存的<strong>原始视频宽高比信息</strong>(SAR，每个像素的宽高比)，并在视频画面输出时通过<code>calculate_display_rect</code>计算视频正确的显示宽高比(DAR ).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 转成真正的播放⽐例</span></span><br><span class="line">aspect_ratio = <span class="built_in">av_mul_q</span>(aspect_ratio, <span class="built_in">av_make_q</span>(pic_width, pic_height));</span><br></pre></td></tr></table></figure>

<p>这样当窗口大小变化时，渲染层也会按照上面计算出来的播放比例就行等比例缩放。</p>
</li>
<li><p>以ffplay为例，窗口大小改变时，由upload_texture中的sws_scale来对原始数据（解码后的数据）进⾏缩放</p>
</li>
</ul>
<hr>
<p>下面也给出了参考ijkplayer，画面刷新逻辑的流程图</p>
<style>.qjkfiwrnxsuk{zoom: 50%;}</style><img src="/2025/02/18/AVDev_player/image-20250221210703870.png" class="qjkfiwrnxsuk" alt="image-20250221210703870">

<h2 id="5-AVDev-同步"><a href="#5-AVDev-同步" class="headerlink" title="5. AVDev_同步"></a>5. AVDev_同步</h2><p>同步方式主要分为：</p>
<ul>
<li>以视频为主导</li>
<li>以音频为主导</li>
<li>以外部时钟为主导</li>
</ul>
<h3 id="以音频为主导"><a href="#以音频为主导" class="headerlink" title="以音频为主导"></a>以音频为主导</h3><p>由于人耳对于声音的敏感度相比视频更高，所以一般都是以音频为主导进行同步。下面也只介绍这一种同步方式（ffplay中的案例）</p>
<p>视频与音频的同步主要通过音频的显示时间戳来维护一个参考时间轴，这样视频就可以通过与该轴上的时间戳进行比较，以判断是播快了，还是播慢了。下面讲讲代码中具体是怎么做的</p>
<ul>
<li><p>在ffplay中，音频显示时间戳audclk是在sdl回调函数中维护</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sdl_audio_callback中</span></span><br><span class="line"><span class="keyword">if</span> (!std::<span class="built_in">isnan</span>(is-&gt;audio_clock)) &#123;</span><br><span class="line">    <span class="type">double</span> audio_clock = is-&gt;audio_clock / pVideoCtl-&gt;<span class="built_in">ffp_get_playback_rate</span>();</span><br><span class="line">    pVideoCtl-&gt;<span class="built_in">set_clock_at</span>(&amp;is-&gt;audclk, audio_clock  - (<span class="type">double</span>)(<span class="number">2</span> * is-&gt;audio_hw_buf_size + is-&gt;audio_write_buf_size) / is-&gt;audio_tgt.bytes_per_sec, is-&gt;audio_clock_serial, audio_callback_time / <span class="number">1000000.0</span>);</span><br><span class="line">    pVideoCtl-&gt;<span class="built_in">sync_clock_to_slave</span>(&amp;is-&gt;extclk, &amp;is-&gt;audclk); <span class="comment">//is-&gt;audclk就是音频显示时间戳pts</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在ffplay中，视频同步的逻辑主要在video_refresh()中完成。假如当**前系统时间time(audclk来维系的时间轴)**是介于vp帧起始时间戳和nextvp帧起始事件戳之间，那么就正常播放这一帧；当视频播放慢了(即time&gt; timer + lastvp的duration)，就丢掉当前vp帧，取nextvp帧(<strong>丢帧的前提就是存在nextvp帧</strong>，注意如果视频慢特别多，即当前图片的时间戳与参考的时间戳差值很多，才是直接丢帧，如果差的小就快速渲染当前帧并马上显示下一帧)；如果视频播放快了，就重复播放上一帧,即lastvp</p>
</li>
</ul>
<h2 id="6-其它功能"><a href="#6-其它功能" class="headerlink" title="6. 其它功能"></a>6. 其它功能</h2><ul>
<li><p>暂停：图片的暂停就是重复显示上一帧，而声音的暂停则是直接在<code>audio_decode_frame</code>函数中返回-1，回调函数取数据的缓存区audio_buf为空就按静音处理</p>
</li>
<li><p>逐帧播放step的本质就是播放一帧暂停</p>
</li>
<li><p>音量调节本质就是控制采样点的幅值(通过SDL_MixAudioFormat 调整音量，静音通过将音量设为0实现)</p>
</li>
<li><p>快进和快退的本质是seek到某个点重新开始播放</p>
<ul>
<li>ffplay通过 av_seek_frame() 实现跳转</li>
<li>需要清空解码器缓存和播放队列</li>
<li>重新计算AVDev_同步时间戳</li>
</ul>
</li>
</ul>
<h3 id="变速"><a href="#变速" class="headerlink" title="变速"></a>变速</h3><ul>
<li><p>音频倍速可以改变音频的采样率，采样率越高，每s采的样本点越多，每个样本点的持续时间就越短，速度就越快，但是这样会使声调变高；更好的方式是采用<strong>时间拉伸</strong>（Time Stretching）</p>
<p>对应的变速算法讲解可以参考<a href="https://xie.infoq.cn/article/d71ced957347f6f70f3c0775d">音频变速变调-sonic源码分析_音视频_floer rivor_InfoQ写作社区</a></p>
</li>
</ul>
<blockquote>
<p><strong>时间拉伸</strong></p>
<ul>
<li><strong>原理</strong>：通过算法拉伸或压缩音频时长，保持音调不变。常用算法如：<ul>
<li><strong>WSOLA（Waveform Similarity Overlap-and-Add）</strong>：通过寻找相似波形片段进行重叠拼接。(<strong>soundtouch就是通过这种算法写的</strong>)</li>
<li><strong>Phase Vocoder</strong>：在频域调整音频时长，适用于音乐等复杂信号。</li>
</ul>
</li>
<li><strong>实现</strong>：使用开源库（如SoundTouch、Sonic或FFmpeg的<code>libavfilter</code>）直接处理PCM数据。</li>
</ul>
</blockquote>
<p>​		而视频倍速播放主要通过调整帧率或显示时间实现：</p>
<p>​		方法主要有如下</p>
<blockquote>
<p><strong>a. 跳帧（Frame Dropping）</strong></p>
<ul>
<li><strong>快放</strong>：丢弃部分帧（如2倍速时每秒显示60帧，原帧率30fps则每帧显示一次）。</li>
<li><strong>缺点</strong>：可能导致画面卡顿，需智能选择丢弃非关键帧（如B帧）。</li>
</ul>
<p><strong>b. 重复帧或插帧（Frame Interpolation）</strong></p>
<ul>
<li><strong>慢放</strong>：重复帧或生成中间帧（通过光流法、AI插帧算法）。</li>
<li><strong>缺点</strong>：插帧计算复杂度高，可能影响实时性。</li>
</ul>
<p><strong>c. 时间戳调整</strong></p>
<ul>
<li><strong>修改PTS&#x2F;DTS</strong>：调整每一帧的显示时间戳。例如，2倍速播放时，每帧的显示时间减半。</li>
<li><strong>实现</strong>：在解码后调整<code>AVFrame.pts</code>，确保渲染器按新时间戳播放。</li>
</ul>
</blockquote>
<p>我们的播放器变速主要基于sonic实现，sonic加速过程的核心是 <strong>去掉一些冗余数据点，同时保证听感上的连续性</strong>。Sonic 通过“基因周期”来分析音频信号的周期性，然后将相似的部分合并，使得音频的时间缩短，但不会让人觉得是简单的裁剪（否则会有“跳跃感”）。</p>
<ul>
<li><p>采样率没变，播放时间变短，所以听起来更快</p>
</li>
<li><p>通过音频信号的周期分析，避免简单裁剪带来的突兀感</p>
</li>
<li><p>Sonic 的方法是聪明地丢弃冗余数据，而不是机械地删点</p>
</li>
</ul>
]]></content>
      <categories>
        <category>技术开发</category>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>音视频</tag>
        <tag>ijkplayer</tag>
        <tag>ffplay</tag>
      </tags>
  </entry>
  <entry>
    <title>遍历排序与分治排序</title>
    <url>/2025/02/27/Algo_Sort/</url>
    <content><![CDATA[<p>总结了3种遍历排序与三种分治排序算法</p>
<p><strong>排序算法性质</strong>：</p>
<p><strong>自适应性</strong>：自适应排序能够利用输入已有的顺序信息来减少计算量，达到更优的时间效率</p>
<p><strong>稳定性</strong>：排序完成后，相等元素在数组中的顺序不发生改变</p>
<span id="more"></span>

<h2 id="遍历排序"><a href="#遍历排序" class="headerlink" title="遍历排序"></a>遍历排序</h2><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>思路：每次查找未排序区间的最小值，并与排序区间的尾部(实际这个位置是每轮外循环未排序区间的第一个位置)交换位置</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//外循环，未排序区间为[i,n-1],每轮未排序区间长度减1</span></span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++) &#123;<span class="comment">//最后一个不用排了</span></span><br><span class="line">    	<span class="type">int</span> k = i; <span class="comment">//未排序区间最小元素索引</span></span><br><span class="line">        <span class="comment">//内循环找未排序区间最小值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i<span class="number">+1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[k] &lt; nums[j]) &#123;</span><br><span class="line">                k = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[k]); <span class="comment">//将最小元素与未排序区间最小值交换</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度o(n^2),空间复杂度o(1)，非稳定性排序</li>
</ul>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>思路：每次冒泡都得到未排序区间的最大值，并交换至未排序区间的尾部，n个数冒泡n-1次即可(外循环次数),</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">//外循环，未排序区间[0,i]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n<span class="number">-1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>; <span class="comment">//标志</span></span><br><span class="line">   		<span class="comment">//内循环，交换最大值至未排序区间的末尾</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j<span class="number">+1</span>] &lt; nums[j]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[j],numss[j<span class="number">+1</span>]);</span><br><span class="line">                flage = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//本轮没有交换说明已经有序了，直接推出即可</span></span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;<span class="keyword">break</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度o(n^2), 有flag的情况下最佳时间复杂度o(n), 空间复杂度o(1)，稳定排序</li>
</ul>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>思路：在未排序区间选择一个基准元素，将其与左边的已排序区间比较，一直到左边元素不大于基准元素为止</p>
<style>.cpnfigllymhd{zoom:33%;}</style><img src="/2025/02/27/Algo_Sort/image-20250227120737150.png" class="cpnfigllymhd" alt="image-20250227120737150">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertionSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//外循环，已排序区间为[0,i-1]</span></span><br><span class="line">    <span class="comment">//初始状态，第一个元素已完成排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> base = nums[i], j = i<span class="number">-1</span>; </span><br><span class="line">    	<span class="comment">//内循环，将base插入到已排序区间</span></span><br><span class="line">		<span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &gt; base) &#123;</span><br><span class="line">            nums[j<span class="number">+1</span>] = nums[j]; <span class="comment">//右移一位</span></span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[j<span class="number">+1</span>] = base; <span class="comment">//插入base</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最差时间复杂度为o(n^2)，数据完全有序的情况下时间复杂度为o(n)，空间复杂度为o(1),稳定排序</p>
<img src="/2025/02/27/Algo_Sort/image-20250227132530692.png" class="" title="image-20250227132530692">

<hr>
<h2 id="分治排序"><a href="#分治排序" class="headerlink" title="分治排序"></a>分治排序</h2><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>思路：</p>
<ul>
<li><p>在未优化的情况下，快速排序的思路为先进行哨兵划分：即将数组最左边的元素nums[left]作为基准值，定义定义两个指针i,j,并分别初始化指向数组左边left和右边right，i从左往右找大于基准值的位置，j从右往左找小于基准值的位置，随后交换对应位置的值，并继续循环。  </p>
</li>
<li><p>进过哨兵划分之后，数组分成了两个子数组，接着递归这两个子数组即可。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//哨兵划分</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = left, j = right;</span><br><span class="line">    <span class="comment">//以nums[left]为基准值</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] &gt;= nums[left]) &#123; <span class="comment">//注意等于时也要移动</span></span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] &lt;= nums[left]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[j]);   															</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//i==j时，将基准值交换到i的位置</span></span><br><span class="line">    <span class="built_in">swap</span>(nums[left], nums[i]);</span><br><span class="line">    <span class="keyword">return</span> i; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//哨兵划分</span></span><br><span class="line">    <span class="comment">//左闭右闭</span></span><br><span class="line">    <span class="type">int</span> pivot = <span class="built_in">partition</span>(nums, left, right);</span><br><span class="line">    <span class="built_in">quickSort</span>(nums, left, pivot<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">queickSort</span>(nums, pivot<span class="number">+1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="易错点"><a href="#易错点" class="headerlink" title="易错点"></a>易错点</h4><blockquote>
<p>哨兵划分中，以下代码是错误的(即不能先从左往右搜索大于基准值的元素)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] &lt;= nums[left]) &#123;</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] &gt;= nums[left]) &#123;</span><br><span class="line">        --j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(nums[i], nums[j]);   															</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原因：</p>
<p>对于数组 <code>[5, 7, 8, 9, 6]</code>：</p>
<ol>
<li>初始状态：<code>[5, 7, 8, 9, 6]</code>，i &#x3D; 0，j &#x3D; 4，pivot &#x3D; 5</li>
<li>先从左往右搜：<ul>
<li>i &#x3D; 0, nums[0] &#x3D; 5 等于 pivot，i++</li>
<li>i &#x3D; 1, nums[1] &#x3D; 7 &gt; pivot，停止</li>
</ul>
</li>
<li>再从右往左搜：<ul>
<li>j &#x3D; 4, nums[4] &#x3D; 6 &gt; pivot，j–</li>
<li>j &#x3D; 3, nums[3] &#x3D; 9 &gt; pivot，j–</li>
<li>j &#x3D; 2, nums[2] &#x3D; 8 &gt; pivot，j–</li>
<li>j &#x3D; 1, 此时 i &#x3D; j，跳出循环</li>
</ul>
</li>
<li>交换 基准值nums[left] 和 nums[i]：i &#x3D; 1，所以交换 nums[0] 和 nums[1]： <code>[7, 5, 8, 9, 6]</code></li>
<li>返回 pivot 位置 1</li>
</ol>
<p>7 &gt; 5，但 7 被放到了 pivot 的左边，破坏了快速排序的分区性质，导致排序结果错误。</p>
</blockquote>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>在数组倒序的情况下，基准数左边或者右边数组长度为n-1，每次递归都会出现有一个子数组长度为0的情况，快速排序退化为类似冒泡排序，时间复杂度劣化为o(n^2)。</p>
<p>同样正序的情况下，也会出现有一个子数组长度为0的情况，每次递归长度为n-1的数组都只减少一个元素，递归深度为n-1，需要占用o(n)的栈帧空间</p>
<p>因此要对基准值和递归区间的选取进行优化：即选择数组左，中，右值的中位数作为基准值，选择对长度更短的子数组递归</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//选择基准数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">medianThree</span><span class="params">(vector&lt;<span class="type">int</span>&gt; nums, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = nums[left], m = nums[mid], r = nums[right];</span><br><span class="line">    <span class="keyword">if</span> ((l &lt;= m &amp;&amp; m &lt;= r) || (r &lt;= m &amp;&amp; m &lt;= l)) &#123;</span><br><span class="line">        <span class="keyword">return</span> mid;		     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((m &lt;= l &amp;&amp; l &lt;= r) || (r &lt;= l &amp;&amp; l &lt;= m)) &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//哨兵划分</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> median = <span class="built_in">medianThree</span>(nums, left, left+(right-left)/<span class="number">2</span> ,right); 	 </span><br><span class="line"> 	<span class="comment">//将数组交换至数组最左端</span></span><br><span class="line">    <span class="built_in">swap</span>(nums[median], nums[left]);</span><br><span class="line">   	<span class="comment">//后面一样，省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 子数组长度为1 时终止</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="comment">// 哨兵划分操作</span></span><br><span class="line">        <span class="type">int</span> pivot = <span class="built_in">partition</span>(nums, left, right);</span><br><span class="line">        <span class="comment">// 对两个子数组中较短的那个执行快速排序</span></span><br><span class="line">        <span class="keyword">if</span> (pivot - left &lt; right - pivot) &#123;</span><br><span class="line">            <span class="built_in">quickSort</span>(nums, left, pivot - <span class="number">1</span>); <span class="comment">// 递归排序左子数组</span></span><br><span class="line">            left = pivot + <span class="number">1</span>; <span class="comment">// 剩余未排序区间为[pivot + 1, right]</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">quickSort</span>(nums, pivot + <span class="number">1</span>, right); <span class="comment">// 递归排序右子数组</span></span><br><span class="line">            right = pivot - <span class="number">1</span>; <span class="comment">// 剩余未排序区间为[left, pivot - 1]  </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color='red'>注意</font>：</p>
<blockquote>
<p><font color='cornflowerblue'>1.得到中位数后，交换中位数与数组最左边元素的值之后，可以使用一个变量存储这个值再进行循环比较。</font></p>
<p>每次循环比较时，如果直接使用<code>nums[left]</code>，<font color='red'>编译器需要每次都访问数组并计算偏移量</font>。<strong>而存储在局部变量<code>pivotValue</code>中只需读取一次，可以减少内存访问，提高性能</strong>。在数组很大且循环次数多的情况下，这种优化是有意义的。（<strong>力扣912通过这个优化不会超时</strong>）</p>
<p><font color='cornflowerblue'>2.以下代码是错误的</font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 三数取中选择枢轴</span></span><br><span class="line">    <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> pivotIndex = <span class="built_in">medianThree</span>(nums, left, mid, right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将枢轴值移到最左边</span></span><br><span class="line">    <span class="built_in">swap</span>(nums[left], nums[pivotIndex]);</span><br><span class="line">    <span class="type">int</span> pivotValue = nums[left];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = left, j = right;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="comment">// 从右向左找第一个小于枢轴的元素</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] &gt;= pivotValue) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="comment">// 从左向右找第一个大于枢轴的元素</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] &lt;= pivotValue) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换这两个元素</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将枢轴值放到正确的位置</span></span><br><span class="line">    <span class="built_in">swap</span>(pivotValue, nums[i]);  <span class="comment">//错误！！应该是nums[left]和nums[i]交换</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原因：</p>
<p><strong>交换操作需要实际的数组元素位置</strong>，而不仅仅是值。<code>swap(nums[left], nums[i])</code>是在交换数组中两个位置的元素，而<code>pivotValue</code>只是一个存储值的变量，不是数组中的位置</p>
<p><font color='cornflowerblue'>3.随机选择基准点来应对特殊输入</font></p>
<p>如果每次选择的基准点都是当前区间的最大或最小值（例如在已排序数组上总是选择第一个元素），分区操作会导致极不平衡的子区间划分（一个子区间为空，另一个包含n-1个元素）。这会使时间复杂度退化到O(n²)。</p>
<p>只需在分区前随机选择一个元素作为基准点：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 随机选择基准点</span></span><br><span class="line">    <span class="type">int</span> randomIndex = left + <span class="built_in">rand</span>() % (right - left + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将随机选择的基准点交换到左端</span></span><br><span class="line">    <span class="built_in">swap</span>(nums[left], nums[randomIndex]);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> pivotValue = nums[left];</span><br><span class="line">    <span class="type">int</span> i = left, j = right;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 常规的分区过程</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] &gt;= pivotValue) j--;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] &lt;= pivotValue) i++;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">swap</span>(nums[left], nums[i]);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：</p>
<ul>
<li><p><strong>平均性能保证</strong>：随机选择使得算法性能不依赖于输入数据的特定模式，能够有效避免最坏情况的频繁出现。</p>
</li>
<li><p><strong>防御性编程</strong>：对抗恶意构造的输入数据，增强算法的健壮性。</p>
</li>
</ul>
<p><strong>概率分析</strong>：从理论上讲，随机快速排序的期望时间复杂度仍为O(n log n)，且这个期望适用于任何输入。</p>
<p><strong>简单直接</strong>：相比其他复杂的基准点选择策略，随机选择实现简单且效果显著。</p>
</blockquote>
<img src="/2025/02/27/Algo_Sort/image-20250227153337619.png" class="">



<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序的递归顺序和二叉树的后序遍历是一样的，即先递归左数组，再递归右数组，最后合并，注意合并时的子数组是有序的。一图总结如下：</p>
<style>.nughnopthebk{zoom: 67%;}</style><img src="/2025/02/27/Algo_Sort/image-20250227153030239.png" class="nughnopthebk" alt="image-20250227153030239">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//合并左右子数组,左数组[left, mid], 右数组[mid+1, right]</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = left, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//创建临时数组存放合并后数组</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tmp</span><span class="params">(right- left <span class="number">+1</span>)</span></span>;</span><br><span class="line">    <span class="comment">//左右数组都还有元素时进行比较</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">        <span class="comment">//将较小元素放入tmp</span></span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt;= nums[j]) &#123;</span><br><span class="line">            tmp[k++] = nums[i++]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp[k++] = nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将剩下元素放入tmp,注意i,j往后移动</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">        tmp[k++] = nums[i++]; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= right) &#123;</span><br><span class="line">        tmp[k++] = nums[j++]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将合并后放回到原数组对应位置</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; tmp.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        nums[left+i] = tmp[i]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//子数组长度为1时终止</span></span><br><span class="line">	<span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">//子数组划分</span></span><br><span class="line">    <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">mergeSort</span>(nums, left, mid); <span class="comment">//左</span></span><br><span class="line">    <span class="built_in">mergeSort</span>(nums, mid<span class="number">+1</span>, right); <span class="comment">//右</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对子数组进行合并</span></span><br><span class="line">    <span class="built_in">merge</span>(nums, left, mid, right);  <span class="comment">//中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度为o(n*logn)，递归深度logn,每层操作n次。  空间复杂度为o(n)，具体：栈帧空间占o(logn), 创建临时数组空间为o(n)</li>
</ul>
<p><font color='red'>归并排序特别适合链表排序</font>，在划分阶段可以使用迭代来代替递归，在合并阶段也不用创建额外的辅助数据，因为链表的合并只需要操作指针</p>
<h4 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148 排序链表"></a>148 排序链表</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//找到链表中点</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">findListMid</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast-&gt;next != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并左右子链表</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* left, ListNode* right)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>();<span class="comment">//虚拟头节点用于链表合并</span></span><br><span class="line">        ListNode* cur = dummyNode;</span><br><span class="line">        <span class="keyword">while</span> (left &amp;&amp; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left-&gt;val &lt;= right-&gt;val) &#123;</span><br><span class="line">                cur-&gt;next = left;</span><br><span class="line">                left = left-&gt;next;<span class="comment">//右移</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur-&gt;next = right;</span><br><span class="line">                right = right-&gt;next;</span><br><span class="line">            &#125;  </span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//链接剩下的节点</span></span><br><span class="line">        <span class="comment">//注意直接if链接就行，不用while</span></span><br><span class="line">        <span class="keyword">if</span> (left) cur-&gt;next = left;</span><br><span class="line">        <span class="keyword">if</span> (right) cur-&gt;next = right;</span><br><span class="line"></span><br><span class="line">        ListNode* result = dummyNode-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummyNode;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//归并排序</span></span><br><span class="line">        <span class="comment">//终止条件，空链表或者只有一个节点时终止</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* mid = <span class="built_in">findListMid</span>(head);</span><br><span class="line">        ListNode* right = mid-&gt;next;</span><br><span class="line">        mid-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        ListNode* leftSortedList = <span class="built_in">sortList</span>(head); <span class="comment">//递归左链表</span></span><br><span class="line">        ListNode* righSortedtList = <span class="built_in">sortList</span>(right); <span class="comment">//递归右链表</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">merge</span>(leftSortedList, righSortedtList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度为o(nlogn)</li>
<li>空间复杂度为栈帧空间o(logn)</li>
</ul>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>思路：</p>
<ul>
<li>先建立一个大顶堆，对数组执行堆化处理</li>
<li>交换堆顶元素和堆底元素,此时堆长度-1，已排序元素+1</li>
<li>堆顶元素从顶向下堆化</li>
<li>循环<strong>n-1</strong>次交换和堆化的过程</li>
</ul>
<p><strong>完全二叉树非常适合使用数组来表示</strong>，而堆就是一种特殊的完全二叉树，所以其底层实现就是数组。</p>
<style>.mtauuuawiodj{zoom: 50%;}</style><img src="/2025/02/27/Algo_Sort/image-20250227171531676.png" class="mtauuuawiodj" alt="image-20250227171531676">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//堆的长度为n，从节点i开始，从顶至底执行堆化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">siftDown</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> n, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">//索引i的左子节点为2i+1,右子节点为2i+2, 父节点索引为(i-1)/2</span></span><br><span class="line">        <span class="type">int</span> l = <span class="number">2</span>i<span class="number">+1</span>, r = <span class="number">2</span>i<span class="number">+2</span>;</span><br><span class="line">        <span class="type">int</span> ma = i; <span class="comment">//ma为i,l,r中值最大的节点索引</span></span><br><span class="line">        <span class="keyword">if</span> (l &lt; n &amp;&amp; nums[l] &gt;= nums[ma]) &#123;</span><br><span class="line">            ma = l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; n &amp;&amp; nums[r] &gt;= nums[ma]) &#123;</span><br><span class="line">           ma = r; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如节点i最大或l，r越界则无需继续堆化</span></span><br><span class="line">        <span class="keyword">if</span> (ma == i) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[ma]);</span><br><span class="line">        i = ma; <span class="comment">//循环进行堆化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">haepSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//建堆，堆化除叶子节点外所有节点</span></span><br><span class="line">    <span class="comment">//建堆的循环语句还可以从最后一个节点的父节点开始，即for (int i = (nums.size()- 1 - 1) / 2; i &gt;= 0; --i) &#123;&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = nums.<span class="built_in">size</span>() / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="comment">//从索引i开始从顶至底的执行堆化</span></span><br><span class="line">    	<span class="built_in">siftDown</span>(nums, nums.<span class="built_in">size</span>(), i); 	   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//循环n-1次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;<span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="comment">//交换堆顶元素与堆底元素</span></span><br><span class="line">        <span class="built_in">swap</span>(nums[<span class="number">0</span>], nums[i]); <span class="comment">//堆长度减1</span></span><br><span class="line">        <span class="built_in">siftDown</span>(nums, i, <span class="number">0</span>); <span class="comment">//从堆顶开始堆化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度o(nlogn)。输入列表并建堆操作的事件复杂度为o(n); 从堆中提取最大元素的时间复杂度为o(logn)(<strong>其实就是堆化的时间复杂度为o(logn)</strong>)。 </p>
<p><strong>补充</strong>：像堆排序这样直接将一个数组进行建堆是从底至顶的，而对于每个节点(除开叶子节点)来说，堆化却是从顶至底的。相比一个个输入元素再每次进行堆化(建堆时间复杂度为o(nlogn))的时间复杂度要小，因为叶子节点不用堆化。</p>
</li>
<li><p>原地排序，空间复杂度为o(1)</p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>冒泡排序通过交换相邻元素来实现排序。通过添加一个标志位来实现提前返回，我们可以将冒泡排序<br>的最佳时间复杂度优化到𝑂(𝑛) 。</li>
<li>插入排序每轮将未排序区间内的元素插入到已排序区间的正确位置，从而完成排序。虽然插入排序的<br>时间复杂度为𝑂(𝑛2) ，但由于单元操作相对较少，因此在小数据量的排序任务中非常受欢迎。</li>
<li>快速排序基于哨兵划分操作实现排序。在哨兵划分中，有可能每次都选取到最差的基准数，导致时间复<br>杂度劣化至𝑂(𝑛2) 。引入中位数基准数或随机基准数可以降低这种劣化的概率。尾递归方法可以有效<br>地减少递归深度，将空间复杂度优化到𝑂(log 𝑛) 。 </li>
<li>归并排序包括划分和合并两个阶段，典型地体现了分治策略。在归并排序中，排序数组需要创建辅助数<br>组，空间复杂度为𝑂(𝑛) ；然而排序链表的空间复杂度可以优化至𝑂(1) 。</li>
<li>桶排序包含三个步骤：数据分桶、桶内排序和合并结果。它同样体现了分治策略，适用于数据体量很大<br>的情况。桶排序的关键在于对数据进行平均分配。</li>
<li>计数排序是桶排序的一个特例，它通过统计数据出现的次数来实现排序。计数排序适用于数据量大但<br>数据范围有限的情况，并且要求数据能够转换为正整数。</li>
<li>基数排序通过逐位排序来实现数据排序，要求数据能够表示为固定位数的数字。</li>
</ul>
<p>总的来说，我们希望找到一种排序算法，具有高效率、稳定、原地以及自适应性等优点。然而，正如其<br>他数据结构和算法一样，没有一种排序算法能够同时满足所有这些条件。在实际应用中，我们需要根据<br>数据的特性来选择合适的排序算法</p>
<img src="/2025/02/27/Algo_Sort/image-20250414110458634.png" class="" title="image-20250414110458634">

<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>[1] hello-algo: 《Hello 算法》(<a href="https://github.com/krahets/hello-algo">https://github.com/krahets/hello-algo</a>)</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>排序</category>
      </categories>
  </entry>
  <entry>
    <title>AI提示词</title>
    <url>/2025/03/25/blog_AIprompt/</url>
    <content><![CDATA[<h2 id="提示词基本结构"><a href="#提示词基本结构" class="headerlink" title="提示词基本结构"></a>提示词基本结构</h2><p>即：角色+指令+上下文+输入问题+约束+例子+输出格式 。</p>
<span id="more"></span>

<p>1.角色(role) </p>
<blockquote>
<p>交互时通过给AI大模型设定某种角色，根据经验可以获得意想不到的效果，可以使大模型的输出更加具有个性化，专业化，同时能够增加模型输出的准确性。</p>
</blockquote>
<p>2.指示或者指令</p>
<blockquote>
<p> 是指示AI大模型需要完成的任务。</p>
</blockquote>
<p>3.上下文（context）</p>
<blockquote>
<p> 当你给出与任务相关的背景或细节时，可以帮助AI大模型更好的理解任务的具体情况，使得输出更加精确。</p>
</blockquote>
<p>4.输入或者问题</p>
<blockquote>
<p> 需要大模型执行具体的任务，或者具体的问题, 有时候如果指令部分描述的是具体的任务时，则指令部分就是输入。</p>
</blockquote>
<p>5.约束</p>
<blockquote>
<p> 有时候需要限制AI大模型的输出范围，设定一些约束条件，可以对输出进行控制。</p>
</blockquote>
<p>6.输出格式：</p>
<blockquote>
<p>主要给大模型指明，输出特定内容时的格式。</p>
</blockquote>
<p>7.例子：</p>
<blockquote>
<p>提供例子可以供AI大模型进行参考，可以有效的提高输出的准确度</p>
</blockquote>
<h2 id="更好的建议"><a href="#更好的建议" class="headerlink" title="更好的建议"></a>更好的建议</h2><ul>
<li><p>如果需求比较复杂，可以将其拆分为几个步骤，逐一提问。</p>
</li>
<li><p>开放式问题往往能够激发更多的想象空间和创造性答案。</p>
</li>
<li><p>在得到AI的回答后，如果不符合预期，可以给出反馈并修正提示词。(训练与测试的过程)</p>
</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="基本模板"><a href="#基本模板" class="headerlink" title="基本模板"></a>基本模板</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 角色设定</span><br><span class="line">你是一位资深流媒体架构师，精通视频传输协议（如HLS/DASH/WebRTC）、媒体编解码（H.264/HEVC/AV1）、CDN优化和实时通信技术。请用分步骤方案解决我的开发问题。</span><br><span class="line"></span><br><span class="line">## 开发背景</span><br><span class="line">当前项目使用[编程语言/框架，如Golang+FFmpeg]开发[具体功能，如低延迟直播系统]，运行在[部署环境，如AWS EC2 g4dn实例]。已实现[现有方案，如基于WebRTC的P2P传输]，但遇到[具体问题描述，如1080p视频在200ms延迟要求下出现5%的丢包率]。</span><br><span class="line"></span><br><span class="line">## 核心需求</span><br><span class="line">1. 优化[具体指标，如端到端延迟]到[目标值，如&lt;200ms]</span><br><span class="line">2. 提升[质量指标，如视频QoE]同时保持[约束条件，如带宽利用率&lt;8Mbps]</span><br><span class="line">3. 解决[具体异常现象，如iOS客户端首帧时间超过2s]</span><br><span class="line"></span><br><span class="line">## 请求格式</span><br><span class="line">请按以下结构给出建议：</span><br><span class="line">1. 诊断分析：可能导致问题的3个技术因素</span><br><span class="line">2. 优化方案：分网络传输、编解码、服务端三个层面的改进措施</span><br><span class="line">3. 配置示例：关键参数的推荐值（如WebRTC的sdp中设置a=goog-latency-experimental:100）</span><br><span class="line">4. 验证方法：建议的AB测试方案或监控指标</span><br><span class="line"></span><br><span class="line">## 补充信息</span><br><span class="line">[相关日志片段/抓包数据特征/硬件配置详情]</span><br></pre></td></tr></table></figure>

<h4 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h4><ol>
<li><strong>技术参数具体化</strong>：避免模糊表述，将”提高画质”改为”在HLS分片时长2s约束下优化SSIM≥0.92”</li>
<li><strong>上下文增强</strong>：附带关键代码段或网络拓扑图描述</li>
<li><strong>渐进式提问</strong>：复杂问题拆分为”协议选型→架构设计→参数调优”多轮对话</li>
<li><strong>验证驱动</strong>：要求AI给出可量化的验证方案（如：建议通过tc命令模拟20%丢包测试抗性）</li>
</ol>
<h3 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">场景：直播卡顿优化（核心需求）</span><br><span class="line">请分析基于NGINX-RTMP的直播系统在万人并发时出现的卡顿问题。当前配置： </span><br><span class="line">- 服务器：8核16G带宽1Gbps</span><br><span class="line">- 客户端观测：20%用户缓冲时间&gt;2s</span><br><span class="line">- 当前CDN配置：静态分片+单源站架构</span><br><span class="line"></span><br><span class="line">期望输出：</span><br><span class="line">1. 瓶颈定位：从协议栈/服务器架构/分发策略角度列出可能瓶颈</span><br><span class="line">2. 扩容方案：推荐边缘节点部署策略及成本估算</span><br><span class="line">3. 自适应码率方案：提供HLS动态分片配置示例</span><br><span class="line">4. 监控建议：关键性能指标的埋点方案</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>AI prompt</tag>
      </tags>
  </entry>
  <entry>
    <title>一图总结AI辅助开发技巧</title>
    <url>/2025/05/16/blog_AIDevSkill/</url>
    <content><![CDATA[<p>从大语言模型的底层原理出发，总结出了如下思路来更充分利用AI辅助开发</p>
<img src="/2025/05/16/blog_AIDevSkill/image-20250516210914588.png" class="" title="image-20250516210914588">

<span id="more"></span>

<p>其它概念不多涉及，下面主要讲讲MCP和个人使用过的一些大模型特点</p>
<h2 id="MCP"><a href="#MCP" class="headerlink" title="MCP"></a>MCP</h2><h3 id="什么是MCP"><a href="#什么是MCP" class="headerlink" title="什么是MCP"></a>什么是MCP</h3><p>Model Context Protocol (MCP) 是一个由 Anthropic 开发的开源协议，旨在标准化大型语言模型（LLM）与外部工具、数据源和服务的交互方式。 它可以被看作是 AI 应用的“USB-C 端口”，为 AI 模型提供统一的接口，以便访问和操作外部资源，从而克服 LLM 仅依赖训练数据的局限性</p>
<p><strong>核心功能</strong>： </p>
<ul>
<li>允许 AI 模型动态发现和使用外部工具（如数据库、文件系统、API 等）。</li>
<li>支持实时、双向通信，AI 可以根据用户需求调用工具并处理返回的结果。</li>
<li>提供标准化的上下文管理，减少为每个工具或模型编写定制化集成代码的需要。</li>
</ul>
<p><strong>架构</strong>： </p>
<ul>
<li><strong>MCP 主机（Host）</strong>：用户交互的应用程序，如 Claude Desktop 或 AI 增强的 IDE（如 Cursor）。</li>
<li><strong>MCP 客户端（Client）</strong>：嵌入在主机中，负责与 MCP 服务器通信，处理工具调用和数据交换。</li>
<li><strong>MCP 服务器（Server）</strong>：提供特定功能的轻量级程序，<strong>连接到外部工具或数据源</strong>（如 GitHub、Slack、数据库）。</li>
<li><strong>协议</strong>：基于 JSON-RPC，定义了客户端与服务器之间的通信规则，支持工具、资源和提示（prompt）的标准化交互。</li>
</ul>
<p><strong>优势</strong>： </p>
<ul>
<li><strong>统一性</strong>：开发者只需为工具构建一个 MCP 服务器，即可被多个支持 MCP 的 AI 模型使用。</li>
<li><strong>灵活性</strong>：支持动态工具发现，AI 可以在运行时识别可用的 MCP 服务器及其功能。</li>
<li><strong>安全性</strong>：通过标准化访问控制和权限管理，降低安全风险。</li>
</ul>
<h3 id="MCP怎么用"><a href="#MCP怎么用" class="headerlink" title="MCP怎么用"></a>MCP怎么用</h3><p>在 AI 辅助开发中，MCP 的主要作用是增强 AI 编码工具（如 Cursor、VS Code、Windsurf）的能力，使其能够：</p>
<ul>
<li><strong>访问外部上下文</strong>：如代码库、文档、数据库或第三方服务（如 GitHub、Slack），以生成更准确的代码或建议。</li>
<li><strong>执行复杂任务</strong>：通过调用工具，AI 可以自动化任务，如运行终端命令、修改文件或查询 API。</li>
<li><strong>简化集成</strong>：开发者无需为每个工具或模型编写单独的集成代码，MCP 提供统一的接口。</li>
</ul>
<p>例如，在 Cursor 中，MCP 可以让 AI 直接操作本地文件、查询 GitHub 仓库或与数据库交互，从而提升开发效率。</p>
<h4 id="1-准备环境"><a href="#1-准备环境" class="headerlink" title="1. 准备环境"></a><strong>1. 准备环境</strong></h4><ul>
<li><p><strong>安装依赖</strong>：</p>
</li>
<li><ul>
<li>确保你的开发环境支持 MCP。常见语言 SDK 包括 Python、TypeScript 和 Java。</li>
<li>安装必要的工具，如 Python（用于运行 MCP 服务器）或 Node.js（用于 TypeScript 服务器）。</li>
<li>如果使用 Cursor 或 VS Code，确保这些 IDE 已更新到支持 MCP 的版本。</li>
</ul>
</li>
<li><p><strong>选择 MCP 服务器</strong>：</p>
</li>
<li><ul>
<li>使用预构建的 MCP 服务器（如 Anthropic 提供的 Google Drive、Slack、GitHub 连接器）。</li>
<li>或者，自行开发 MCP 服务器以连接到自定义工具或数据源。</li>
</ul>
</li>
</ul>
<h4 id="2-安装和配置-MCP-服务器"><a href="#2-安装和配置-MCP-服务器" class="headerlink" title="2. 安装和配置 MCP 服务器"></a><strong>2. 安装和配置 MCP 服务器</strong></h4><ul>
<li><p><strong>获取 MCP 服务器</strong>：</p>
</li>
<li><ul>
<li>从 Anthropic 的开源仓库（modelcontextprotocol.io）或社区市场（如 mcp.so、mcpmarket.com， <strong>smithery还有github也行</strong>）下载预构建的 MCP 服务器。</li>
<li>示例：安装 GitHub MCP 服务器以访问代码仓库。</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install mcp-server-github</span><br><span class="line">omcp run github</span><br></pre></td></tr></table></figure>

<p>（<code>omcp</code> 是一个社区工具，用于管理本地 MCP 服务器。）</p>
<ul>
<li><p><strong>配置服务器</strong>：</p>
</li>
<li><ul>
<li>运行服务器时，提供必要的凭据或 API 密钥（如 GitHub 的 Personal Access Token）。</li>
<li>配置服务器的通信方式：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><strong>stdio</strong>：用于本地集成，适合与本地文件或脚本交互。</li>
<li><strong>HTTP&#x2F;SSE</strong>：用于远程服务，通过 Server-Sent Events 保持持久连接。</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>示例：为 Cursor 配置一个本地 MCP 服务器。</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>在 Cursor 中，打开 <code>File → Preferences → Cursor Settings → MCP → Add New Server</code>。</li>
<li>输入服务器名称和路径（如 <code>C:\mcp-demos\calculator.py</code>）。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>测试服务器</strong>：</p>
</li>
<li><ul>
<li>启动服务器后，检查是否在 IDE 中显示为可用（例如，Cursor 中显示绿色状态）。</li>
<li>使用命令行或 IDE 的终端运行测试命令，确保服务器响应正常。</li>
</ul>
</li>
</ul>
<h4 id="3-在-IDE-中集成-MCP"><a href="#3-在-IDE-中集成-MCP" class="headerlink" title="3. 在 IDE 中集成 MCP"></a><strong>3. 在 IDE 中集成 MCP</strong></h4><ul>
<li><p><strong>在 Cursor 中使用 MCP</strong>：</p>
</li>
<li><ul>
<li>打开 Cursor，进入 <code>Composer</code> 或 <code>Agent</code> 模式。</li>
<li>输入 prompt，引用 MCP 工具（例如，使用 <code>#mcp_add()</code> 调用计算器工具）。</li>
<li>示例 prompt：</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用 GitHub MCP 服务器列出我的开放 pull requests。</span><br></pre></td></tr></table></figure>

<p>Cursor 会自动调用 GitHub MCP 服务器并返回结果。</p>
<ul>
<li><p><strong>在 VS Code 中使用 MCP</strong>：</p>
</li>
<li><ul>
<li>添加 MCP 服务器：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>创建 <code>.vscode/mcp.json</code> 文件，配置服务器地址和端口。</li>
<li>或者，在用户设置中启用自动发现，连接到 Claude Desktop 等工具定义的服务器。</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>在 <code>Chat view</code> 中切换到 <code>Agent mode</code>，选择可用工具并输入 prompt。</li>
<li>示例：</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查询 Postgres 数据库中最近 10 天的订单数据。</span><br></pre></td></tr></table></figure>

<p>VS Code 将通过 Postgres MCP 服务器执行查询。</p>
<ul>
<li><p><strong>安全提示</strong>：</p>
</li>
<li><ul>
<li>只使用来自可信来源的 MCP 服务器，因为它们可能运行任意代码。</li>
<li>检查服务器日志以诊断连接问题（在 VS Code 中，运行 <code>MCP: List Servers</code> 查看输出）。</li>
</ul>
</li>
</ul>
<h4 id="4-开发自定义-MCP-服务器（高级）"><a href="#4-开发自定义-MCP-服务器（高级）" class="headerlink" title="4. 开发自定义 MCP 服务器（高级）"></a><strong>4. 开发自定义 MCP 服务器（高级）</strong></h4><p>如果你需要连接到特定工具或数据源，可以开发自己的 MCP 服务器：</p>
<ul>
<li><p><strong>使用 SDK</strong>：</p>
</li>
<li><ul>
<li>Python 示例（使用 FastMCP 库）：</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> fastmcp <span class="keyword">import</span> FastMCP</span><br><span class="line"></span><br><span class="line">mcp = FastMCP(<span class="string">&quot;Demo&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@mcp.tool()</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a: <span class="built_in">int</span>, b: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Add two numbers&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line">mcp.run()</span><br></pre></td></tr></table></figure>

<p>这个服务器定义了一个简单的 <code>add</code> 工具，AI 可以通过 prompt 调用它。</p>
<ul>
<li><ul>
<li>TypeScript&#x2F;Java 也有类似 SDK，参考官方文档（modelcontextprotocol.io）。</li>
</ul>
</li>
<li><p><strong>部署服务器</strong>：</p>
</li>
<li><ul>
<li>本地运行：使用 <code>stdio</code> 模式，适合开发测试。</li>
<li>远程部署：使用 Cloudflare Workers 等平台，通过 HTTP&#x2F;SSE 提供服务。</li>
</ul>
</li>
<li><p><strong>测试与集成</strong>：</p>
</li>
<li><ul>
<li>在 Claude Desktop 或 Cursor 中添加服务器地址，测试工具是否可用。</li>
<li>使用 MCP 客户端（如 mcp-use）验证服务器功能。</li>
</ul>
</li>
</ul>
<h4 id="5-探索高级用例"><a href="#5-探索高级用例" class="headerlink" title="5. 探索高级用例"></a><strong>5. 探索高级用例</strong></h4><ul>
<li><p><strong>自动化开发任务</strong>：</p>
</li>
<li><ul>
<li>使用 GitHub MCP 服务器自动提交代码或管理 pull requests。</li>
<li>示例：Block 公司使用 MCP 连接内部工具，自动化代码迁移和监控设置。</li>
</ul>
</li>
<li><p><strong>多工具协作</strong>：</p>
</li>
<li><ul>
<li>结合多个 MCP 服务器（如 Google Maps、Yelp、OpenTable）实现复杂任务，如规划晚餐并预订餐厅。</li>
<li>示例 prompt：</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在 Slack 中监听“找个吃饭的地方”，从 Google Maps 和 Yelp 获取推荐，并使用 OpenTable 预订。</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>实时数据查询</strong>：</p>
</li>
<li><ul>
<li>使用 Perplexity MCP 服务器进行实时网络搜索，补充 AI 的知识。</li>
</ul>
</li>
<li><p><strong>社区工具</strong>：</p>
</li>
<li><ul>
<li>探索社区开发的 MCP 服务器，如 Unity MCP（用于通过提示词创建游戏）或 Slack MCP（集成团队通信）。</li>
</ul>
</li>
</ul>
<h4 id="6-监控和优化"><a href="#6-监控和优化" class="headerlink" title="6. 监控和优化"></a><strong>6. 监控和优化</strong></h4><ul>
<li><p><strong>日志监控</strong>：</p>
</li>
<li><ul>
<li>检查 MCP 服务器的日志，确保请求和响应正常。</li>
<li>在 Cursor 或 VS Code 中，查看工具调用是否正确执行。</li>
</ul>
</li>
<li><p><strong>优化性能</strong>：</p>
</li>
<li><ul>
<li>启用 Server Manager（在 mcp-use 中设置 <code>use_server_manager=True</code>），自动选择最合适的服务器，减少资源浪费。</li>
</ul>
</li>
<li><p><strong>迭代改进</strong>：</p>
</li>
<li><ul>
<li>根据实际使用情况调整工具定义，提供更清晰的描述和参数，优化 LLM 的调用效率。</li>
</ul>
</li>
</ul>
<h2 id="一些常用的大模型"><a href="#一些常用的大模型" class="headerlink" title="一些常用的大模型"></a>一些常用的大模型</h2><p>接下来对个人使用过的大模型进行分类，主要从优缺点上分类</p>
<ul>
<li><strong>快速原型开发</strong>：GPT-4.1、Grok 3（易用、性能强）。</li>
</ul>
<blockquote>
<p>​	GPT最厉害的点还是多模态能力。图像，语音，文字，编码工作都可以胜任。</p>
</blockquote>
<ul>
<li><strong>大型项目重构</strong>：Claude 3.5 Sonnet（长上下文，适合复杂代码库）。</li>
</ul>
<blockquote>
<p>​	在编码方面目前最厉害的还是claude sonnet,目前已经更新到了3.7，不过使用起来似乎没有之前3.5惊艳了，因为claude锁国区且对中文支持不好，建议不要用中文提问。</p>
</blockquote>
<ul>
<li><strong>成本敏感项目</strong>：DeepSeek-V3、Qwen 2.5（开源，免费或低成本）。</li>
<li><strong>研究与小型设备</strong>：LLaMA 3.2（轻量，适合实验）。</li>
<li><strong>多语言开发</strong>：Qwen 2.5、Mistral Large 2（支持多语言）。</li>
</ul>
<blockquote>
<p>​	在中文大语言模型这块千问应该是排在前列的。</p>
</blockquote>
<ul>
<li><strong>实时信息需求</strong>：Grok 3（集成 X 平台数据）。</li>
</ul>
<blockquote>
<p>​	马斯克的grok3最近一直在用，感觉在语言理解和编码方面都跟gpt差不多了，而且编码甚至论文公式推导这些方面也很不错，推荐。</p>
</blockquote>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>AI prompt</tag>
      </tags>
  </entry>
  <entry>
    <title>cmake</title>
    <url>/2025/03/10/DevTools__cmake/</url>
    <content><![CDATA[<h2 id="从零开始写一个CMakeLists-txt文件"><a href="#从零开始写一个CMakeLists-txt文件" class="headerlink" title="从零开始写一个CMakeLists.txt文件"></a>从零开始写一个CMakeLists.txt文件</h2><p>从零开始写CMakeLists.txt的基本步骤和结构：</p>
<ol>
<li><strong>第一步：基础设置</strong><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定CMake最低版本</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目名称</span></span><br><span class="line"><span class="keyword">project</span>(你的项目名称)</span><br></pre></td></tr></table></figure></li>
</ol>
<span id="more"></span>

<ol start="2">
<li><strong>第二步：设置编译选项</strong></li>
</ol>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置C++标准</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -std=c++11&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置编译类型（Debug/Release）</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_BUILD_TYPE Debug)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p><strong>第三步：设置头文件和库文件路径</strong></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果有额外的头文件目录</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="keyword">include</span>)</span><br><span class="line"><span class="comment"># 如果有额外的库文件目录</span></span><br><span class="line"><span class="keyword">link_directories</span>(lib)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>第四步：添加源文件</strong></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方法1：直接列出所有源文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(项目名称 </span><br><span class="line">    src/main.cpp</span><br><span class="line">    src/other.cpp</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法2：使用变量收集源文件</span></span><br><span class="line"><span class="keyword">set</span>(SOURCES</span><br><span class="line">    src/main.cpp</span><br><span class="line">    src/other.cpp</span><br><span class="line">)</span><br><span class="line"><span class="keyword">add_executable</span>(项目名称 <span class="variable">$&#123;SOURCES&#125;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>第五步：如果需要链接外部库</strong></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 链接库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(项目名称</span><br><span class="line">    库名称<span class="number">1</span></span><br><span class="line">    库名称<span class="number">2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
</ol>
<p>一些实用的建议：</p>
<ol>
<li>保持结构清晰，按照上述步骤组织你的CMakeLists.txt</li>
<li>使用注释说明每个部分的作用</li>
<li>对于大型项目，可以使用子目录的CMakeLists.txt</li>
<li>养成良好的变量命名习惯</li>
<li>建议使用现代CMake的命令和特性</li>
</ol>
<p>创建一个最简单的CMakeLists.txt，可以参考这个模板：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 最低CMake版本要求</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目名称</span></span><br><span class="line"><span class="keyword">project</span>(MyProject)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将所有源文件添加到可执行文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(MyProject main.cpp)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>开发工具</category>
        <category>构建</category>
      </categories>
  </entry>
  <entry>
    <title>智能指针</title>
    <url>/2025/03/10/Cpp11__inteligent_ptr/</url>
    <content><![CDATA[<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p><strong>c++11之后引入智能指针的目的</strong>：动态分配的内存空间如果不进行释放，就会导致内存泄露。智能指针是一个模板类，其离开作用域时就会销毁，这时就会调用其析构函数来释放所指向的动态分配对象的空间。<font color='red'>即智能指针就是用来解决内存泄露问题的。</font></p>
<p>本文重在实现简化版的智能指针的模板类，其它概念不多介绍。</p>
<p>阅读前请确保已了解右值引用和移动语义相关知识。</p>
<span id="more"></span>

<h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><p><strong>shared_ptr和其指向的动态分配对象可以实现多对一，即可以多个shared_ptr指向同一个动态分配的对象。</strong></p>
<p>​	<strong>首先需要列出实现的内容：</strong></p>
<ul>
<li>构造函数(默认构造函数，有参构造函数，拷贝构造函数)</li>
<li>析构函数</li>
<li>赋值运算符”&#x3D;”的重载</li>
<li>operator * 的重载</li>
<li>operator -&gt; 的重载</li>
<li>指向动态分配对象的原始指针<code>m_ptr</code></li>
<li>引用计数指针<code>m_count</code></li>
<li>成员函数get(), reset(), use_count()</li>
<li>make_shared函数模板</li>
</ul>
<style>.oepoolxblxpd{zoom:50%;}</style><img src="/2025/03/10/Cpp11__inteligent_ptr/image-20250310211607484.png" class="oepoolxblxpd" alt="image-20250310211607484">

<blockquote>
<p><strong>为什么图中使用<code>int* m_count</code>而不是<code>int m_count</code>?</strong></p>
<p><strong>答：为了共享引用计数值</strong></p>
<p><strong>更具体的</strong>：使用指针m_count而不是整型m_count保证了不同的shared_ptr可以指向同一个引用计数值(因为m_count的地址值是一样的)。如果每个<code>shared_ptr</code>实例都有自己的<code>int m_count</code>成员变量，那么当一个实例增加或减少计数时，其他实例不会知道这个变化。</p>
</blockquote>
<h4 id="具体代码实现"><a href="#具体代码实现" class="headerlink" title="具体代码实现"></a>具体代码实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*	</span></span><br><span class="line"><span class="comment">	shared_ptr.h</span></span><br><span class="line"><span class="comment">	实现一个简化版的shared_ptr模板类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SHARED_PTR_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHARED_PTR_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySharedPtr</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//指向动态分配对象的原始指针</span></span><br><span class="line">	T* m_ptr;	</span><br><span class="line">	<span class="comment">//共享的引用计数指针</span></span><br><span class="line">	<span class="type">int</span>* m_count;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//释放函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//注意要保证已经指向了动态对象，即m_count不为空</span></span><br><span class="line">		<span class="keyword">if</span> (m_count) &#123;</span><br><span class="line">			--(*m_count);</span><br><span class="line">			<span class="comment">//只有引用计数为0，才释放管理的对象内存空间</span></span><br><span class="line">			<span class="keyword">if</span> ((*m_count) == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">delete</span> m_ptr;</span><br><span class="line">				<span class="keyword">delete</span> m_count;</span><br><span class="line">				m_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">				m_count = <span class="literal">nullptr</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//默认构造函数</span></span><br><span class="line">	<span class="built_in">MySharedPtr</span>(): <span class="built_in">m_ptr</span>(<span class="literal">nullptr</span>), <span class="built_in">m_count</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//有参构造函数,最好使用显式构造，避免出现在栈区隐式调用智能指针构造函数，导致智能指针提前销毁</span></span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">MySharedPtr</span><span class="params">(T* ptr)</span>: m_ptr(ptr), m_count(new int(<span class="number">1</span>)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//拷贝构造函数</span></span><br><span class="line">	<span class="comment">//MySharedptr&lt;T&gt; p2(p1);</span></span><br><span class="line">	<span class="built_in">MySharedPtr</span>(<span class="type">const</span> MySharedPtr &amp;other): <span class="built_in">m_ptr</span>(other.m_ptr), <span class="built_in">m_count</span>(other.m_count) &#123;</span><br><span class="line">		<span class="comment">//引用计数加1</span></span><br><span class="line">		<span class="keyword">if</span> (m_count) &#123;</span><br><span class="line">			++(*m_count);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//析构函数</span></span><br><span class="line">	~<span class="built_in">MySharedPtr</span>() &#123;</span><br><span class="line">		<span class="built_in">release</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//赋值运算符&quot;=&quot;重载</span></span><br><span class="line">	<span class="comment">//MySharedptr&lt;T&gt; p2 = p1; 不能给shared_ptr赋裸指针的原因</span></span><br><span class="line">	MySharedPtr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MySharedPtr &amp;other) &#123;</span><br><span class="line">		<span class="comment">//other这里是个实例,而this是指向p2的指针，所以要加个&quot;&amp;&quot;</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">			<span class="built_in">release</span>();</span><br><span class="line">			m_ptr = other.m_ptr;</span><br><span class="line">			m_count = other.m_count;</span><br><span class="line">			<span class="keyword">if</span> (m_count) &#123;</span><br><span class="line">				++(*m_count);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//解引用&quot;*&quot;的重载</span></span><br><span class="line">	T&amp; <span class="keyword">operator</span>*() &#123;</span><br><span class="line">		<span class="keyword">return</span> *m_ptr; <span class="comment">//返回管理的对象</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//&quot;-&gt;&quot;的重载</span></span><br><span class="line">	T* <span class="keyword">operator</span>-&gt;() &#123;</span><br><span class="line">		<span class="keyword">return</span> m_ptr; </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//reset函数</span></span><br><span class="line">	<span class="comment">//重置指针，如果调用该函数的shared_ptr对象没有初始化且ptr不为空则让裸指针指向动态对象，并将引用计数加1</span></span><br><span class="line">	<span class="comment">//如果shared_ptr对象已经初始化，则根据reset是否传参：即ptr有值则重新指向该对象；ptr为空，则让引用计数减1</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(T* ptr = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (m_ptr != ptr) &#123;</span><br><span class="line">			<span class="built_in">release</span>();</span><br><span class="line">			<span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">				m_ptr = ptr;</span><br><span class="line">				++(*m_count);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//get函数,获取原始指针</span></span><br><span class="line">	<span class="function">T* <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_ptr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//use_count函数，返回引用计数的值</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">use_count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//注意管理对象可以已经销毁再调用use_count查看的</span></span><br><span class="line">		<span class="keyword">return</span> m_count ? *m_count : <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//make_shared&lt;T&gt;() 函数模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">MySharedPtr&lt;T&gt; <span class="title">make_shared</span><span class="params">(Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//std::forward&lt;&gt; 在模板代码中用于完美转发</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">MySharedPtr</span>&lt;T&gt;(<span class="keyword">new</span> <span class="built_in">T</span>(std::forward&lt;Args&gt;(args)...)); <span class="comment">//有参构造</span></span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br></pre></td></tr></table></figure>

<p>测试函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;shared_ptr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">/****************shared_ptr的测试*******************************/</span></span><br><span class="line">	<span class="comment">/*测试简化版的shared_ptr模板类*/</span></span><br><span class="line">	<span class="function">MySharedPtr&lt;<span class="type">int</span>&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">50</span>))</span></span>;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;the use_count: &quot;</span> &lt;&lt; sp<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;sp1: &quot;</span> &lt;&lt; *sp1 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//测试赋值运算重载</span></span><br><span class="line">	MySharedPtr&lt;<span class="type">int</span>&gt; sp2 = sp1; </span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;After copy, use_count(): &quot;</span> &lt;&lt; sp<span class="number">2.</span><span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 修改值</span></span><br><span class="line">	*sp1 = <span class="number">100</span>;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;*the value of sp2: &quot;</span> &lt;&lt; *sp2 &lt;&lt; std::endl;  <span class="comment">// sp2也会看到更改</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用make_shared</span></span><br><span class="line">	<span class="keyword">auto</span> sp3 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">200</span>);</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;*sp3: &quot;</span> &lt;&lt; *sp3 &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;after sp3,  use_count of sp3 &quot;</span> &lt;&lt; sp<span class="number">3.</span><span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;after sp3, use_count of sp2,sp1 &quot;</span> &lt;&lt; sp<span class="number">2.</span><span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重置指针</span></span><br><span class="line">	sp<span class="number">1.</span><span class="built_in">reset</span>();</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;After sp1.reset(), sp2.use_count(): &quot;</span> &lt;&lt; sp<span class="number">2.</span><span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/****************shared_ptr测试函数到此结束***********************/</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">the use_count: 1</span><br><span class="line">sp1: 50</span><br><span class="line">After copy, use_count(): 2</span><br><span class="line">*the value of sp2: 100</span><br><span class="line">*sp3: 200</span><br><span class="line">after sp3,  use_count of sp3 1</span><br><span class="line">after sp3, use_count of sp2,sp1 2</span><br><span class="line">After sp1.reset(), sp2.use_count(): 1</span><br></pre></td></tr></table></figure>

<h4 id="难点以及“坑”解析"><a href="#难点以及“坑”解析" class="headerlink" title="难点以及“坑”解析"></a>难点以及“坑”解析</h4><ul>
<li><p>一、<strong>释放函数release必须要先判断引用计数指针m_count是否为空！</strong></p>
</li>
<li><p>二、<strong>赋值运算符重载这里需要考虑如下情况</strong></p>
<ul>
<li>1.<font color='mediumseagreen'>如果不加this !&#x3D; &amp;other</font></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">SharedPtr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">p1 = p1;  <span class="comment">// ❌ 如果没有 this != &amp;other，p1 可能释放掉自己正在管理的资源</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>2.<font color='mediumseagreen'>为什么先release()减少引用计数，而不是直接给赋值，并增加引用计数</font></p>
<p>如下假如不先执行release()</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">    m_ptr = other.m_ptr;</span><br><span class="line">    m_count = other.m_count;</span><br><span class="line">    <span class="keyword">if</span> (m_count) &#123;</span><br><span class="line">        ++(*m_count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	那么如果测试函数中出现如下情况，<font color='red'>则会导致p2原来指向的动态对象空间int(20)永远不会被释放，导致内存泄露</font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">MySharedPtr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;  <span class="comment">// p1: *m_count = 1</span></span><br><span class="line"><span class="function">MySharedPtr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">20</span>))</span></span>;  <span class="comment">// p2: *m_count = 1</span></span><br><span class="line">p2 = p1;  <span class="comment">// p2 放弃原来的对象，指向 p1 的对象</span></span><br></pre></td></tr></table></figure>

<p>​	正常的MySharedPtr赋值如下：</p>
<blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">MySharedPtr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;  <span class="comment">// p1: *m_count = 1</span></span><br><span class="line">MySharedPtr&lt;<span class="type">int</span>&gt; p2;  <span class="comment">// p2 为空，m_count = nullptr</span></span><br><span class="line">p2 = p1;  <span class="comment">// p2 变成 p1 的拷贝</span></span><br></pre></td></tr></table></figure>

<p><strong>步骤解析：</strong></p>
<p><code>p2.release();</code> <strong>不会释放任何东西</strong>（因为 <code>p2</code> 为空）。</p>
<p><code>p2.m_ptr = p1.m_ptr;</code>（指向相同对象）</p>
<p><code>p2.m_count = p1.m_count;</code>（共享相同引用计数）</p>
<p><code>++(*p2.m_count);</code>  引用计数 <code>1 → 2</code>。</p>
</blockquote>
<ul>
<li>3.<font color='mediumseagreen'>返回类型为该模板类<code>*this</code>的引用</font></li>
</ul>
<blockquote>
<p>这里这么做的作用主要是如果函数返回类型不加引用，那么实际上返回值是一个拷贝了原对象<code>*this</code>的新智能指针p2’，在需要<strong>链式编程</strong>的场景下就不可行了，所以我们直接加引用“&amp;”返回原对象即可。</p>
</blockquote>
</li>
<li><p>三、<strong>有参构造函数要加explicit关键字，保证是显式构造</strong></p>
<blockquote>
<p>如果没有 <code>explicit</code> 关键字，以下代码将被允许：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(SharedPtr&lt;<span class="type">int</span>&gt; ptr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 ptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* rawPtr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">func</span>(rawPtr);  <span class="comment">// 编译器会隐式地将 rawPtr 转换为 SharedPtr&lt;int&gt;</span></span><br><span class="line">    <span class="comment">// 可能导致内存泄漏，因为 func 结束后，临时创建的 SharedPtr 被销毁，会释放 rawPtr</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<p>补充：</p>
<blockquote>
<p>在 C++ 中，<code>const</code> 限定符有几个重要的用途：</p>
<ol>
<li><strong>保证接口安全</strong>：当函数声明为 <code>const</code> 时（例如 <code>T* get() const</code>），它承诺不会修改对象的状态。这使调用者知道调用该函数是安全的，不会改变对象的内部数据。</li>
<li><strong>编译时检查</strong>：编译器会检查并阻止在 <code>const</code> 方法中对对象成员变量的修改，这有助于防止意外的数据修改。</li>
<li><strong>更广泛的使用场景</strong>：<code>const</code> 方法可以被 <code>const</code> 对象和非 <code>const</code> 对象调用，而非 <code>const</code> 方法只能被非 <code>const</code> 对象调用。这增加了类的灵活性。</li>
<li><strong>代码自文档化</strong>：<code>const</code> 关键字明确告诉其他开发者哪些操作不会修改对象状态，增强了代码的可读性和可维护性。</li>
<li><strong>编译器优化</strong>：编译器可以对 <code>const</code> 方法进行更积极的优化，因为它知道这些方法不会修改对象状态。</li>
</ol>
</blockquote>
<p>此外，<font color='red'>还需注意标准库中的shared_ptr的reset函数在智能指针对象指向了动态分配对象的前提下使用且不传参，引用计数减1的同时，还会销毁该对象</font></p>
<h4 id="线程安全的引用计数"><a href="#线程安全的引用计数" class="headerlink" title="线程安全的引用计数"></a>线程安全的引用计数</h4><p><strong>注意在shared_ptr中引用计数是线程安全的，但是管理的数据不是线程安全的</strong>。我们上面的实现并不能保证引用计数是线程安全的，因为多个线程可能同时操作引用计数指针<code>m_count</code>，导致动态对象被提前释放或永远不被释放。</p>
<p>下面将采用互斥锁来实现引用计数线程安全（可以参考下图实现，这里我们就不考虑weak_count了）</p>
<style>.wstqgmpgkyzb{zoom:50%;}</style><img src="/2025/03/10/Cpp11__inteligent_ptr/image-20250310221101442.png" class="wstqgmpgkyzb" alt="image-20250310221101442">

<p>具体代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* shared_ptr.h</span></span><br><span class="line"><span class="comment">* 实现一个线程安全的shared_ptr模板类，不考虑weak_ptr</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SHARED_PTR_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHARED_PTR_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySharedPtr</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 控制块结构</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ControlBlock</span> &#123;</span><br><span class="line">        <span class="type">int</span> ref_count; <span class="comment">// 引用计数</span></span><br><span class="line">        std::mutex mutex; <span class="comment">// 互斥锁，保证线程安全</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">        <span class="built_in">ControlBlock</span>() : <span class="built_in">ref_count</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向管理对象的原始指针</span></span><br><span class="line">    T* raw_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向控制块的指针</span></span><br><span class="line">    ControlBlock* control_block;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加引用计数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add_count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (control_block) &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(control_block-&gt;mutex)</span></span>;</span><br><span class="line">            ++(control_block-&gt;ref_count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 减少引用计数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sub_count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (control_block) &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(control_block-&gt;mutex)</span></span>;</span><br><span class="line">            --(control_block-&gt;ref_count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (control_block) &#123;</span><br><span class="line">            <span class="built_in">sub_count</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查是否为最后一个引用</span></span><br><span class="line">            <span class="type">bool</span> delete_resources = <span class="literal">false</span>;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(control_block-&gt;mutex)</span></span>;</span><br><span class="line">                delete_resources = (control_block-&gt;ref_count == <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 只有当引用计数为零时才删除资源</span></span><br><span class="line">            <span class="keyword">if</span> (delete_resources) &#123;</span><br><span class="line">                <span class="keyword">delete</span> raw_ptr;</span><br><span class="line">                <span class="keyword">delete</span> control_block;</span><br><span class="line">                raw_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">                control_block = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">MySharedPtr</span>() : <span class="built_in">raw_ptr</span>(<span class="literal">nullptr</span>), <span class="built_in">control_block</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有参构造，从原始指针构造</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MySharedPtr</span><span class="params">(T* ptr)</span>: raw_ptr(ptr), control_block(ptr ? new ControlBlock() : nullptr) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MySharedPtr</span>(<span class="type">const</span> MySharedPtr&amp; other): <span class="built_in">raw_ptr</span>(other.raw_ptr), <span class="built_in">control_block</span>(other.control_block) &#123;</span><br><span class="line">        <span class="built_in">add_count</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">MySharedPtr</span>(MySharedPtr&amp;&amp; other) <span class="keyword">noexcept</span>: <span class="built_in">raw_ptr</span>(other.raw_ptr), <span class="built_in">control_block</span>(other.control_block) &#123;</span><br><span class="line">        other.raw_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        other.control_block = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">MySharedPtr</span>() &#123;</span><br><span class="line">        <span class="built_in">release</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝赋值运算符重载</span></span><br><span class="line">    <span class="comment">//这里不能给shared_ptr赋裸指针</span></span><br><span class="line">    MySharedPtr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MySharedPtr&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="built_in">release</span>();</span><br><span class="line">            raw_ptr = other.raw_ptr;</span><br><span class="line">            control_block = other.control_block;</span><br><span class="line">            <span class="built_in">add_count</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动赋值运算符重载</span></span><br><span class="line">    MySharedPtr&amp; <span class="keyword">operator</span>=(MySharedPtr&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="built_in">release</span>();</span><br><span class="line">            raw_ptr = other.raw_ptr;</span><br><span class="line">            control_block = other.control_block;</span><br><span class="line">            other.raw_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">            other.control_block = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解引用运算符重载</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> *raw_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 箭头运算符重载</span></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> raw_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(T* ptr = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (raw_ptr != ptr) &#123;</span><br><span class="line">            <span class="built_in">release</span>();</span><br><span class="line">            <span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">                raw_ptr = ptr;</span><br><span class="line">                control_block = <span class="keyword">new</span> <span class="built_in">ControlBlock</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取原始指针</span></span><br><span class="line">    <span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> raw_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取引用计数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">use_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (control_block) &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(control_block-&gt;mutex)</span></span>;</span><br><span class="line">            <span class="keyword">return</span> control_block-&gt;ref_count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查指针是否是唯一拥有者（只有一个引用）</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">unique</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">use_count</span>() == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// make_shared函数模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">MySharedPtr&lt;T&gt; <span class="title">make_shared</span><span class="params">(Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">MySharedPtr</span>&lt;T&gt;(<span class="keyword">new</span> <span class="built_in">T</span>(std::forward&lt;Args&gt;(args)...));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>同样的测试用例下，代码无误</p>
<h4 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h4><h5 id="1-为什么make-shared创建shared-ptr会比shared-ptr-p-new-int-更优"><a href="#1-为什么make-shared创建shared-ptr会比shared-ptr-p-new-int-更优" class="headerlink" title="1.为什么make_shared&lt;int&gt;创建shared_ptr会比shared_ptr&lt;int&gt; p(new int())更优"></a>1.为什么<code>make_shared&lt;int&gt;</code>创建shared_ptr会比<code>shared_ptr&lt;int&gt; p(new int())</code>更优</h5><blockquote>
<p>简单来说就是make_shared内存分配效率更高(性能更好)，安全性更好，代码可读性更强</p>
<p>具体的：</p>
<p>（1）性能更优</p>
<p><code>std::make_shared&lt;T&gt;(...)</code> 在堆上只分配 <strong>一次内存</strong>，而 <code>std::shared_ptr&lt;T&gt;(new T(...))</code> 会进行 <strong>两次分配</strong>：</p>
<ul>
<li><code>make_shared</code> 会把 <strong>引用计数控制块</strong> 和 <strong>实际对象 T</strong> 一起分配在一块连续的内存中。</li>
<li>而 <code>shared_ptr&lt;T&gt;(new T(...))</code> 会先分配对象的内存，再分配引用计数控制块的内存。</li>
</ul>
<p>（2）安全性更好</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> Widget(), custom_deleter)</span></span>;</span><br></pre></td></tr></table></figure>

<p>如果 <code>new Widget()</code> 和 <code>custom_deleter</code> 之间抛异常，<code>Widget</code> 的指针就泄露了（因为 <code>shared_ptr</code> 构造尚未完成）。</p>
<p>而 <code>make_shared</code> 是原子操作，整个过程由内部管理，不存在这种中间状态导致的泄漏问题。</p>
<p>(3) 代码可读性更强</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = std::<span class="built_in">make_shared</span>&lt;MyClass&gt;(arg1, arg2);  <span class="comment">// 简洁明了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> p = std::<span class="built_in">shared_ptr</span>&lt;MyClass&gt;(<span class="keyword">new</span> <span class="built_in">MyClass</span>(arg1, arg2));  <span class="comment">// 啰嗦且容易出错</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="2-完美转发std-forward"><a href="#2-完美转发std-forward" class="headerlink" title="2.完美转发std::forward"></a>2.完美转发<code>std::forward</code></h5><blockquote>
<p>完美转发是C++11引入的一个重要概念，它允许我们在不损失任何参数信息（包括值类别、const修饰等）的情况下，将参数从一个函数传递到另一个函数。这在编写模板代码和通用包装函数时特别有用。</p>
<p><font color='cornflowerblue'>为什么需要完美转发？</font></p>
<p>在没有完美转发之前，我们面临一个困境：</p>
<ol>
<li>如果函数参数用值传递，会产生不必要的拷贝</li>
<li>如果使用const引用，无法传递可修改的引用</li>
<li>如果使用非const引用，无法接受临时对象或常量</li>
</ol>
<p>考虑这个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper</span><span class="params">(T&amp; param)</span> </span>&#123;  <span class="comment">// 非const引用</span></span><br><span class="line">    <span class="built_in">f</span>(param);  <span class="comment">// 调用目标函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个<code>wrapper</code>函数无法接受右值（如临时对象）。而如果我们改为<code>const T&amp;</code>，又无法传递需要被修改的参数。</p>
<p><font color='cornflowerblue'>完美转发的解决方案</font>:</p>
<p>C++11引入了两个关键组件来解决这个问题：</p>
<ol>
<li><strong>右值引用</strong>：<code>T&amp;&amp;</code></li>
<li><strong>引用折叠规则</strong>和<strong>万能引用(universal reference)</strong></li>
<li><strong>std::forward</strong>函数</li>
</ol>
<p>正确的完美转发包装函数是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper</span><span class="params">(T&amp;&amp; param)</span> </span>&#123;  <span class="comment">// 这里的T&amp;&amp;是万能引用，不是右值引用</span></span><br><span class="line">    <span class="built_in">f</span>(std::forward&lt;T&gt;(param));  <span class="comment">// 完美转发</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color='cornflowerblue'>关键组件详解</font>:</p>
<ul>
<li><strong>万能引用(Universal Reference)</strong></li>
</ul>
<p>当<code>T&amp;&amp;</code>出现在模板参数推导的上下文中时，它不是普通的右值引用，而是”万能引用”，可以绑定到任何值类别的对象上：</p>
<ul>
<li><p>当传入左值时，<code>T</code>被推导为左值引用类型</p>
</li>
<li><p>当传入右值时，<code>T</code>被推导为非引用类型</p>
</li>
<li><p><strong>引用折叠规则</strong></p>
</li>
</ul>
<p>C++11引入了”引用折叠”规则，对于类型<code>T</code>:</p>
<ul>
<li><code>T&amp; &amp;</code> 折叠为 <code>T&amp;</code></li>
<li><code>T&amp; &amp;&amp;</code> 折叠为 <code>T&amp;</code></li>
<li><code>T&amp;&amp; &amp;</code> 折叠为 <code>T&amp;</code></li>
<li><code>T&amp;&amp; &amp;&amp;</code> 折叠为 <code>T&amp;&amp;</code></li>
</ul>
<p>简单说：**只要有一个&amp;，结果就是&amp;**。</p>
<ul>
<li><strong>std::forward的原理</strong></li>
</ul>
<p><code>std::forward</code>是完美转发的核心，其简化实现大致如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp; param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它利用引用折叠规则，确保：</p>
<ul>
<li>如果原始参数是左值，通过<code>forward</code>后仍然是左值</li>
<li>如果原始参数是右值，通过<code>forward</code>后仍然是右值</li>
</ul>
<p><font color='cornflowerblue'>实际例子</font></p>
<p>假设我们要实现一个工厂函数，用于创建对象并转发构造函数的所有参数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;T&gt; <span class="title">make_unique</span><span class="params">(Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">unique_ptr</span>&lt;T&gt;(<span class="keyword">new</span> <span class="built_in">T</span>(std::forward&lt;Args&gt;(args)...));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个实现允许我们完美地转发任何参数到<code>T</code>的构造函数。</p>
<p><font color='cornflowerblue'>注意事项</font></p>
<ol>
<li><p>完美转发</p>
<p>只转发引用类型和值类别</p>
<p>，不转发以下内容：</p>
<ul>
<li>隐式转换</li>
<li>默认参数</li>
<li>函数重载解析的结果</li>
<li>语法糖（如初始化列表）</li>
</ul>
</li>
<li><p>调用<code>std::forward&lt;T&gt;</code>时，<code>T</code>必须准确匹配模板参数推导出的类型，否则会导致错误的行为。</p>
</li>
</ol>
</blockquote>
<p>​	</p>
<p>加了weak_ptr之后的实现可以参考下图，具体代码省略</p>
<style>.iyxlwtrmewfy{zoom:50%;}</style><img src="/2025/03/10/Cpp11__inteligent_ptr/image-20250310230603480.png" class="iyxlwtrmewfy" alt="image-20250310230603480">



<h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p><strong>unique_ptr和其管理的动态分配对象必须一对一。</strong></p>
<ul>
<li><p>unique_ptr只有一个原始指针和一个删除器，<strong>占的内存空间和原始裸指针相当</strong></p>
</li>
<li><p>unique_ptr确保同一时间只有一个指针可以管理动态分配的对象，<strong>通过禁用拷贝构造函数和拷贝赋值运算符实现</strong></p>
</li>
<li><p><strong>如果要指定删除器，应当在unique_ptr创建时指定</strong></p>
</li>
<li><p>成员函数get(), release(),</p>
</li>
</ul>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* uniquex_ptr的实现</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Deleter = std::default_delete&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> UniquePtr &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//指向管理对象的原始指针</span></span><br><span class="line">	T* raw_ptr; </span><br><span class="line"></span><br><span class="line">	<span class="comment">//删除器</span></span><br><span class="line">	Deleter deleter;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">UniquePtr</span><span class="params">(T* ptr = <span class="literal">nullptr</span>)</span>: raw_ptr(ptr) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 移动构造函数</span></span><br><span class="line">	<span class="built_in">UniquePtr</span>(UniquePtr&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">raw_ptr</span>(other.raw_ptr) &#123;</span><br><span class="line">		other.raw_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 移动赋值运算符, std::move返回值就是右值，即测试函数中的&quot;=&quot;将会调用该移动拷贝函数</span></span><br><span class="line">	UniquePtr&amp; <span class="keyword">operator</span>=(UniquePtr&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">			<span class="keyword">if</span> (raw_ptr) <span class="built_in">deleter</span>(raw_ptr);</span><br><span class="line">			raw_ptr = other.raw_ptr;</span><br><span class="line">			other.raw_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//析构函数</span></span><br><span class="line">	~<span class="built_in">UniquePtr</span>() &#123;</span><br><span class="line">		<span class="keyword">if</span> (raw_ptr) &#123;</span><br><span class="line">			<span class="comment">//释放对象内存空间</span></span><br><span class="line">			<span class="built_in">deleter</span>(raw_ptr);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关键：禁用赋值拷贝和拷贝构造函数</span></span><br><span class="line">	UniquePtr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> UniquePtr&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">	<span class="built_in">UniquePtr</span>(<span class="type">const</span> UniquePtr&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//运算符重载</span></span><br><span class="line">	T&amp; <span class="keyword">operator</span>*() <span class="type">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> *raw_ptr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	T* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> raw_ptr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//get函数</span></span><br><span class="line">	<span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> raw_ptr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//reset函数,释放原管理对象空间，重置原始指针指向新对象</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(T* uptr = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (raw_ptr) &#123; </span><br><span class="line">			<span class="built_in">deleter</span>(raw_ptr); </span><br><span class="line">		&#125;</span><br><span class="line">		raw_ptr = uptr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//释放所有权release()</span></span><br><span class="line">	<span class="function">T* <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		T* tmp = raw_ptr;</span><br><span class="line">		raw_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>测试用例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简单测试类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> value;</span><br><span class="line">	<span class="built_in">Test</span>(<span class="type">int</span> v) : <span class="built_in">value</span>(v) &#123; std::cout &lt;&lt; <span class="string">&quot;Test(&quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot;) constructed\n&quot;</span>; &#125;</span><br><span class="line">	~<span class="built_in">Test</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Test(&quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot;) destructed\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************unique_ptr测试函数开始***********************/</span></span><br><span class="line">	<span class="comment">// 测试基本功能</span></span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;=== 测试基本功能 ===\n&quot;</span>;</span><br><span class="line">		<span class="function">UniquePtr&lt;Test&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> Test(<span class="number">1</span>))</span></span>;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;p1-&gt;value: &quot;</span> &lt;&lt; p1-&gt;value &lt;&lt; std::endl;</span><br><span class="line">	&#125; <span class="comment">// p1析构，Test(1)也析构</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 测试release</span></span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;\n=== 测试release ===\n&quot;</span>;</span><br><span class="line">		<span class="function">UniquePtr&lt;Test&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> Test(<span class="number">3</span>))</span></span>;</span><br><span class="line">		Test* raw = p<span class="number">1.</span><span class="built_in">release</span>();</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;release后p1是否为空: &quot;</span> &lt;&lt; (p<span class="number">1.</span><span class="built_in">get</span>() == <span class="literal">nullptr</span> ? <span class="string">&quot;是&quot;</span> : <span class="string">&quot;否&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;raw-&gt;value: &quot;</span> &lt;&lt; raw-&gt;value &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">delete</span> raw; <span class="comment">// 手动释放资源</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;\n=== 测试reset函数 ===\n&quot;</span>;</span><br><span class="line">		<span class="function">UniquePtr&lt;Test&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> Test(<span class="number">1</span>))</span></span>;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;原始p1-&gt;value: &quot;</span> &lt;&lt; p1-&gt;value &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 重置为新对象</span></span><br><span class="line">		p<span class="number">1.</span><span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Test</span>(<span class="number">2</span>));</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;reset后p1-&gt;value: &quot;</span> &lt;&lt; p1-&gt;value &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 重置为nullptr</span></span><br><span class="line">		p<span class="number">1.</span><span class="built_in">reset</span>();</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;reset为nullptr后，p1是否为空: &quot;</span> &lt;&lt; (p<span class="number">1.</span><span class="built_in">get</span>() == <span class="literal">nullptr</span> ? <span class="string">&quot;是&quot;</span> : <span class="string">&quot;否&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 测试移动构造</span></span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;\n=== 测试移动构造 ===\n&quot;</span>;</span><br><span class="line">		<span class="function">UniquePtr&lt;Test&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> Test(<span class="number">1</span>))</span></span>;</span><br><span class="line">		<span class="comment">//注意UniquePtr的拷贝赋值运算符重载被禁用了</span></span><br><span class="line">         <span class="comment">//这里std::move将p1转换为右值引用，所以这里会调用移动拷贝复制运算符重载函数</span></span><br><span class="line">		UniquePtr&lt;Test&gt; p2 = std::<span class="built_in">move</span>(p1);</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;移动后p2-&gt;value: &quot;</span> &lt;&lt; p2-&gt;value &lt;&lt; std::endl;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;p1是否为空: &quot;</span> &lt;&lt; (p<span class="number">1.</span><span class="built_in">get</span>() == <span class="literal">nullptr</span> ? <span class="string">&quot;是&quot;</span> : <span class="string">&quot;否&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************unique_ptr测试函数结束***********************/</span></span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">=== 测试基本功能 ===</span><br><span class="line">Test(1) constructed</span><br><span class="line">p1-&gt;value: 1</span><br><span class="line">Test(1) destructed</span><br><span class="line"></span><br><span class="line">=== 测试release ===</span><br><span class="line">Test(3) constructed</span><br><span class="line">release后p1是否为空: 是</span><br><span class="line">raw-&gt;value: 3</span><br><span class="line">Test(3) destructed</span><br><span class="line"></span><br><span class="line">=== 测试reset函数 ===</span><br><span class="line">Test(1) constructed</span><br><span class="line">原始p1-&gt;value: 1</span><br><span class="line">Test(2) constructed</span><br><span class="line">Test(1) destructed</span><br><span class="line">reset后p1-&gt;value: 2</span><br><span class="line">Test(2) destructed</span><br><span class="line">reset为nullptr后，p1是否为空: 是</span><br><span class="line"></span><br><span class="line">=== 测试移动构造 ===</span><br><span class="line">Test(1) constructed</span><br><span class="line">移动后p2-&gt;value: 1</span><br><span class="line">p1是否为空: 是</span><br><span class="line">Test(1) destructed</span><br></pre></td></tr></table></figure>

<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><ul>
<li><p>move函数要加<code>static</code>关键字(在模板类中实现move函数要注意的点，展示的代码用的标准库的move函数)</p>
<blockquote>
<p>原因：</p>
<ul>
<li><p><strong>静态成员函数不属于某个实例，而是属于类</strong>，这意味着它不绑定到特定的 <code>unique_ptr</code> 实例上，也不需要通过特定实例来调用。所以这里才允许使用 <code>unique_ptr&lt;T&gt;::move(ptr)</code> 这样的调用方式，而不是如<code>UniquePtr&lt;Test&gt; p2 = p1.move(p1);</code>这样来调用</p>
</li>
<li><p>将函数定义为静态成员函数可以将其限定在类的作用域内，<strong>避免与全局命名空间中的其他 <code>move</code> 函数冲突。</strong></p>
</li>
</ul>
</blockquote>
</li>
<li><p>移动构造函数及<code>noexcept</code>作用</p>
<blockquote>
<p>移动构造函数(Move Constructor)是C++11中引入的一个特性，它允许在创建新对象时”窃取”已有对象的资源，而不是复制这些资源。</p>
<p>移动构造函数的基本形式是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ClassName</span>(ClassName&amp;&amp; other) <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure>

<p>这里的关键是双引用符号<code>&amp;&amp;</code>，它表示一个右值引用，允许函数接收临时对象或即将被销毁的对象(<strong>都是右值</strong>)。</p>
<p><strong>移动构造函数的主要优点是：</strong></p>
<ol>
<li><strong>提高性能</strong>：对于包含大量数据的对象（如向量、字符串等），<strong>移动比复制快得多。</strong></li>
<li><strong>避免不必要的资源分配和释放</strong>：使用移动语义优化了临时变量创建、复制、转移的过程。</li>
</ol>
<p><strong>补充</strong>：<font color='red'>在移动语义中，一个临时变量的创建、复制、转移过程都被省略优化掉了(拷贝省略优化)</font>，即直接在目标对象的空间中完成构造。<strong>在上面的代码中，并没有实现指针赋值的深拷贝，而在需要深拷贝以避免同一内存多次释放的情况下，使用移动拷贝构造函数和移动拷贝赋值运算符可以避免申请大量资源，从而提高引用程序的效率。</strong></p>
<p>我们在设计和实现类时，对于需要动态申请大量资源的类，应该设计右值引用的拷贝构造函数和赋值函数，以提高应用程序的效率。</p>
<p><strong>noexcept作用</strong></p>
<p><code>noexcept</code> 关键字在 C++ 中用来指定函数不会抛出异常，它有几个重要作用：</p>
<ol>
<li><strong>性能优化</strong>：当编译器知道函数不会抛出异常时，可以生成更高效的代码。特别是对于移动构造函数和移动赋值运算符，标记为 <code>noexcept</code> 可以显著提高性能。</li>
<li><strong>标准容器优化</strong>：标准库容器（如 <code>std::vector</code>）会根据移动操作是否标记为 <code>noexcept</code> 来决定在扩容时使用移动还是复制操作。如果移动构造函数标记为 <code>noexcept</code>，<code>std::vector</code> 会使用移动操作，否则会退回到复制操作以保证异常安全性。</li>
<li><strong>异常安全保证</strong>：向调用者明确表明函数不会抛出异常，有助于编写更可靠的代码和进行异常处理设计。</li>
<li><strong>编译时检查</strong>：编译器会检查标记为 <code>noexcept</code> 的函数是否真的不会抛出异常。如果函数内部可能抛出异常（直接或通过调用可能抛出异常的函数），则会产生编译错误。</li>
</ol>
<p><code>noexcept</code> 可以有两种形式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无条件指定函数不会抛出异常</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有条件指定，表达式为 true 时函数不会抛出异常</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(表达式)</span></span>;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p><strong>weak_ptr主要用来观测shared_ptr所管理的动态分配对象，其不会导致引用计数变化。</strong></p>
<h3 id="标准库的智能指针实战指南"><a href="#标准库的智能指针实战指南" class="headerlink" title="标准库的智能指针实战指南"></a>标准库的智能指针实战指南</h3><h4 id="三大智能指针使用场景"><a href="#三大智能指针使用场景" class="headerlink" title="三大智能指针使用场景"></a>三大智能指针使用场景</h4><h5 id="1-std-unique-ptr-独占所有权"><a href="#1-std-unique-ptr-独占所有权" class="headerlink" title="1. std::unique_ptr - 独占所有权"></a>1. <code>std::unique_ptr</code> - 独占所有权</h5><p>这是你应该最常用的智能指针：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">modernWay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unique_ptr&lt;MyClass&gt; ptr = std::<span class="built_in">make_unique</span>&lt;MyClass&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 无需担心异常，函数结束时自动释放内存</span></span><br><span class="line">    <span class="built_in">doSomething</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 不需要手动delete</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实际使用场景：</strong></p>
<ul>
<li>工厂方法返回新创建的对象</li>
<li>类的私有实现（PIMPL模式）</li>
<li>容器中存储多态对象</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 工厂函数示例</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;Shape&gt; <span class="title">createShape</span><span class="params">(ShapeType type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> ShapeType::Circle:</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;Circle&gt;();</span><br><span class="line">        <span class="keyword">case</span> ShapeType::Rectangle:</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;Rectangle&gt;();</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>几个重要特性：</strong></p>
<ul>
<li>不可复制，只能移动</li>
<li>可以自定义删除器</li>
<li>几乎零开销（与原始指针大小相同）</li>
</ul>
<h5 id="2-std-shared-ptr-共享所有权"><a href="#2-std-shared-ptr-共享所有权" class="headerlink" title="2. std::shared_ptr - 共享所有权"></a>2. <code>std::shared_ptr</code> - 共享所有权</h5><p>当多个对象需要共同拥有某个资源时使用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sharedOwnership</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> sharedResource = std::<span class="built_in">make_shared</span>&lt;LargeObject&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 多个对象可以共享这个资源</span></span><br><span class="line">    worker1-&gt;<span class="built_in">setResource</span>(sharedResource);</span><br><span class="line">    worker2-&gt;<span class="built_in">setResource</span>(sharedResource);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 所有shared_ptr都销毁后，资源才会释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实际使用场景：</strong></p>
<ul>
<li>缓存系统</li>
<li>观察者模式中的主题对象</li>
<li>异步操作中共享的数据</li>
</ul>
<p><strong>使用注意事项：</strong></p>
<ul>
<li>比<code>unique_ptr</code>有更多开销（引用计数）</li>
<li>创建时优先使用<code>std::make_shared</code>（单次内存分配更高效）</li>
<li>避免从同一原始指针创建多个<code>shared_ptr</code></li>
</ul>
<h5 id="3-std-weak-ptr-弱引用"><a href="#3-std-weak-ptr-弱引用" class="headerlink" title="3. std::weak_ptr - 弱引用"></a>3. <code>std::weak_ptr</code> - 弱引用</h5><p><code>weak_ptr</code>不增加引用计数，用于打破循环引用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    std::shared_ptr&lt;Node&gt; next;  <span class="comment">// 强引用</span></span><br><span class="line">    std::weak_ptr&lt;Node&gt; parent;  <span class="comment">// 弱引用，避免循环引用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>实际使用场景：</strong></p>
<ul>
<li>缓存系统（可以被自动回收的缓存）</li>
<li>观察者模式（避免被观察者和观察者之间的循环引用）</li>
<li>父子关系（子对象持有父对象的弱引用）</li>
</ul>
<h4 id="实际工程中的最佳实践"><a href="#实际工程中的最佳实践" class="headerlink" title="实际工程中的最佳实践"></a>实际工程中的最佳实践</h4><h5 id="1-尽量使用make-unique和make-shared"><a href="#1-尽量使用make-unique和make-shared" class="headerlink" title="1. 尽量使用make_unique和make_shared"></a>1. 尽量使用<code>make_unique</code>和<code>make_shared</code></h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">w1</span><span class="params">(<span class="keyword">new</span> Widget(arg1, arg2))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">auto</span> w2 = std::<span class="built_in">make_shared</span>&lt;Widget&gt;(arg1, arg2);</span><br></pre></td></tr></table></figure>

<p>这样做的优势：</p>
<ul>
<li>避免内存泄漏风险（如表达式计算顺序问题）</li>
<li><code>make_shared</code>只分配一次内存（同时分配对象和控制块）</li>
<li>代码更简洁</li>
</ul>
<h5 id="2-处理自定义删除器"><a href="#2-处理自定义删除器" class="headerlink" title="2. 处理自定义删除器"></a>2. 处理自定义删除器</h5><p>有时需要特殊的资源清理逻辑：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件句柄的自定义删除器</span></span><br><span class="line"><span class="keyword">auto</span> fileDeleter = [](FILE* file) &#123; </span><br><span class="line">    <span class="keyword">if</span> (file) <span class="built_in">fclose</span>(file); </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_ptr&lt;FILE, <span class="title">decltype</span><span class="params">(fileDeleter)</span>&gt; </span></span><br><span class="line"><span class="function">    <span class="title">filePtr</span><span class="params">(fopen(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>), fileDeleter)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>实际场景：</strong></p>
<ul>
<li>关闭文件、套接字</li>
<li>释放C库分配的内存</li>
<li>释放系统资源（如Windows中的句柄）</li>
</ul>
<h5 id="3-避免智能指针的常见陷阱"><a href="#3-避免智能指针的常见陷阱" class="headerlink" title="3. 避免智能指针的常见陷阱"></a>3. 避免智能指针的常见陷阱</h5><h6 id="循环引用问题"><a href="#循环引用问题" class="headerlink" title="循环引用问题"></a>循环引用问题</h6><p>这是最常见的问题之一：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;Child&gt; child;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;Parent&gt; parent;  <span class="comment">// 会导致循环引用！</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createObjects</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> parent = std::<span class="built_in">make_shared</span>&lt;Parent&gt;();</span><br><span class="line">    <span class="keyword">auto</span> child = std::<span class="built_in">make_shared</span>&lt;Child&gt;();</span><br><span class="line">    </span><br><span class="line">    parent-&gt;child = child;</span><br><span class="line">    child-&gt;parent = parent;  <span class="comment">// 循环引用形成</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 函数结束，但两个对象都不会被释放！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决方案：使用weak_ptr</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::weak_ptr&lt;Parent&gt; parent;  <span class="comment">// 使用weak_ptr打破循环</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h6 id="从this创建shared-ptr的危险"><a href="#从this创建shared-ptr的危险" class="headerlink" title="从this创建shared_ptr的危险"></a>从this创建shared_ptr的危险</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 危险！可能导致同一对象有两个独立的控制块</span></span><br><span class="line">        <span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">self</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">        worker-&gt;<span class="built_in">enqueue</span>(self);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>解决方案：使用<code>enable_shared_from_this</code></strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> : <span class="keyword">public</span> std::enable_shared_from_this&lt;Widget&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 安全地获取shared_ptr</span></span><br><span class="line">        <span class="keyword">auto</span> self = <span class="built_in">shared_from_this</span>();</span><br><span class="line">        worker-&gt;<span class="built_in">enqueue</span>(self);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h5 id="4-性能考量"><a href="#4-性能考量" class="headerlink" title="4. 性能考量"></a>4. 性能考量</h5><ul>
<li><code>unique_ptr</code>几乎无开销，放心使用</li>
<li><code>shared_ptr</code>有引用计数开销，尤其是频繁复制时</li>
<li>大量小对象使用<code>shared_ptr</code>可能导致内存碎片</li>
<li>避免频繁的<code>shared_ptr</code>复制，考虑传递引用</li>
</ul>
<h5 id="5-针对大型项目的建议"><a href="#5-针对大型项目的建议" class="headerlink" title="5. 针对大型项目的建议"></a>5. 针对大型项目的建议</h5><h6 id="明确所有权策略"><a href="#明确所有权策略" class="headerlink" title="明确所有权策略"></a>明确所有权策略</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数参数中表明所有权语义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processData</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;Data&gt;&amp; data)</span></span>;  <span class="comment">// 共享访问，不获取所有权</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumeData</span><span class="params">(std::unique_ptr&lt;Data&gt; data)</span></span>;  <span class="comment">// 获取独占所有权</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">borrowData</span><span class="params">(Data* data)</span></span>;  <span class="comment">// 临时访问，不涉及所有权</span></span><br></pre></td></tr></table></figure>



<h6 id="在API边界使用原始指针或引用"><a href="#在API边界使用原始指针或引用" class="headerlink" title="在API边界使用原始指针或引用"></a>在API边界使用原始指针或引用</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;Impl&gt; pImpl_;  <span class="comment">// 内部使用智能指针管理生命周期</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// API使用原始引用，不暴露内存管理细节</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">const</span> Data&amp; data)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="实际工程案例"><a href="#实际工程案例" class="headerlink" title="实际工程案例"></a>实际工程案例</h4><h5 id="案例1：资源管理系统"><a href="#案例1：资源管理系统" class="headerlink" title="案例1：资源管理系统"></a>案例1：资源管理系统</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ResourceManager</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 缓存使用weak_ptr，不阻止资源释放</span></span><br><span class="line">    std::unordered_map&lt;std::string, std::weak_ptr&lt;Resource&gt;&gt; resourceCache_;</span><br><span class="line">    std::mutex cacheMutex_;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::shared_ptr&lt;Resource&gt; <span class="title">getResource</span><span class="params">(<span class="type">const</span> std::string&amp; id)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(cacheMutex_)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 尝试从缓存获取</span></span><br><span class="line">        <span class="keyword">auto</span> it = resourceCache_.<span class="built_in">find</span>(id);</span><br><span class="line">        <span class="keyword">if</span> (it != resourceCache_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="comment">// 尝试将weak_ptr提升为shared_ptr</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">auto</span> resource = it-&gt;second.<span class="built_in">lock</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> resource;  <span class="comment">// 缓存命中，返回已有资源</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建新资源</span></span><br><span class="line">        <span class="keyword">auto</span> resource = std::<span class="built_in">make_shared</span>&lt;Resource&gt;(id);</span><br><span class="line">        resourceCache_[id] = resource;  <span class="comment">// 存入缓存</span></span><br><span class="line">        <span class="keyword">return</span> resource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h5 id="案例2：组件系统"><a href="#案例2：组件系统" class="headerlink" title="案例2：组件系统"></a>案例2：组件系统</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameObject</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;std::unique_ptr&lt;Component&gt;&gt; components_;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">    T* <span class="title">addComponent</span><span class="params">(Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> component = std::<span class="built_in">make_unique</span>&lt;T&gt;(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">        T* rawPtr = component.<span class="built_in">get</span>();  <span class="comment">// 保存原始指针用于返回</span></span><br><span class="line">        components_.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(component));</span><br><span class="line">        <span class="keyword">return</span> rawPtr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="keyword">auto</span> gameObject = std::<span class="built_in">make_unique</span>&lt;GameObject&gt;();</span><br><span class="line"><span class="keyword">auto</span> renderer = gameObject-&gt;<span class="built_in">addComponent</span>&lt;RenderComponent&gt;(meshData);</span><br><span class="line"><span class="keyword">auto</span> physics = gameObject-&gt;<span class="built_in">addComponent</span>&lt;PhysicsComponent&gt;(mass, volume);</span><br></pre></td></tr></table></figure>



<h4 id="总结：智能指针使用指南"><a href="#总结：智能指针使用指南" class="headerlink" title="总结：智能指针使用指南"></a>总结：智能指针使用指南</h4><ol>
<li><strong>默认选择<code>unique_ptr</code></strong> - 除非确实需要共享所有权</li>
<li><strong>需要共享所有权时使用<code>shared_ptr</code></strong></li>
<li><strong>处理循环引用时使用<code>weak_ptr</code></strong></li>
<li><strong>始终使用<code>make_</code>函数创建</strong> - <code>std::make_unique</code>和<code>std::make_shared</code></li>
<li><strong>不要混用原始<code>new/delete</code>和智能指针</strong></li>
<li><strong>小心<code>this</code>指针与智能指针的关系</strong> - 需要时继承<code>enable_shared_from_this</code></li>
<li><strong>明确函数参数中的所有权语义</strong></li>
<li><strong>在类中使用智能指针管理资源，在API边界使用引用或原始指针</strong></li>
</ol>
]]></content>
      <categories>
        <category>c++11</category>
        <category>智能指针</category>
      </categories>
  </entry>
  <entry>
    <title>生产者-消费者模式</title>
    <url>/2025/03/07/conCurrency__comsumer&amp;producer/</url>
    <content><![CDATA[<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>在介绍生产者-消费者模式之前，首先讲讲线程与进程的区别，以及互斥锁和条件变量、信号量</p>
<ul>
<li>线程：进程执行流的最小单元</li>
<li>进程：操作系统执行流的最小单元</li>
<li><strong>进程与线程的区别</strong>：<font color='mediumseagreen'>每个进程都有独立的内存空间，因此多进程将耗费大量系统资源，而线程只有栈区是独立的，堆区和数据都是共享的。</font>如下图所示</li>
</ul>
<span id="more"></span>

<p><img src="/thread__comsumer&producer/image-20250307230213904.png" alt="image-20250307230213904"></p>
<ul>
<li><p>线程销毁：在c中使用<code>pthread_detach()</code>来引导线程销毁，一般服务端不使用<code>pthread_join()</code>，因为该函数会一直阻塞等待线程终止，而对于服务端来说是不能这样阻塞的。</p>
</li>
<li><p>互斥锁：主要用于线程安全，可以通过创建互斥锁，并将需要保护的临界区使用<code>lock</code>和<code>unlock</code>围住，<strong>当前线程在执行临界区代码时，其它线程会进入阻塞状态。</strong><font color='red'>防止同一变量被多个线程同时操作，导致混乱</font></p>
</li>
<li><p>条件变量：和互斥锁配合使用，主要用于消费者-生产者模式，实现线程同步</p>
</li>
<li><p>信号量: 定义两个信号量，并将初值分别初始化为0，1，也可以实现线程同步. 调用一次<code>sem_wait()</code>对应的信号量就减1，当信号量值已经为0了，如果又运行到<code>sem_wait()</code>就会阻塞，直到<code>sem_post()</code>运行，给该信号量值+1。</p>
</li>
</ul>
<h2 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h2><p>我们直接通过代码来进行分析</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生产者-消费者问题</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 共享缓冲区</span></span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; buffer;</span><br><span class="line"><span class="comment">// 最大缓冲区大小</span></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> BUFFER_SIZE = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 互斥锁和条件变量</span></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv_producer;</span><br><span class="line">std::condition_variable cv_consumer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者线程函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> product = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待缓冲区有空位</span></span><br><span class="line">        cv_producer.<span class="built_in">wait</span>(lock, []() &#123; <span class="keyword">return</span> buffer.<span class="built_in">size</span>() &lt; BUFFER_SIZE; &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生产数据并放入缓冲区</span></span><br><span class="line">        product++;</span><br><span class="line">        buffer.<span class="built_in">push</span>(product);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Producer &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; produced: &quot;</span> &lt;&lt; product &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知消费者有数据可取</span></span><br><span class="line">        cv_consumer.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放锁，生产间隔一段时间（模拟生产过程）</span></span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者线程函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待缓冲区有数据</span></span><br><span class="line">        cv_consumer.<span class="built_in">wait</span>(lock, []() &#123; <span class="keyword">return</span> !buffer.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费数据</span></span><br><span class="line">        <span class="type">int</span> consumed_product = buffer.<span class="built_in">front</span>();</span><br><span class="line">        buffer.<span class="built_in">pop</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Consumer &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; consumed: &quot;</span> &lt;&lt; consumed_product &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知生产者缓冲区有空位</span></span><br><span class="line">        cv_producer.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放锁，消费间隔一段时间（模拟消费过程）</span></span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">150</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建生产者和消费者线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">producer1</span><span class="params">(producer, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">producer2</span><span class="params">(producer, <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">consumer1</span><span class="params">(consumer, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">consumer2</span><span class="params">(consumer, <span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让主线程等待生产者和消费者线程（通常不会结束）</span></span><br><span class="line">    producer<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    producer<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    consumer<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    consumer<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的输出结果为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Producer 1 produced: 1</span><br><span class="line">Producer 2 produced: 1</span><br><span class="line">Consumer 1 consumed: 1</span><br><span class="line">Consumer 2 consumed: 1</span><br><span class="line">Producer 2 produced: 2</span><br><span class="line">Producer 1 produced: 2</span><br><span class="line">Consumer 1 consumed: 2</span><br><span class="line">Consumer 2 consumed: 2</span><br><span class="line">Producer 1 produced: 3</span><br><span class="line">Producer 2 produced: 3</span><br><span class="line">Consumer 1 consumed: 3</span><br><span class="line">Consumer 2 consumed: 3</span><br><span class="line">Producer 1 produced: 4</span><br><span class="line">Producer 2 produced: 4</span><br><span class="line">.....</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>执行流程</strong></li>
</ul>
<blockquote>
<p><strong><font color='mediumseagreen'>假设消费者先获得锁：</font></strong></p>
<ol>
<li><p>消费者调用<code>std::unique_lock&lt;std::mutex&gt; lock(mtx)</code>获取锁</p>
</li>
<li><p>消费者执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cv_consumer.wait(lock, []() &#123; return !buffer.empty(); &#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>由于<code>buffer.empty()</code>为真，<code>!buffer.empty()</code>为假</li>
<li>消费者会释放锁并进入等待状态</li>
</ul>
</li>
<li><p>此时锁被释放，生产者可以获取锁</p>
</li>
</ol>
<p><strong><font color='mediumseagreen'>生产者获得锁：</font></strong></p>
<ol>
<li><p>生产者调用<code>std::unique_lock&lt;std::mutex&gt; lock(mtx)</code>获取锁</p>
</li>
<li><p>生产者执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cv_producer.wait(lock, []() &#123; return buffer.size() &lt; BUFFER_SIZE; &#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>由于<code>buffer.size() &lt; BUFFER_SIZE</code>为真（缓冲区为空）</li>
<li>生产者不阻塞，继续执行</li>
</ul>
</li>
<li><p>生产者放入数据：<code>buffer.push(product)</code></p>
</li>
<li><p>生产者调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cv_consumer.notify_all()</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>关键点</strong>：这里仅发送通知，不会立即唤醒消费者线程</li>
<li>消费者线程仍在等待状态，只有当锁被释放后才会被唤醒</li>
</ul>
</li>
<li><p>生产者通过<code>lock.unlock()</code>释放锁</p>
</li>
<li><p><strong>这时</strong>消费者线程才会被唤醒并尝试重新获取锁</p>
</li>
</ol>
<p><strong><font color='mediumseagreen'>消费者被唤醒：</font></strong></p>
<ol>
<li><p>消费者获取锁</p>
</li>
<li><p>消费者重新检查条件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">!buffer.empty()</span><br></pre></td></tr></table></figure>

<ul>
<li>由于缓冲区现在有数据，条件为真</li>
</ul>
</li>
<li><p>消费者从缓冲区取出数据并处理</p>
</li>
<li><p>消费者调用<code>cv_producer.notify_all()</code>通知生产者</p>
</li>
<li><p>消费者通过<code>lock.unlock()</code>释放锁</p>
</li>
</ol>
</blockquote>
<p><strong>在这里我们使用了互斥锁保护了临界区</strong>，如下所示，在多线程运行的情况下，通过互斥锁保证了buffer中数据是正常的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//生产者中</span></span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line"><span class="comment">// 等待缓冲区有空位</span></span><br><span class="line">cv_producer.<span class="built_in">wait</span>(lock, []() &#123; <span class="keyword">return</span> buffer.<span class="built_in">size</span>() &lt; BUFFER_SIZE; &#125;);</span><br><span class="line"><span class="comment">// 生产数据并放入缓冲区</span></span><br><span class="line">product++;</span><br><span class="line">buffer.<span class="built_in">push</span>(product);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Producer &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; produced: &quot;</span> &lt;&lt; product &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">// 通知消费者有数据可取</span></span><br><span class="line">cv_consumer.<span class="built_in">notify_all</span>();</span><br><span class="line"><span class="comment">// 释放锁，生产间隔一段时间（模拟生产过程）</span></span><br><span class="line">lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者中</span></span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line"><span class="comment">// 等待缓冲区有数据</span></span><br><span class="line">cv_consumer.<span class="built_in">wait</span>(lock, []() &#123; <span class="keyword">return</span> !buffer.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line"><span class="comment">// 消费数据</span></span><br><span class="line"><span class="type">int</span> consumed_product = buffer.<span class="built_in">front</span>();</span><br><span class="line">buffer.<span class="built_in">pop</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Consumer &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; consumed: &quot;</span> &lt;&lt; consumed_product &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">// 通知生产者缓冲区有空位</span></span><br><span class="line">cv_producer.<span class="built_in">notify_all</span>();</span><br><span class="line"><span class="comment">// 释放锁，消费间隔一段时间（模拟消费过程）</span></span><br><span class="line">lock.<span class="built_in">unlock</span>();</span><br></pre></td></tr></table></figure>

<p>此外，我们还需要注意以下几点：</p>
<blockquote>
<p><strong>条件变量通知后不会立即执行</strong>：当线程A调用<code>notify_all()</code>时，线程B不会立即从等待状态恢复执行。线程B只有在线程A释放锁后才有机会获取锁并检查条件。</p>
<p><strong>条件变量始终与锁配合使用</strong>：</p>
<ul>
<li><code>wait()</code>操作会自动释放锁</li>
<li>被通知唤醒后，线程会重新尝试获取锁</li>
<li>获取锁成功后，会再次检查条件</li>
</ul>
<p><strong>条件变量防止虚假唤醒</strong>：<code>wait()</code>函数的谓词参数(lambda函数)用于防止虚假唤醒。即使线程被错误地唤醒，它也会检查条件是否真的满足。</p>
<p><strong>通知只是发信号，不会立即触发执行</strong>：通知只是告诉等待的线程”可能满足条件了”，被通知的线程仍然需要:</p>
<ul>
<li>等待当前持有锁的线程释放锁</li>
<li>获取锁</li>
<li>重新检查条件是否满足</li>
</ul>
<p><strong>线程的栈区是独立的</strong>，所以两个生产者输出的produced才会是独立的，而其它全局区数据是多线程共享的</p>
</blockquote>
<h2 id="补充：信号量实现线程同步"><a href="#补充：信号量实现线程同步" class="headerlink" title="补充：信号量实现线程同步"></a>补充：信号量实现线程同步</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 基于c实现*/</span></span><br><span class="line"><span class="comment">//前面省略</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">sem_t</span> sem_one;</span><br><span class="line"><span class="type">static</span> <span class="type">sem_t</span> sem_two;</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> id_t1, id_t2;</span><br><span class="line">    <span class="comment">//创建信号量</span></span><br><span class="line">    sem_init(&amp;sem_one, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//信号值初始化为0</span></span><br><span class="line">    sem_init(&amp;sem_two, <span class="number">0</span>, <span class="number">1</span>);<span class="comment">//信号值初始化为1</span></span><br><span class="line">   	</span><br><span class="line">    <span class="comment">//read先执行</span></span><br><span class="line">   	pthread_create(&amp;id_t1, <span class="literal">NULL</span>, read, <span class="literal">NULL</span>);<span class="comment">//线程id_t1执行的函数为read</span></span><br><span class="line">    pthread_create(&amp;id_t2, <span class="literal">NULL</span>, accu, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    pthread_join(id_t1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(id_t2, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    sem_destroy(&amp;sem_one);</span><br><span class="line">    sem_destroy(&amp;sem_two);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//生产者</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">read</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;Input num: &quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">        sem_wait(&amp;sem_two); <span class="comment">//sem_two减1，现在是0,可以往下执行，后面就无法再减了，需要等待消费者通知(即给sem_two加1)</span></span><br><span class="line">  	    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, num);</span><br><span class="line">        sem_post(&amp;sem_one); <span class="comment">//sem_one加1，现在值为1，通知消费者。</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">accu</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        sem_wait(&amp;sem_one); <span class="comment">//初始值就是0，没法再减了，阻塞在这</span></span><br><span class="line">        num += <span class="number">1</span>;</span><br><span class="line">        sem_post(&amp;sem_two);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>并发</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>线程同步</tag>
        <tag>线程安全</tag>
      </tags>
  </entry>
  <entry>
    <title>typora+hexo-asset-img插入文章图片</title>
    <url>/2025/02/18/blog_typora&amp;hexo-asset-img/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在使用hexo部署博客文章时，发现hexo默认的上传文件方式不太方便(如下)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% asset_img image.png name %&#125;</span><br></pre></td></tr></table></figure>

<p>于是上网搜索方案，发现typora配合其它转图片路径的插件的方案很方便，但是在试过<code>hexo-asset-image</code>和<code>hexo-renderer-marked</code>之后，发现直接在typora中粘贴图片(即markdown格式)还是无法在网页上显示图片。</p>
<p>以下是遇到的主要问题及解决方法</p>
<span id="more"></span>

<h2 id="问题1："><a href="#问题1：" class="headerlink" title="问题1："></a>问题1：</h2><p><strong>_post目录下如果在生成的.md目录插入图片就会生成两个同名的文件夹(实际上有一个后面多了一个空格)，导致默认的图片上传方式都出问题</strong></p>
<p><strong>原因及解决方案</strong>：在修改_config.yml文件中的<strong>post_asset_folder为true</strong>之后，如果使用<code>hexo new xxx</code>的方式生成.md文件和同名文件夹，且同时还将typora的偏好设置为<code>./$&#123;filename&#125;</code>，那么就会出现这样的问题，解决办法就是直接手动创建一个.md文件，只要插入图片，typora就自动会生成一个同名文件夹，并加图片放入。（<font color='red'>注意不要将post_asset_folder又设回false了</font>）</p>
<h2 id="问题2："><a href="#问题2：" class="headerlink" title="问题2："></a>问题2：</h2><p><strong>按照网上许多方法仍然无法直接使用<code>![](xx.png)</code>这种markdown格式插入图片</strong></p>
<p><strong>原因分析</strong>：<font color='red'>该问题的主要原因在于插件版本和hexo版本不一致</font>。在本地生成的静态网页中我们可以按”F12”查看图片路径是否转换成功。</p>
<img src="/2025/02/18/blog_typora&hexo-asset-img/image-20250218221232758.png" class="" title="F12查看图片路径">

<p>如图所示，&#x2F;2025&#x2F;02&#x2F;18&#x2F;player&#x2F;xx这个目录就是<code>hexo g</code>执行后生成到public目录下的。</p>
<ul>
<li>从文件中查看，如果该目录下没有我们文章中出现的图片，则说明图片上传失败；</li>
<li>而从网页端查看则如图所示，即图片源路径指向了对应的目录。</li>
</ul>
<p>上面两种方式都可以用来判断图片是否上传成功</p>
<p><strong>解决办法:</strong></p>
<p>由于我们使用的是hexo6.3.0版本，<code>hexo-asset-image</code>插件已经无法适配，所以这里直接下载另外一个<code>hexo-asset-img</code>插件即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-asset-img --save</span><br></pre></td></tr></table></figure>

<p>随后，按照问题1的方式创建.md文件，直接在typora中粘贴图片，即可实现图片和文章一起上传至博客网站.</p>
<p>在typora中图片插入的具体的格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![命名](与.md同名文件夹/logo.png)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>死锁与活锁</title>
    <url>/2025/04/21/conCurrency__muteManage/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>并发</category>
        <category>锁管理</category>
      </categories>
      <tags>
        <tag>死锁</tag>
        <tag>活锁</tag>
      </tags>
  </entry>
  <entry>
    <title>网络IO复用模型</title>
    <url>/2025/04/21/concurrentServer__Net_IOmodel/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li><strong>什么是网络IO复用？</strong></li>
</ul>
<blockquote>
<p>允许<strong>单个</strong>进程或线程同时监视多个文件描述符（如网络连接）的技术，<strong>只有当其中某个描述符就绪时（可读、可写或发生错误）才进行处理，而不需要为每个连接创建新的进程或线程。</strong></p>
</blockquote>
<ul>
<li><p><strong>为什么出现了网络IO复用技术</strong></p>
<blockquote>
<p>即便多进程服务器创建的子进程在数据传输完成后就会断开连接，并由信号处理函数完成子进程的销毁，但是这期间也可以有多个子进程的创建。而创建多个进程需要大量运算和内存空间，此外由于每个进程都有独立的内存空间，想要相互交换数据就需要IPC，因此需要io复用等技术</p>
<p><strong>io复用并不适用所有情况，需要根据服务器端特性选择</strong></p>
</blockquote>
</li>
</ul>
<span id="more"></span>

<p>以下基于网络io复用模型的服务端均基于tcp连接</p>
<h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p><strong>优点</strong>：兼容性强，linux和windows均可</p>
<p><strong>缺点</strong>：需要轮询监视的文件描述符集合，且文件描述符的变化监视本质还是内核完成，因此发生变化时还需要将事件拷贝到用户态（即存在用户态-内核态-用户态的切换过程），比较消耗资源。</p>
<blockquote>
<p><strong>select实现io复用的步骤：</strong></p>
<p>1.设置文件描述符，指定监视范围，设置超时</p>
<p>2.调用select函数</p>
<p>3.查看调用结果</p>
</blockquote>
<p>关键结构体：<code>fd_set</code> (对应的宏有<code>FD_ZERO(&amp;set), FD_SET(1, &amp;set) </code>)</p>
<p>关键函数：<code>select()</code>函数。select只有在监视的文件描述符发生变化时才会返回，如果未发生变化，就会进入阻塞状态。select判断文件描述符是否发生变化的过程如下，即需要比较变化前后文件描述符对应的值</p>
<img src="/2025/04/21/concurrentServer__Net_IOmodel/image-20250421224125140.png" class="" title="image-20250421224125140">

<p>一个简单的<code>select</code>服务端（linux中）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>     <span class="comment">// 标准输入输出</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>    <span class="comment">// 标准库函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>    <span class="comment">// 字符串处理函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>    <span class="comment">// UNIX标准函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span> <span class="comment">// 网络地址转换函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span> <span class="comment">// Socket API</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span>  <span class="comment">// 时间相关函数和结构</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span> <span class="comment">// select函数和相关宏定义</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 100   <span class="comment">// 定义缓冲区大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误处理函数声明</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">char</span> *buf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> serv_sock, clnt_sock;       <span class="comment">// 服务器和客户端socket文件描述符</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_adr, clnt_adr; <span class="comment">// 服务器和客户端地址结构</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timeval</span> timeout;         <span class="comment">// select超时结构</span></span><br><span class="line">    fd_set reads, cpy_reads;        <span class="comment">// 文件描述符集合，用于select</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">socklen_t</span> adr_sz;               <span class="comment">// 地址结构大小</span></span><br><span class="line">    <span class="type">int</span> fd_max, str_len, fd_num, i; <span class="comment">// 最大fd，字符串长度，select返回值，循环变量</span></span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE];             <span class="comment">// 数据缓冲区</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查命令行参数</span></span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建服务器TCP套接字</span></span><br><span class="line">    serv_sock=<span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化服务器地址结构</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family=AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr=<span class="built_in">htonl</span>(INADDR_ANY); <span class="comment">// 接受任意IP地址的连接</span></span><br><span class="line">    serv_adr.sin_port=<span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">1</span>]));     <span class="comment">// 设置端口号为命令行参数提供的值</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 绑定socket到指定地址和端口</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">bind</span>(serv_sock, (<span class="keyword">struct</span> sockaddr*) &amp;serv_adr, <span class="built_in">sizeof</span>(serv_adr))==<span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 开始监听连接请求，队列长度为5</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">listen</span>(serv_sock, <span class="number">5</span>)==<span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;listen() error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化fd_set</span></span><br><span class="line">    <span class="built_in">FD_ZERO</span>(&amp;reads);</span><br><span class="line">    <span class="comment">// 将服务器socket添加到监视列表</span></span><br><span class="line">    <span class="built_in">FD_SET</span>(serv_sock, &amp;reads);</span><br><span class="line">    <span class="comment">// 初始化最大文件描述符</span></span><br><span class="line">    fd_max=serv_sock;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 服务器主循环</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 每次select前复制fd_set，因为select会修改传入的fd_set</span></span><br><span class="line">        cpy_reads=reads;</span><br><span class="line">        <span class="comment">// 设置select超时时间为5.5秒</span></span><br><span class="line">        timeout.tv_sec=<span class="number">5</span>;</span><br><span class="line">        timeout.tv_usec=<span class="number">5000</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用select监视读取事件</span></span><br><span class="line">        <span class="keyword">if</span>((fd_num=<span class="built_in">select</span>(fd_max<span class="number">+1</span>, &amp;cpy_reads, <span class="number">0</span>, <span class="number">0</span>, &amp;timeout))==<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// select出错，退出循环</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 如果超时且没有活动事件，继续下一轮循环</span></span><br><span class="line">        <span class="keyword">if</span>(fd_num==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 遍历所有可能的文件描述符，检查哪些有事件发生</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;fd_max<span class="number">+1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 检查当前文件描述符是否有事件</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(i, &amp;cpy_reads))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果是服务器socket有事件，说明有新的连接请求</span></span><br><span class="line">                <span class="keyword">if</span>(i==serv_sock)    <span class="comment">// 连接请求事件</span></span><br><span class="line">                &#123;</span><br><span class="line">                    adr_sz=<span class="built_in">sizeof</span>(clnt_adr);</span><br><span class="line">                    <span class="comment">// 接受新连接</span></span><br><span class="line">                    clnt_sock=</span><br><span class="line">                        <span class="built_in">accept</span>(serv_sock, (<span class="keyword">struct</span> sockaddr*)&amp;clnt_adr, &amp;adr_sz);</span><br><span class="line">                    <span class="comment">// 将新客户端socket添加到监视列表</span></span><br><span class="line">                    <span class="built_in">FD_SET</span>(clnt_sock, &amp;reads);</span><br><span class="line">                    <span class="comment">// 更新最大文件描述符</span></span><br><span class="line">                    <span class="keyword">if</span>(fd_max&lt;clnt_sock)</span><br><span class="line">                        fd_max=clnt_sock;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;connected client: %d \n&quot;</span>, clnt_sock);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>    <span class="comment">// 客户端发送数据事件</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 读取客户端发送的数据</span></span><br><span class="line">                    str_len=<span class="built_in">read</span>(i, buf, BUF_SIZE);</span><br><span class="line">                    <span class="keyword">if</span>(str_len==<span class="number">0</span>)  <span class="comment">// EOF，客户端关闭连接</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 从监视列表中移除客户端socket</span></span><br><span class="line">                        <span class="built_in">FD_CLR</span>(i, &amp;reads);</span><br><span class="line">                        <span class="comment">// 关闭客户端socket</span></span><br><span class="line">                        <span class="built_in">close</span>(i);</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;closed client: %d \n&quot;</span>, i);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 将收到的数据回显给客户端（echo服务）</span></span><br><span class="line">                        <span class="built_in">write</span>(i, buf, str_len);  <span class="comment">// echo!</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关闭服务器socket（实际上这里很少会执行，因为服务器通常是通过信号终止的）</span></span><br><span class="line">    <span class="built_in">close</span>(serv_sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 错误处理函数，输出错误信息并终止程序</span></span><br><span class="line"><span class="comment"> * @param buf 错误信息字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(buf, stderr);    <span class="comment">// 输出错误信息到标准错误</span></span><br><span class="line">    <span class="built_in">fputc</span>(<span class="string">&#x27;\n&#x27;</span>, stderr);   <span class="comment">// 添加换行符</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);               <span class="comment">// 终止程序，返回状态码1表示错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>回声客户端实现（linux）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>      <span class="comment">// 标准输入输出</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>     <span class="comment">// 标准库函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>     <span class="comment">// 字符串处理函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>     <span class="comment">// UNIX标准函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span>  <span class="comment">// 网络地址转换函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span> <span class="comment">// Socket API</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span>    <span class="comment">// POSIX线程库</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 100    <span class="comment">// 定义缓冲区大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NAME_SIZE 20    <span class="comment">// 用户名大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误处理函数声明</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">char</span> *msg)</span></span>;</span><br><span class="line"><span class="comment">// 线程函数声明</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">send_msg</span><span class="params">(<span class="type">void</span> *arg)</span></span>;    <span class="comment">// 发送消息线程</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">recv_msg</span><span class="params">(<span class="type">void</span> *arg)</span></span>;    <span class="comment">// 接收消息线程</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> name[NAME_SIZE] = <span class="string">&quot;[DEFAULT]&quot;</span>;  <span class="comment">// 用户名</span></span><br><span class="line"><span class="type">char</span> msg[BUF_SIZE];                  <span class="comment">// 消息缓冲区</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sock;                        <span class="comment">// 客户端socket</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr;    <span class="comment">// 服务器地址结构</span></span><br><span class="line">    <span class="type">pthread_t</span> snd_thread, rcv_thread;<span class="comment">// 线程ID</span></span><br><span class="line">    <span class="type">void</span> *thread_return;             <span class="comment">// 线程返回值</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 验证命令行参数</span></span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;IP&gt; &lt;port&gt; &lt;name&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置用户名</span></span><br><span class="line">    <span class="built_in">sprintf</span>(name, <span class="string">&quot;[%s]&quot;</span>, argv[<span class="number">3</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建客户端TCP套接字</span></span><br><span class="line">    sock = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sock == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化服务器地址结构</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(argv[<span class="number">1</span>]);  <span class="comment">// 服务器IP地址</span></span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">2</span>]));       <span class="comment">// 服务器端口</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 连接到服务器</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">connect</span>(sock, (<span class="keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;connect() error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建发送消息线程</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">pthread_create</span>(&amp;snd_thread, <span class="literal">NULL</span>, send_msg, (<span class="type">void</span>*)&amp;sock) != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;pthread_create() error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建接收消息线程</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">pthread_create</span>(&amp;rcv_thread, <span class="literal">NULL</span>, recv_msg, (<span class="type">void</span>*)&amp;sock) != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;pthread_create() error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 等待发送线程结束</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">pthread_join</span>(snd_thread, &amp;thread_return) != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;pthread_join() error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 等待接收线程结束</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">pthread_join</span>(rcv_thread, &amp;thread_return) != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;pthread_join() error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关闭套接字</span></span><br><span class="line">    <span class="built_in">close</span>(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送消息线程函数</span></span><br><span class="line"><span class="comment"> * @param arg 指向套接字的指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">send_msg</span><span class="params">(<span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sock = *((<span class="type">int</span>*)arg);    <span class="comment">// 解引用获取套接字描述符</span></span><br><span class="line">    <span class="type">char</span> name_msg[NAME_SIZE + BUF_SIZE];  <span class="comment">// 带用户名的消息</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 从标准输入读取消息</span></span><br><span class="line">        <span class="built_in">fgets</span>(msg, BUF_SIZE, stdin);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果输入&quot;q&quot;或&quot;Q&quot;，发送退出消息并结束线程</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(msg, <span class="string">&quot;q\n&quot;</span>) || !<span class="built_in">strcmp</span>(msg, <span class="string">&quot;Q\n&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">close</span>(sock);  <span class="comment">// 关闭套接字</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);      <span class="comment">// 退出程序</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将用户名和消息组合</span></span><br><span class="line">        <span class="built_in">sprintf</span>(name_msg, <span class="string">&quot;%s %s&quot;</span>, name, msg);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 发送消息到服务器</span></span><br><span class="line">        <span class="built_in">write</span>(sock, name_msg, <span class="built_in">strlen</span>(name_msg));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接收消息线程函数</span></span><br><span class="line"><span class="comment"> * @param arg 指向套接字的指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">recv_msg</span><span class="params">(<span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sock = *((<span class="type">int</span>*)arg);    <span class="comment">// 解引用获取套接字描述符</span></span><br><span class="line">    <span class="type">char</span> name_msg[NAME_SIZE + BUF_SIZE];  <span class="comment">// 接收缓冲区</span></span><br><span class="line">    <span class="type">int</span> str_len;                          <span class="comment">// 接收到的字节数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 从服务器接收消息</span></span><br><span class="line">        str_len = <span class="built_in">read</span>(sock, name_msg, NAME_SIZE + BUF_SIZE - <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果连接关闭或发生错误</span></span><br><span class="line">        <span class="keyword">if</span>(str_len &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">void</span>*)<span class="number">-1</span>;  <span class="comment">// 退出线程</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 添加字符串结束符</span></span><br><span class="line">        name_msg[str_len] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 打印接收到的消息</span></span><br><span class="line">        <span class="built_in">fputs</span>(name_msg, stdout);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 错误处理函数，输出错误信息并终止程序</span></span><br><span class="line"><span class="comment"> * @param msg 错误信息字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">char</span> *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(msg, stderr);    <span class="comment">// 输出错误信息到标准错误</span></span><br><span class="line">    <span class="built_in">fputc</span>(<span class="string">&#x27;\n&#x27;</span>, stderr);   <span class="comment">// 添加换行符</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);               <span class="comment">// 终止程序，返回状态码1表示错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在终端输入<code>./client 127.0.0.1 9190 Username</code>即可启动	</p>
<h3 id="htonl-INADDR-ANY-和-inet-addr-192-168-0-1-的区别"><a href="#htonl-INADDR-ANY-和-inet-addr-192-168-0-1-的区别" class="headerlink" title="htonl(INADDR_ANY)和 inet_addr(&quot;192.168.0.1&quot;)的区别"></a><code>htonl(INADDR_ANY)</code>和 <code>inet_addr(&quot;192.168.0.1&quot;)</code>的区别</h3><img src="/2025/04/21/concurrentServer__Net_IOmodel/image-20250224154139692.png" class="" title="image-20250224154139692">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用 inet_addr() 将点分十进制的ip转换为网络字节序整数：</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *ip_str = <span class="string">&quot;192.168.0.1&quot;</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> ip = inet_addr(ip_str);  <span class="comment">// 转换为网络字节序的整数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 htonl() 将主机字节序的整数转换为网络字节序（大端序）</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> host_ip = <span class="number">0xC0A80001</span>;  <span class="comment">// 192.168.0.1 in hexadecimal (host byte order)</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> network_ip = htonl(host_ip);  <span class="comment">// 转换为网络字节序</span></span><br></pre></td></tr></table></figure>



<h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><p>poll和select区别不大，基本上只有监视集合上的区别</p>
<p>优点：<code>select</code> 使用固定大小的位图数组限制了最大监听 fd 数(最大1024)，<code>poll</code> 使用<strong>可变数组</strong>支持更多 fd（只受限于系统源），且接口更简洁，避免了 <code>select</code> 的 fd_set 限制和繁琐操作。</p>
<p>缺点：<code>poll</code>每次都要重新设置事件数组，不保留状态</p>
<p>一个简单的<code>poll</code>服务端</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">    <span class="comment">// Windows平台特定头文件</span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ws2tcpip.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">int</span> <span class="type">socklen_t</span>;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> CLOSE_SOCKET closesocket</span></span><br><span class="line">    <span class="comment">// WSAPoll函数等同于Linux的poll</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> poll WSAPoll</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">// Linux平台特定头文件</span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> CLOSE_SOCKET close</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> SOCKET int</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> INVALID_SOCKET -1</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> SOCKET_ERROR -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 8889</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_CLIENTS 30</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_platform_specific</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">    <span class="comment">// Windows需要初始化Winsock</span></span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WSAStartup</span>(<span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;WSAStartup 失败\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cleanup_platform_specific</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">    <span class="comment">// Windows需要清理Winsock</span></span><br><span class="line">    <span class="built_in">WSACleanup</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">init_platform_specific</span>();</span><br><span class="line">    </span><br><span class="line">    SOCKET master_socket;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server_addr, client_addr;</span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">    <span class="type">int</span> activity, i, addrlen = <span class="built_in">sizeof</span>(client_addr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建poll使用的结构</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">pollfd</span> fds[MAX_CLIENTS + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> nfds = <span class="number">1</span>;  <span class="comment">// 初始只有主socket</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建主socket</span></span><br><span class="line">    <span class="keyword">if</span> ((master_socket = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == INVALID_SOCKET) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket 创建失败&quot;</span>);</span><br><span class="line">        <span class="built_in">cleanup_platform_specific</span>();</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置socket选项，允许地址重用</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">    <span class="type">char</span> opt = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">setsockopt</span>(master_socket, SOL_SOCKET, SO_REUSEADDR, (<span class="type">const</span> <span class="type">char</span>*)&amp;opt, <span class="built_in">sizeof</span>(opt)) == SOCKET_ERROR) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;setsockopt 失败&quot;</span>);</span><br><span class="line">        <span class="built_in">CLOSE_SOCKET</span>(master_socket);</span><br><span class="line">        <span class="built_in">cleanup_platform_specific</span>();</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 配置服务器地址结构</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    server_addr.sin_port = <span class="built_in">htons</span>(PORT);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 绑定socket</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(master_socket, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="built_in">sizeof</span>(server_addr)) == SOCKET_ERROR) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind 失败&quot;</span>);</span><br><span class="line">        <span class="built_in">CLOSE_SOCKET</span>(master_socket);</span><br><span class="line">        <span class="built_in">cleanup_platform_specific</span>();</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 监听socket，最大连接队列为3</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(master_socket, <span class="number">3</span>) == SOCKET_ERROR) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen 失败&quot;</span>);</span><br><span class="line">        <span class="built_in">CLOSE_SOCKET</span>(master_socket);</span><br><span class="line">        <span class="built_in">cleanup_platform_specific</span>();</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;服务器启动成功，监听端口 %d\n&quot;</span>, PORT);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化fds数组</span></span><br><span class="line">    <span class="built_in">memset</span>(fds, <span class="number">0</span>, <span class="built_in">sizeof</span>(fds));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置主socket到fds[0]</span></span><br><span class="line">    fds[<span class="number">0</span>].fd = master_socket;</span><br><span class="line">    fds[<span class="number">0</span>].events = POLLIN;  <span class="comment">// 监听读事件</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将所有其他fds初始化为-1</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= MAX_CLIENTS; i++) &#123;</span><br><span class="line">        fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 使用poll等待活动</span></span><br><span class="line">        activity = <span class="built_in">poll</span>(fds, nfds, <span class="number">500</span>);  <span class="comment">// 超时500毫秒</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (activity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;poll 错误&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查主socket是否有新连接</span></span><br><span class="line">        <span class="keyword">if</span> (fds[<span class="number">0</span>].revents &amp; POLLIN) &#123;</span><br><span class="line">            SOCKET new_socket;</span><br><span class="line">            <span class="keyword">if</span> ((new_socket = <span class="built_in">accept</span>(master_socket, (<span class="keyword">struct</span> sockaddr*)&amp;client_addr, (<span class="type">socklen_t</span>*)&amp;addrlen)) == INVALID_SOCKET) &#123;</span><br><span class="line">                <span class="built_in">perror</span>(<span class="string">&quot;accept 失败&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;新连接，socket fd: %d, IP: %s, 端口: %d\n&quot;</span>, </span><br><span class="line">                   (<span class="type">int</span>)new_socket, </span><br><span class="line">                   <span class="built_in">inet_ntoa</span>(client_addr.sin_addr), </span><br><span class="line">                   <span class="built_in">ntohs</span>(client_addr.sin_port));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 发送欢迎消息</span></span><br><span class="line">            <span class="type">const</span> <span class="type">char</span>* welcome_message = <span class="string">&quot;欢迎连接到poll服务器\r\n&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">send</span>(new_socket, welcome_message, <span class="built_in">strlen</span>(welcome_message), <span class="number">0</span>) != <span class="built_in">strlen</span>(welcome_message)) &#123;</span><br><span class="line">                <span class="built_in">perror</span>(<span class="string">&quot;send 失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将新socket添加到fds数组</span></span><br><span class="line">            <span class="type">int</span> slot = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= MAX_CLIENTS; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (fds[i].fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    fds[i].fd = new_socket;</span><br><span class="line">                    fds[i].events = POLLIN;  <span class="comment">// 监听读事件</span></span><br><span class="line">                    slot = i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (slot != <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;添加到clients列表，位置: %d\n&quot;</span>, slot);</span><br><span class="line">                <span class="keyword">if</span> (slot &gt;= nfds) &#123;</span><br><span class="line">                    nfds = slot + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;无法添加新连接，服务器已满\n&quot;</span>);</span><br><span class="line">                <span class="built_in">CLOSE_SOCKET</span>(new_socket);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查客户端socket是否有活动</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; nfds; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fds[i].fd &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (fds[i].revents &amp; POLLIN) &#123;</span><br><span class="line">                <span class="built_in">memset</span>(buffer, <span class="number">0</span>, BUFFER_SIZE);</span><br><span class="line">                <span class="type">int</span> valread = <span class="built_in">recv</span>(fds[i].fd, buffer, BUFFER_SIZE, <span class="number">0</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (valread &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 客户端断开连接或错误</span></span><br><span class="line">                    <span class="built_in">getpeername</span>(fds[i].fd, (<span class="keyword">struct</span> sockaddr*)&amp;client_addr, (<span class="type">socklen_t</span>*)&amp;addrlen);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;客户端断开连接，IP: %s, 端口: %d\n&quot;</span>, </span><br><span class="line">                           <span class="built_in">inet_ntoa</span>(client_addr.sin_addr), </span><br><span class="line">                           <span class="built_in">ntohs</span>(client_addr.sin_port));</span><br><span class="line">                    </span><br><span class="line">                    <span class="built_in">CLOSE_SOCKET</span>(fds[i].fd);</span><br><span class="line">                    fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 调整nfds以优化poll调用</span></span><br><span class="line">                    <span class="keyword">if</span> (i == nfds - <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">while</span> (nfds &gt; <span class="number">0</span> &amp;&amp; fds[nfds<span class="number">-1</span>].fd == <span class="number">-1</span>) &#123;</span><br><span class="line">                            nfds--;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 回显消息给客户端</span></span><br><span class="line">                    buffer[valread] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;从客户端接收: %s\n&quot;</span>, buffer);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 简单处理，回显消息</span></span><br><span class="line">                    <span class="type">char</span> response[BUFFER_SIZE + <span class="number">30</span>];</span><br><span class="line">                    <span class="built_in">sprintf</span>(response, <span class="string">&quot;服务器收到: %s&quot;</span>, buffer);</span><br><span class="line">                    <span class="built_in">send</span>(fds[i].fd, response, <span class="built_in">strlen</span>(response), <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关闭所有socket</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nfds; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fds[i].fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">CLOSE_SOCKET</span>(fds[i].fd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cleanup_platform_specific</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p><strong>优点</strong>：epoll的底层实现是一个红黑树+双向链表（还有其它一些底层机制，大体是这两个）。文件描述符的监视是放在内核的红黑树中的，以及发生事件时，会将事件拷贝到就绪队列（双向链表），整个过程用户不参与，用户只需要将发生的事件和文件描述符拷贝就行。</p>
<p>epoll是基于事件驱动的，首先事件发生时，由内核通知，而不用像<code>select</code>和<code>poll</code>那样不断轮询所监视的集合；其次，只用拷贝发生的事件，而不用拷贝整个文件描述符集合。</p>
<p><strong>缺点</strong>：linux特有，其它平台不支持</p>
<p><strong>二个重要接口</strong>：</p>
<ul>
<li><code>epoll_create</code>()</li>
<li><code>epoll_ctl()</code></li>
</ul>
<p><strong>一个结构体</strong>:</p>
<ul>
<li><code>epoll_event</code></li>
</ul>
<p>**水平触发(LT)**：只要输入缓冲(<font color='lightgreen'>创建套接字时，操作系统就会创建一个输入缓冲</font>)还有数据，服务端操作系统就会通知该事件(<strong>注册到发生变化的文件描述符，调用epoll_wait处理通知</strong>)</p>
<p>**边缘触发(ET)**：输入缓冲收到数据只会注册一次该事件（可以给服务器带来高性能），即使输入缓冲还有数据也不会再次注册事件</p>
<p>边缘触发服务端代码实现(linux)：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// epoll_ET_server.c</span></span><br><span class="line"><span class="comment">// 基于边缘触发(Edge Triggered)方式的epoll服务器实现</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 4096        <span class="comment">// 缓冲区大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPOLL_SIZE 50        <span class="comment">// epoll 事件池大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EVENTS 50        <span class="comment">// 单次处理的最大事件数</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误处理函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置文件描述符为非阻塞模式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setnonblocking</span><span class="params">(<span class="type">int</span> fd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> serv_sock, clnt_sock;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr, clnt_addr;</span><br><span class="line">    <span class="type">socklen_t</span> addr_size;</span><br><span class="line">    <span class="type">int</span> str_len, i, j;</span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> *events;        <span class="comment">// 用于接收的事件数组</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> event;          <span class="comment">// 用于注册的事件</span></span><br><span class="line">    <span class="type">int</span> epfd, event_cnt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查命令行参数</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建服务器套接字</span></span><br><span class="line">    serv_sock = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (serv_sock == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置地址重用选项</span></span><br><span class="line">    <span class="type">int</span> option = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">setsockopt</span>(serv_sock, SOL_SOCKET, SO_REUSEADDR, &amp;option, <span class="built_in">sizeof</span>(option));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化服务器地址结构</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">1</span>]));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 绑定套接字</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(serv_sock, (<span class="keyword">struct</span> sockaddr *)&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置监听</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(serv_sock, <span class="number">5</span>) == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;listen() error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建epoll实例</span></span><br><span class="line">    epfd = <span class="built_in">epoll_create</span>(EPOLL_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (epfd == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;epoll_create() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配events数组空间</span></span><br><span class="line">    events = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> epoll_event) * MAX_EVENTS);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置服务器套接字为非阻塞模式</span></span><br><span class="line">    <span class="built_in">setnonblocking</span>(serv_sock);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 向epoll注册服务器套接字事件</span></span><br><span class="line">    event.events = EPOLLIN;      <span class="comment">// 使用水平触发模式监听服务器套接字</span></span><br><span class="line">    event.data.fd = serv_sock;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, serv_sock, &amp;event);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Server started. Waiting for connections...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主循环</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 等待事件发生</span></span><br><span class="line">        event_cnt = <span class="built_in">epoll_wait</span>(epfd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (event_cnt == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">error_handling</span>(<span class="string">&quot;epoll_wait() error&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理所有就绪的事件</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; event_cnt; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (events[i].data.fd == serv_sock) &#123;  <span class="comment">// 新的客户端连接</span></span><br><span class="line">                addr_size = <span class="built_in">sizeof</span>(clnt_addr);</span><br><span class="line">                clnt_sock = <span class="built_in">accept</span>(serv_sock, (<span class="keyword">struct</span> sockaddr *)&amp;clnt_addr, &amp;addr_size);</span><br><span class="line">                <span class="keyword">if</span> (clnt_sock == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;accept() error\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 设置客户端套接字为非阻塞模式</span></span><br><span class="line">                <span class="built_in">setnonblocking</span>(clnt_sock);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 向epoll注册客户端套接字，使用边缘触发模式</span></span><br><span class="line">                event.events = EPOLLIN | EPOLLET;  <span class="comment">// 边缘触发模式</span></span><br><span class="line">                event.data.fd = clnt_sock;</span><br><span class="line">                <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, clnt_sock, &amp;event);</span><br><span class="line">                </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Connected client: %d\n&quot;</span>, clnt_sock);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 已有客户端的数据就绪</span></span><br><span class="line">                <span class="comment">// 使用循环读取数据，直到没有数据为止 (边缘触发模式必须)</span></span><br><span class="line">                <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                    str_len = <span class="built_in">read</span>(events[i].data.fd, buf, BUF_SIZE);</span><br><span class="line">                    <span class="keyword">if</span> (str_len == <span class="number">0</span>) &#123;  <span class="comment">// 客户端关闭连接</span></span><br><span class="line">                        <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_DEL, events[i].data.fd, <span class="literal">NULL</span>);</span><br><span class="line">                        <span class="built_in">close</span>(events[i].data.fd);</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;Closed client: %d\n&quot;</span>, events[i].data.fd);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str_len &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (errno == EAGAIN || errno == EWOULDBLOCK) &#123;</span><br><span class="line">                            <span class="comment">// 没有更多数据可读，退出读取循环</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="built_in">error_handling</span>(<span class="string">&quot;read() error&quot;</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 有数据，进行回显</span></span><br><span class="line">                        <span class="comment">// 实际应用中，这里可能需要使用循环确保写入所有数据</span></span><br><span class="line">                        <span class="built_in">write</span>(events[i].data.fd, buf, str_len);</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;Echoed %d bytes to client %d\n&quot;</span>, str_len, events[i].data.fd);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="built_in">close</span>(serv_sock);</span><br><span class="line">    <span class="built_in">close</span>(epfd);</span><br><span class="line">    <span class="built_in">free</span>(events);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置文件描述符为非阻塞模式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setnonblocking</span><span class="params">(<span class="type">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> flags = <span class="built_in">fcntl</span>(fd, F_GETFL, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">fcntl</span>(fd, F_SETFL, flags | O_NONBLOCK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误处理函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, stderr);</span><br><span class="line">    <span class="built_in">fputc</span>(<span class="string">&#x27;\n&#x27;</span>, stderr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>并发</category>
        <category>网络IO复用</category>
      </categories>
  </entry>
  <entry>
    <title>linux常用命令总结</title>
    <url>/2025/02/23/linux_bashCmd01/</url>
    <content><![CDATA[<p>总结了一些linux中常用的基本命令和项目中常用的命令</p>
<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><ul>
<li>shell ：即命令解释器，是用户和linux内核交互的桥梁，通过在shell终端输入命令让linux内核相应部分识别用户命令并处理。</li>
</ul>
<span id="more"></span>

<style>.pecoljizyysm{zoom:50%;}</style><img src="/2025/02/23/linux_bashCmd01/image-20250422133735308.png" class="pecoljizyysm" alt="image-20250422133735308">

<blockquote>
<p><strong>bash与shell的关系</strong></p>
<p><strong>Shell就是终端程序的统称</strong>，它充当了人与内核（硬件）之间的翻译官，用户把一些命令“告诉”终端程序，它就会调用相应的程序服务去完成某些工作。许多主流Linux系统默认使用的<strong>终端是Bash（Bourne-Again SHell）解释器。</strong></p>
<p><strong>Shell与Bash是包含与被包含的关系</strong>。举例来说，在社会中有翻译官这个职业，它是由许多从业者共同组成的职业名称，而Bash则是其中一个出色的成员，是Shell终端程序中的一份子。</p>
</blockquote>
<p>shell命令的基本格式为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">命令 [option] 参数 </span><br></pre></td></tr></table></figure>
<p>​	其中加”[]”符号表示可以不输入这个选项</p>
<p><strong>tips</strong>: </p>
<ul>
<li><p>对于不熟悉的命令可以使用<code>man 1 命令</code>或者<code>命令 --help</code>来查看说明</p>
<img src="/2025/02/23/linux_bashCmd01/image-20250422135042892.png" class="" title="image-20250422135042892">
</li>
<li><p>注意如果想要在windows复制并粘贴到linux虚拟机中，就要安装open-vm-tools，而vm-tools是老版的，重复安装这两个就会冲突，所以只安装open-vm-tools即可。对应命令为：</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install open-vm-tools-desktop</span><br></pre></td></tr></table></figure>

<p>​	以下给出几个vm-tools的区别</p>
<blockquote>
<p><strong>open-vm-tools</strong>：开源工具集，主要用于 Linux 虚拟机。</p>
<p><strong>vm-tools</strong>：VMware 提供的专有工具集，通常用于 VMware 产品。</p>
<p><strong>open-vm-tools-desktop</strong>：<code>open-vm-tools</code> 的桌面扩展版，专为桌面环境（有图形界面的 Linux）优化，提供更多图形相关的功能。</p>
</blockquote>
<p>linux磁盘相关文件系统，扩容等：<a href="https://blog.csdn.net/zhanhjxxx/article/details/123232402">Linux磁盘分区详解（新建分区，现有分区扩容，分区减容）_linux分区-CSDN博客</a></p>
<h2 id="基本常用命令"><a href="#基本常用命令" class="headerlink" title="基本常用命令"></a>基本常用命令</h2><ol>
<li>切换用户权限组</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo su //切换为管理员</span><br><span class="line">exit //推出管理员权限</span><br></pre></td></tr></table></figure>

<p>在命令前加<code>sudo</code>也可以使用管理员权限</p>
<ol start="2">
<li>创建目录</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -m 目录名</span><br><span class="line">mkdir -r /home/hh # -r 可以递归的创建目录</span><br></pre></td></tr></table></figure>

<p>3.删除目录或者文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -i 文件名</span><br><span class="line">rm -r 目录名 #主要用来删除目录</span><br><span class="line">rm -f 文件名 #强制删除</span><br></pre></td></tr></table></figure>

<p>4.切换路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /  #切换到根目录</span><br><span class="line">cd ~  #切换到家目录</span><br><span class="line">cd /home/xxx  </span><br></pre></td></tr></table></figure>

<p>5.gedit 记事本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gedit main.c</span><br></pre></td></tr></table></figure>

<p>6.查看文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat main.c #查看文件内容并输出到shell终端</span><br><span class="line">cat -A 文件名  #隐藏的字符也可以查看</span><br></pre></td></tr></table></figure>

<p>7.复制</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp -r 源文件 目标文件 #可以复制目录的所有文件</span><br></pre></td></tr></table></figure>

<p>8.移动或重命名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv [选项] 源文件 目标文件</span><br><span class="line">mv old.txt new.txt #重命名单个文件</span><br><span class="line">mv old_folder new_folder #重命名目录</span><br><span class="line">mv file.txt /home/user/documents/newfile.txt #移动文件到其他目录并重命名</span><br></pre></td></tr></table></figure>

<p>9.查看当前路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></table></figure>

<p>10.查看当前目录文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls [option]</span><br><span class="line">ls -a #查看所有文件，包括隐藏的</span><br></pre></td></tr></table></figure>

<ol start="11">
<li>显示磁盘空间使用情况</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">df -h</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="项目常用命令"><a href="#项目常用命令" class="headerlink" title="项目常用命令"></a>项目常用命令</h2><ul>
<li>解压缩</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf xx.tar.gz # 解压缩tar.gz文件，x为提取，v为详细信息，f即file</span><br></pre></td></tr></table></figure>

<ul>
<li>查看进程</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps au #查看所有进程</span><br><span class="line">ps aux|grep xx*</span><br></pre></td></tr></table></figure>

<ul>
<li>查找文件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">基本语法：find 搜索路径 选项 表达式</span></span><br><span class="line">find /path/to/search -name &quot;filename&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在当前目录及子目录查找名为<span class="string">&quot;example.txt&quot;</span>的文件</span></span><br><span class="line">find . -name &quot;example.txt&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用通配符查找所有.<span class="built_in">log</span>文件</span></span><br><span class="line">find /var/log -name &quot;*.log&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找指定用户拥有的文件</span></span><br><span class="line">find /home -user username</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找过去7天内修改的文件</span></span><br><span class="line">find /home/user -mtime -7</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用 find 命令查找最近修改的文件</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果你刚刚安装了软件，可以查找系统中最近被修改的文件：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找过去30分钟内修改的文件</span></span><br><span class="line">sudo find / -type f -mmin -30 2&gt;/dev/null</span><br></pre></td></tr></table></figure>

<p>查找文件还可以使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">whereis xx</span><br></pre></td></tr></table></figure>

<ul>
<li>安装软件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i 文件名.deb #安装的默认路径为：/opt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看 dpkg 日志找出最近安装的包</span></span><br><span class="line">grep &quot;install &quot; /var/log/dpkg.log | tail</span><br></pre></td></tr></table></figure>

<ul>
<li>挂载共享文件夹</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mount -t fuse.vmhgfs-fuse .host:/ /mnt/hgfs -o allow_other</span><br></pre></td></tr></table></figure>

<p>开机自动挂载共享文件夹参考下图：</p>
<img src="/2025/02/23/linux_bashCmd01/image-20250302110137834.png" class="" title="image-20250302110137834">

<ul>
<li>安装和卸载</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install </span><br><span class="line">apt-get autoremove </span><br></pre></td></tr></table></figure>

<ul>
<li>编译和链接</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">编译c源码,以创建线程为例</span></span><br><span class="line">gcc thread1.c -o trl -lphread</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>gcc</code>: GNU编译器集合(GNU Compiler Collection)，这是一个常用的C&#x2F;C++编译器</p>
<p><code>thread1.c</code>: 源代码文件名，这是要被编译的C语言源文件</p>
<p><code>-o tr1</code>: 输出选项，指定编译后生成的可执行文件名为”tr1”</p>
<p><code>-lpthread</code>: 链接选项，告诉编译器链接POSIX线程库(pthread库)</p>
<p><strong>为什么要链接</strong>：</p>
<ul>
<li>当编译器看到你的代码引用了 pthread 库中的函数时，它需要知道这些函数的实现在哪里</li>
<li><code>-lpthread</code> 告诉链接器去寻找并链接 pthread 库</li>
<li>如果不链接这个库，链接器会报”未定义的引用”(undefined reference)错误</li>
</ul>
<p><strong>具体作用</strong></p>
<ul>
<li><code>-l</code> 是链接库的标志</li>
<li><code>pthread</code> 是库的名称（省略了前缀”lib”和后缀”.so”或”.a”）</li>
<li>实际上链接器会寻找 <code>libpthread.so</code>（共享库）或 <code>libpthread.a</code>（静态库）文件</li>
</ul>
</blockquote>
<ul>
<li><p>软链接</p>
<p>作用1：允许从不同位置访问同一个文件或目录，而不需要复制数据，相当于创建快捷方式</p>
<p>作用2：，比如先转移文件到其它目录，再删除原路径的文件，这时创建一个软链接，确保依赖于旧路径的程序继续正常工作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果已有Downloads目录且有内容，先移动</span></span><br><span class="line">mv ~/Downloads/* /data/Downloads/ # 仅当Downloads有内容时</span><br><span class="line">rm -rf ~/Downloads # 删除原Downloads目录</span><br><span class="line">ln -s /data/Downloads ~/Downloads # 创建软链接</span><br></pre></td></tr></table></figure>

</li>
<li><p>网络相关</p>
<ul>
<li>查看网络的配置和状态</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure>

<ul>
<li>查看 socket、网络协议栈、网口以及路由表的信息</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-n表示以数字方式显示ip和端口</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-l表示只显示listen状态的socket</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-p表示显示进程信息</span></span><br><span class="line">netstat -nlp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#######################################</span></span></span><br><span class="line">ss -ntlp</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-n表示以数字方式显示ip和端口</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-t表示只显示tcp连接</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-l表示只显示listen状态的socket</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-p表示显示进程信息</span></span><br></pre></td></tr></table></figure>

<ul>
<li>查看协议栈的统计信息</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -s</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##或者</span></span></span><br><span class="line">ss -s</span><br></pre></td></tr></table></figure>

<ul>
<li><p>查看网络吞吐率和pps</p>
<blockquote>
<p><strong>网络吞吐率</strong>：单位事件内成功传输的数据量</p>
<p><strong>pps</strong>：packet per second</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sar -n DEV  #显示网口的统计数据</span><br><span class="line">sar -n EDEV	#显示关于网络错误的统计数据</span><br><span class="line">sar -n TCP	#显示 TCP 的统计数据</span><br><span class="line">ethtool eth0 | grep Speed	#查看eth0网卡带宽，单位为Mb/s</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
</li>
</ul>
<p>​	</p>
]]></content>
      <categories>
        <category>linux</category>
        <category>bash命令</category>
      </categories>
  </entry>
  <entry>
    <title>linux之多进程编程</title>
    <url>/2025/04/21/linux_LearningNote01_IPC/</url>
    <content><![CDATA[<h2 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h2><h3 id="什么是僵尸进程"><a href="#什么是僵尸进程" class="headerlink" title="什么是僵尸进程"></a>什么是僵尸进程</h3><p>对于多进程程序，父进程需要跟踪子进程的退出状态。当子进程结束运行时，内核不会立即释放该进程的进程表项，以便父进程可以查询子进程的退出信息。<strong>在子进程结束后但父进程尚未读取其退出状态前，这个子进程被称为”僵尸态”。</strong></p>
<p>另一种情况是：如果<strong>父进程先结束或异常终止，而子进程继续运行</strong>，子进程的PPID会被设置为1（init进程）。<strong>init进程会接管这个子进程并等待它结束。</strong>这种情况下，子进程在退出前也会处于僵尸态。如果父进程没有正确处理子进程的返回信息，子进程将一直停留在僵尸态，占用内核资源。</p>
<blockquote>
<p>僵尸进程的特点：</p>
<ol>
<li>已经释放了几乎所有资源，但在进程表中仍然有一个条目</li>
<li>在 <code>ps</code> 命令中显示为 “Z” 或 “defunct” 状态</li>
<li>占用极少的系统资源，但会占用一个进程ID(PID)</li>
<li>如果大量存在，可能导致系统无法创建新进程</li>
</ol>
</blockquote>
<span id="more"></span>

<h3 id="僵尸进程的危害"><a href="#僵尸进程的危害" class="headerlink" title="僵尸进程的危害"></a>僵尸进程的危害</h3><p>虽然单个僵尸进程几乎不会对系统造成负担，但如果大量僵尸进程累积，将会：</p>
<ol>
<li>耗尽进程表空间，导致系统无法创建新进程</li>
<li>占用PID资源，影响系统稳定性</li>
<li>表明程序可能存在资源管理问题</li>
</ol>
<h3 id="消除僵尸进程的方法"><a href="#消除僵尸进程的方法" class="headerlink" title="消除僵尸进程的方法"></a>消除僵尸进程的方法</h3><ul>
<li>使用 wait() 或 waitpid() 函数 （wait有一个缺点就是如果没有已终止的子进程，那么程序将阻塞直到有子进程终止）</li>
</ul>
<p><strong>代码示例如下：</strong></p>
<h4 id="waitpid-SIGCHLD信号"><a href="#waitpid-SIGCHLD信号" class="headerlink" title="waitpid + SIGCHLD信号  "></a><code>waitpid + SIGCHLD信号  </code></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子进程结束时的信号处理函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sigchld_handler</span><span class="params">(<span class="type">int</span> sig)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 声明一个变量来存储子进程的状态</span></span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">pid_t</span> child_pid;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用 waitpid 并设置 WNOHANG 选项，这样即使没有子进程退出也不会阻塞</span></span><br><span class="line">    <span class="comment">// -1 表示等待任何子进程</span></span><br><span class="line">    <span class="comment">// 循环处理所有已经结束的子进程</span></span><br><span class="line">    <span class="keyword">while</span> ((child_pid = <span class="built_in">waitpid</span>(<span class="number">-1</span>, &amp;status, WNOHANG)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">WIFEXITED</span>(status)) &#123;</span><br><span class="line">            <span class="comment">// 如果子进程正常退出，打印其退出码</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;子进程(&quot;</span> &lt;&lt; child_pid &lt;&lt; <span class="string">&quot;)正常退出，退出码: &quot;</span> </span><br><span class="line">                      &lt;&lt; <span class="built_in">WEXITSTATUS</span>(status) &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">WIFSIGNALED</span>(status)) &#123;</span><br><span class="line">            <span class="comment">// 如果子进程被信号终止，打印终止它的信号编号</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;子进程(&quot;</span> &lt;&lt; child_pid &lt;&lt; <span class="string">&quot;)被信号&quot;</span> </span><br><span class="line">                      &lt;&lt; <span class="built_in">WTERMSIG</span>(status) &lt;&lt; <span class="string">&quot;终止&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置 SIGCHLD 信号的处理函数</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigaction</span> sa;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;sa, <span class="number">0</span>, <span class="built_in">sizeof</span>(sa));  <span class="comment">// 清零 sa 结构体</span></span><br><span class="line">    sa.sa_handler = sigchld_handler;  <span class="comment">// 设置信号处理函数</span></span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;sa.sa_mask);  <span class="comment">// 清空信号掩码</span></span><br><span class="line">    sa.sa_flags = SA_RESTART;  <span class="comment">// 设置 SA_RESTART 标志，使被中断的系统调用自动重启</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册信号处理函数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sigaction</span>(SIGCHLD, &amp;sa, <span class="literal">NULL</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;注册信号处理函数失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建5个子进程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="type">pid_t</span> pid = fork();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// fork 失败</span></span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;创建子进程失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 子进程代码</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;子进程&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;开始执行，PID: &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">sleep</span>(i + <span class="number">1</span>);  <span class="comment">// 每个子进程睡眠不同的时间</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;子进程&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;结束执行&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> i * <span class="number">10</span>;  <span class="comment">// 每个子进程返回不同的退出码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 父进程继续执行自己的工作</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;父进程继续执行其他任务，所有子进程将在后台运行&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 父进程工作循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;父进程工作中...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;父进程工作完成&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="“双重-fork”技术"><a href="#“双重-fork”技术" class="headerlink" title="“双重 fork”技术"></a>“双重 fork”技术</h4><p><a href="https://www.cnblogs.com/tangr206/articles/3158685.html">fork两次 避免僵尸进程 - tangr206 - 博客园</a></p>
<p>另一种避免僵尸进程的方法是使用”双重 fork”技术，让孙子进程成为孤儿进程，由 init 进程(PID 1)接管：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();  <span class="comment">// 第一次 fork</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// fork 失败</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;第一次 fork 失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 第一个子进程</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建会话组，使子进程独立</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">setsid</span>() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;setsid 失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">pid_t</span> pid2 = fork();  <span class="comment">// 第二次 fork</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (pid2 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 第二次 fork 失败</span></span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;第二次 fork 失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid2 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 第一个子进程立即退出，使得第二个子进程变成孤儿进程</span></span><br><span class="line">            <span class="comment">// 被 init 进程接管，从而避免成为僵尸进程。init进程会负责回收其子进程的僵尸状态</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;第一个子进程退出，PID: &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 第二个子进程（孙子进程）</span></span><br><span class="line">            <span class="comment">// 这个进程将由 init 进程接管</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;第二个子进程开始执行，PID: &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">5</span>);  <span class="comment">// 模拟一些工作</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;第二个子进程工作完成&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 原始父进程</span></span><br><span class="line">        <span class="comment">// 等待第一个子进程结束，防止它变成僵尸进程</span></span><br><span class="line">        <span class="type">int</span> status;</span><br><span class="line">        <span class="built_in">waitpid</span>(pid, &amp;status, <span class="number">0</span>);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;父进程: 第一个子进程已退出&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 此时第二个子进程（孙子进程）已经成为孤儿进程</span></span><br><span class="line">        <span class="comment">// 由 init 进程接管，不会成为僵尸进程</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;父进程继续执行其他任务...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">10</span>);  <span class="comment">// 继续一些工作</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="忽略-SIGCHLD-信号"><a href="#忽略-SIGCHLD-信号" class="headerlink" title="忽略 SIGCHLD 信号"></a>忽略 SIGCHLD 信号</h4><p>最简单但功能有限的方法是让父进程忽略 SIGCHLD 信号：</p>
<blockquote>
<p>当一个进程设置 <code>signal(SIGCHLD, SIG_IGN)</code> 或使用 <code>sigaction()</code> 将 SIGCHLD 信号处理设为 SIG_IGN 时，Linux 内核会采取特殊行为：当子进程终止时，内核将立即清理（reap）子进程资源，而不是将其保留为僵尸进程。</p>
<p>这种行为背后的原理是：</p>
<ol>
<li><strong>自动回收机制</strong>：当父进程明确表示不关心子进程的退出状态（通过忽略 SIGCHLD 信号），内核将此视为一种暗示 - 父进程不打算调用 wait() 或 waitpid() 函数来获取子进程的退出状态。</li>
<li><strong>内核优化</strong>：为了节省资源，内核实现了一种优化 - 既然父进程明确表示不关心子进程的退出状态，那么保留僵尸进程就没有意义，内核会自动回收子进程的所有资源，包括进程表项。</li>
<li><strong>标准保证</strong>：POSIX.1-2001 标准明确规定了这种行为：”如果 SIGCHLD 的处置被设置为 SIG_IGN，子进程的状态信息不会变成可用的”。这是因为子进程被自动回收了。</li>
</ol>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置父进程忽略 SIGCHLD 信号</span></span><br><span class="line">    <span class="comment">// 这将导致子进程在终止时自动被系统回收，不会成为僵尸进程</span></span><br><span class="line">    <span class="built_in">signal</span>(SIGCHLD, SIG_IGN);</span><br><span class="line">    </span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// fork 失败</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;创建子进程失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程代码</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;子进程开始执行，PID: &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;子进程结束执行&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 父进程代码</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;父进程创建了子进程(&quot;</span> &lt;&lt; pid &lt;&lt; <span class="string">&quot;)，继续执行自己的任务&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 父进程不等待子进程，继续工作</span></span><br><span class="line">        <span class="comment">// 由于已经忽略了 SIGCHLD 信号，子进程结束后不会成为僵尸进程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;父进程工作中...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;父进程工作完成&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<blockquote>
<p>总结：</p>
<p><strong>在实际开发中，推荐的处理僵尸进程的方法是：</strong></p>
<ol>
<li>对于<strong>简单应用，使用信号处理函数</strong>（示例1）是最常见的方法</li>
<li><strong>对于需要获取子进程退出状态的应用，应使用 <code>waitpid()</code> 函数</strong></li>
<li>对于<strong>守护进程，可以使用双重 fork 方法</strong>（示例2）</li>
<li>如果<strong>不关心子进程的退出状态，可以简单地忽略 SIGCHLD 信号</strong>（示例3）</li>
</ol>
</blockquote>
<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p>由于进程的内存空间都是独立的，一般而言是不能互相访问的，<strong>但内核空间是每个进程都共享的</strong>，所以进程间通信必须要内核</p>
<style>.rsqzwibkbhqj{zoom:50%;}</style><img src="/2025/04/21/linux_LearningNote01_IPC/image-20250422183736258.png" class="rsqzwibkbhqj" alt="image-20250422183736258">

<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><h4 id="匿名管道"><a href="#匿名管道" class="headerlink" title="匿名管道"></a>匿名管道</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps auxf | grep mysql</span><br></pre></td></tr></table></figure>

<p>上面命令行里的「<code>|</code>」竖线就是一个<strong>管道</strong>，它的功能是将前一个命令（<code>ps auxf</code>）的输出，作为后一个命令（<code>grep mysql</code>）的输入，从这功能描述，可以看出<strong>管道传输数据是单向的</strong>，如果想相互通信，我们需要创建两个管道才行。</p>
<p><strong>匿名管道是父子进程之间通信的常用手段。</strong></p>
<blockquote>
<p>一般实现父子进程的通信都是采用两个管道，虽然在fork后父子进程都会拥有管道IO文件描述符，可以使用一个管道实现两个进程之间的双向通信，但是会出现问题，即如果没有<code>sleep</code>来协调将会导致进程读取自己传输的数据的情况。</p>
</blockquote>
<p>两个管道实现父子进程通信模型如下：</p>
<img src="/2025/04/21/linux_LearningNote01_IPC/image-20250422212114841.png" class="" title="image-20250422212114841">

<p> 代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> fds1[<span class="number">2</span>], fds2[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">pipe</span>(fds1), <span class="built_in">pipe</span>(fds2);</span><br><span class="line">pid=fork();</span><br><span class="line"><span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">write</span>(fds1[<span class="number">1</span>], str1, <span class="built_in">sizeof</span>(str1));</span><br><span class="line">    <span class="built_in">read</span>(fds2[<span class="number">0</span>], buf, BUF_SIZE);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Child proc output: %s \n&quot;</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">read</span>(fds1[<span class="number">0</span>], buf, BUF_SIZE);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent proc output: %s \n&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">write</span>(fds2[<span class="number">1</span>], str2, <span class="built_in">sizeof</span>(str2));</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="有名管道"><a href="#有名管道" class="headerlink" title="有名管道"></a>有名管道</h4><p>管道还有另外一个类型是<strong>命名管道</strong>，也被叫做 <code>FIFO</code>，因为数据是先进先出的传输方式。</p>
<p>在使用命名管道前，先需要通过 <code>mkfifo</code> 命令来创建，并且指定管道名字：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkfifo</span> myPipe</span><br></pre></td></tr></table></figure>

<p>myPipe 就是这个管道的名称，基于 Linux 一切皆文件的理念，所以管道也是以文件的方式存在。</p>
<p>有名管道使用示例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span> &gt; myPipe  // 将数据写进管道</span><br><span class="line">                         // 停住了 ...</span><br></pre></td></tr></table></figure>

<p>将数据输入到管道之后，如果其中数据没有被读完就不会退出</p>
<p>读数据的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> &lt; myPipe  // 读取管道里的数据</span><br><span class="line">hello</span><br></pre></td></tr></table></figure>

<p>我们可以看出，<strong>管道这种通信方式效率低，不适合进程间频繁地交换数据</strong>。当然，它的好处，自然就是简单，同时也我们很容易得知管道里的数据已经被另一个进程读取了。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li><p><strong>管道，其实就是内核里面的一串缓存</strong>。从管道的一段写入的数据，实际上是缓存在内核中的，另一端读取，也就是从内核中读取这段数据。</p>
</li>
<li><p>另外，<strong>管道传输的数据是无格式的流且大小受限</strong>。</p>
</li>
<li><p>在 shell 里面执行 <code>A | B</code>命令的时候，A 进程和 B 进程都是 shell 创建出来的子进程，A 和 B 之间不存在父子关系，它俩的父进程都是 shell。</p>
<style>.ysuhifwwfvta{zoom: 25%;}</style><img src="/2025/04/21/linux_LearningNote01_IPC/image-20250422213247731.png" class="ysuhifwwfvta" alt="image-20250422213247731"></li>
</ul>
<p>​		因此，在bash终端输入的<code>|</code>匿名管道将多个命令连		接在一起，实际上也创建了多个子进程。所以为了		减少创建子进程的开销，尽量不要用多个<code>|</code>来连接		多个命令</p>
<ul>
<li><strong>对于匿名管道，它的通信范围是存在父子关系的进程</strong>。因为管道没有实体，也就是没有管道文件，只能通过 fork 来复制父进程 fd 文件描述符，来达到通信的目的。</li>
<li>匿名管道的生命周期，是随进程的创建而建立，随进程的结束而销毁。</li>
<li><strong>对于命名管道，它可以在不相关的进程间也能相互通信</strong>。因为命令管道，提前创建了一个类型为管道的设备文件，在进程里只要使用这个设备文件，就可以相互通信。</li>
</ul>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>优点：</p>
<ul>
<li>相比管道通信效率更高，<strong>一个进程将数据放入消息队列后就可以返回，另外一个进程需要的时候去取就行了</strong>（<font color='cornflowerblue'>异步通信</font>）</li>
<li>消息队列是保存在内核中的<strong>消息链表</strong>，进程之间传输的数据为消息体(数据块，用户自定义)，<strong>每个消息体都是固定大小的存储块</strong>。如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。</li>
<li>消息队列生命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会一直存在</li>
</ul>
<p>缺点：</p>
<ul>
<li><strong>消息队列不适合比较大数据的传输</strong>。，因为在内核中每个消息体都有一个最大长度的限制，同时所有队列所包含的全部消息体的总长度也是有上限。在 Linux 内核中，会有两个宏定义 <code>MSGMAX</code> 和 <code>MSGMNB</code>，它们以字节为单位，分别定义了一条消息的最大长度和一个队列的最大长度。</li>
<li><strong>消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销</strong>。一个进程写入数据时，存在用户态-内核态的转换，另外一个进程读数据时，存在内核态-用户态的转换。</li>
</ul>
<p>在C++中，可<strong>以使用POSIX消息队列或System V消息队列来实现</strong>:</p>
<p>发送进程 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>       <span class="comment">// 提供 O_* 常量定义</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span>    <span class="comment">// 提供 mode 常量定义</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mqueue.h&gt;</span>      <span class="comment">// 消息队列API</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>      <span class="comment">// sleep函数</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义消息队列名称（必须以&#x27;/&#x27;开头）</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* queue_name = <span class="string">&quot;/my_message_queue&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义消息队列属性</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">mq_attr</span> attr;</span><br><span class="line">    attr.mq_flags = <span class="number">0</span>;                <span class="comment">// 非阻塞标志</span></span><br><span class="line">    attr.mq_maxmsg = <span class="number">10</span>;              <span class="comment">// 队列中最大消息数量</span></span><br><span class="line">    attr.mq_msgsize = <span class="number">1024</span>;           <span class="comment">// 每条消息最大字节数</span></span><br><span class="line">    attr.mq_curmsgs = <span class="number">0</span>;              <span class="comment">// 当前队列中的消息数量</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打开/创建消息队列</span></span><br><span class="line">    <span class="comment">// O_CREAT: 如果队列不存在则创建</span></span><br><span class="line">    <span class="comment">// O_WRONLY: 以只写模式打开</span></span><br><span class="line">    <span class="comment">// 0644: 权限设置 (rw-r--r--)</span></span><br><span class="line">    <span class="type">mqd_t</span> mq = <span class="built_in">mq_open</span>(queue_name, O_CREAT | O_WRONLY, <span class="number">0644</span>, &amp;attr);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (mq == (<span class="type">mqd_t</span>)<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;mq_open失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;发送进程启动，PID: &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 发送5条消息</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 准备消息内容</span></span><br><span class="line">        std::string message = <span class="string">&quot;来自发送进程的消息 #&quot;</span> + std::<span class="built_in">to_string</span>(i);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        <span class="comment">// 参数: 消息队列描述符, 消息内容, 消息长度, 消息优先级</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">mq_send</span>(mq, message.<span class="built_in">c_str</span>(), message.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;mq_send失败&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;已发送: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 等待1秒再发送下一条</span></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关闭消息队列</span></span><br><span class="line">    <span class="built_in">mq_close</span>(mq);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;发送进程完成，退出&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接收进程</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>       <span class="comment">// 提供 O_* 常量定义</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span>    <span class="comment">// 提供 mode 常量定义</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mqueue.h&gt;</span>      <span class="comment">// 消息队列API</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>      <span class="comment">// sleep函数</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义消息队列名称（必须与发送进程一致）</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* queue_name = <span class="string">&quot;/my_message_queue&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打开已存在的消息队列</span></span><br><span class="line">    <span class="comment">// O_RDONLY: 以只读模式打开</span></span><br><span class="line">    <span class="type">mqd_t</span> mq = <span class="built_in">mq_open</span>(queue_name, O_RDONLY);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (mq == (<span class="type">mqd_t</span>)<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;mq_open失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取消息队列属性</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">mq_attr</span> attr;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mq_getattr</span>(mq, &amp;attr) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;mq_getattr失败&quot;</span>);</span><br><span class="line">        <span class="built_in">mq_close</span>(mq);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;接收进程启动，PID: &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;队列最大消息数: &quot;</span> &lt;&lt; attr.mq_maxmsg &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;消息最大长度: &quot;</span> &lt;&lt; attr.mq_msgsize &lt;&lt; <span class="string">&quot;字节&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分配足够大的缓冲区来存储消息</span></span><br><span class="line">    <span class="type">char</span>* buffer = <span class="keyword">new</span> <span class="type">char</span>[attr.mq_msgsize];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 接收和处理消息</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> priority;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 阻塞直到收到消息</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;等待消息...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 接收消息</span></span><br><span class="line">        <span class="comment">// 参数: 消息队列描述符, 接收缓冲区, 缓冲区大小, 优先级指针</span></span><br><span class="line">        <span class="type">ssize_t</span> bytes_read = <span class="built_in">mq_receive</span>(mq, buffer, attr.mq_msgsize, &amp;priority);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (bytes_read == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;mq_receive失败&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;收到消息: &quot;</span> &lt;&lt; buffer &lt;&lt; <span class="string">&quot; (长度: &quot;</span> &lt;&lt; bytes_read </span><br><span class="line">                      &lt;&lt; <span class="string">&quot; 字节, 优先级: &quot;</span> &lt;&lt; priority &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">delete</span>[] buffer;</span><br><span class="line">    <span class="built_in">mq_close</span>(mq);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除消息队列</span></span><br><span class="line">    <span class="built_in">mq_unlink</span>(queue_name);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;接收进程完成，退出&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>bash终端输入以下命令既可以运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 编译两个程序</span><br><span class="line">g++ -o sender message_sender.cpp -lrt</span><br><span class="line">g++ -o receiver message_receiver.cpp -lrt</span><br><span class="line"></span><br><span class="line"># 在两个不同的终端窗口运行程序</span><br><span class="line"># 终端1:</span><br><span class="line">./receiver</span><br><span class="line"></span><br><span class="line"># 终端2:</span><br><span class="line">./sender</span><br></pre></td></tr></table></figure>



<p>总结消息队列优缺点：</p>
<blockquote>
<p>消息队列的优点</p>
<ol>
<li><strong>结构化数据传输</strong>：可以传输具有明确类型和优先级的消息</li>
<li><strong>异步通信</strong>：发送和接收可以在不同时间进行，不需要双方同时在线</li>
<li><strong>内置同步机制</strong>：无需额外的同步原语</li>
<li><strong>多对多通信</strong>：支持多个生产者和消费者</li>
<li><strong>容量控制</strong>：可以设置队列大小，防止生产者过快导致内存耗尽</li>
</ol>
<p>消息队列的缺点</p>
<ol>
<li><strong>通信开销</strong>：比共享内存有更多的数据复制操作</li>
<li><strong>容量限制</strong>：消息大小和队列长度通常有系统限制</li>
<li><strong>管理复杂</strong>：需要处理队列满&#x2F;空的情况</li>
<li><strong>持久性问题</strong>：进程崩溃可能导致消息丢失</li>
</ol>
</blockquote>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>在内存管理中，每个进程都有自己的虚拟内存空间，即使虚拟内存地址相同也不影响，因为他们可以对应不同的物理内存地址。</p>
<p>而共享内存就是将进程的虚拟内存拿出一块并映射到相同的物理内存空间。当一个进程将数据传入时，另外一个进程也能“知道”，<strong>避免了相互拷贝带来的开销，大大提高进程间通信的速度</strong></p>
<style>.izilshbozhjc{zoom:33%;}</style><img src="/2025/04/21/linux_LearningNote01_IPC/image-20250422215548453.png" class="izilshbozhjc" alt="image-20250422215548453">

<blockquote>
<p><strong>需要用到的一个重要系统函数<code>mmap</code>介绍</strong></p>
<p>mmap是Linux和其他类Unix系统中的一个重要系统调用，<strong>全称为”memory map”（内存映射）</strong>。它的主要作用是<strong>将文件或设备的内容映射到进程的地址空间</strong>，使得进程可以像访问内存一样访问这些文件或设备的内容。</p>
<p>mmap的基本功能</p>
<ol>
<li><strong>文件映射到内存</strong>：将磁盘文件的内容映射到进程的虚拟地址空间</li>
<li><strong>共享内存</strong>：创建多个进程之间共享的内存区域</li>
<li><strong>内存分配</strong>：分配匿名内存空间（不关联任何文件）</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>addr</code>：建议的映射起始地址，通常设为NULL让系统自动选择</li>
<li><code>length</code>：要映射的字节数</li>
<li><code>prot</code>：内存保护标志（读&#x2F;写&#x2F;执行权限）</li>
<li><code>flags</code>：映射类型标志</li>
<li><code>fd</code>：要映射的文件描述符</li>
<li><code>offset</code>：文件中的偏移量（通常是页大小的倍数）</li>
</ul>
</blockquote>
<h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><ul>
<li>共享数据结构定义 (shared_data.h)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SHARED_DATA_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHARED_DATA_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 共享内存中的数据结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SharedData</span> &#123;</span><br><span class="line">    <span class="type">int</span> status;         <span class="comment">// 状态标志：0=未准备好，1=数据已写入，2=数据已读取</span></span><br><span class="line">    <span class="type">int</span> counter;        <span class="comment">// 计数器，用于验证数据传输</span></span><br><span class="line">    <span class="type">char</span> message[<span class="number">256</span>];  <span class="comment">// 消息内容</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 共享内存和信号量的名称</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHM_NAME <span class="string">&quot;/my_shared_memory&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEM_WRITER_NAME <span class="string">&quot;/sem_writer&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEM_READER_NAME <span class="string">&quot;/sem_reader&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 共享内存大小</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHM_SIZE sizeof(SharedData)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// SHARED_DATA_H</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>写入进程</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span>    <span class="comment">// 内存映射函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span>    <span class="comment">// 文件状态常量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>       <span class="comment">// 文件控制常量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span>   <span class="comment">// 信号量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>      <span class="comment">// POSIX API</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;shared_data.h&quot;</span> <span class="comment">// 共享数据结构定义</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建/打开共享内存对象</span></span><br><span class="line">    <span class="type">int</span> shm_fd = <span class="built_in">shm_open</span>(SHM_NAME, O_CREAT | O_RDWR, <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span> (shm_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;shm_open失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置共享内存大小</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ftruncate</span>(shm_fd, SHM_SIZE) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;ftruncate失败&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(shm_fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建/打开写入者信号量（初始值为1，表示可以写入）</span></span><br><span class="line">    <span class="type">sem_t</span>* sem_writer = <span class="built_in">sem_open</span>(SEM_WRITER_NAME, O_CREAT, <span class="number">0644</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (sem_writer == SEM_FAILED) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;sem_open(writer)失败&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(shm_fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建/打开读取者信号量（初始值为0，表示尚未有数据可读）</span></span><br><span class="line">    <span class="type">sem_t</span>* sem_reader = <span class="built_in">sem_open</span>(SEM_READER_NAME, O_CREAT, <span class="number">0644</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sem_reader == SEM_FAILED) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;sem_open(reader)失败&quot;</span>);</span><br><span class="line">        <span class="built_in">sem_close</span>(sem_writer);</span><br><span class="line">        <span class="built_in">close</span>(shm_fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将共享内存对象映射到进程地址空间</span></span><br><span class="line">    SharedData* shared_data = (SharedData*)<span class="built_in">mmap</span>(<span class="literal">NULL</span>, SHM_SIZE, </span><br><span class="line">                                             PROT_READ | PROT_WRITE, </span><br><span class="line">                                             MAP_SHARED, shm_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (shared_data == MAP_FAILED) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;mmap失败&quot;</span>);</span><br><span class="line">        <span class="built_in">sem_close</span>(sem_reader);</span><br><span class="line">        <span class="built_in">sem_close</span>(sem_writer);</span><br><span class="line">        <span class="built_in">close</span>(shm_fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;写入进程启动，PID: &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 写入数据到共享内存</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 等待写入权限（获取写入信号量）</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;等待写入权限...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sem_wait</span>(sem_writer) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;sem_wait(writer)失败&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 准备写入的数据</span></span><br><span class="line">        std::string message = <span class="string">&quot;来自写入进程的消息 #&quot;</span> + std::<span class="built_in">to_string</span>(i);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 写入数据到共享内存</span></span><br><span class="line">        shared_data-&gt;status = <span class="number">1</span>;  <span class="comment">// 标记为已写入</span></span><br><span class="line">        shared_data-&gt;counter = i;</span><br><span class="line">        <span class="built_in">strcpy</span>(shared_data-&gt;message, message.<span class="built_in">c_str</span>());</span><br><span class="line">        </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;已写入: &quot;</span> &lt;&lt; message &lt;&lt; <span class="string">&quot; (计数: &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通知读取者有新数据可读（释放读取信号量）</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sem_post</span>(sem_reader) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;sem_post(reader)失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 每次写入之间等待1秒</span></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 等待最后一次读取完成（获取写入信号量）</span></span><br><span class="line">    <span class="built_in">sem_wait</span>(sem_writer);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 标记为完成</span></span><br><span class="line">    shared_data-&gt;status = <span class="number">-1</span>;  <span class="comment">// 特殊值表示结束</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通知读取者进程结束（释放读取信号量）</span></span><br><span class="line">    <span class="built_in">sem_post</span>(sem_reader);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清理资源</span></span><br><span class="line">    <span class="built_in">munmap</span>(shared_data, SHM_SIZE);</span><br><span class="line">    <span class="built_in">close</span>(shm_fd);</span><br><span class="line">    <span class="built_in">sem_close</span>(sem_writer);</span><br><span class="line">    <span class="built_in">sem_close</span>(sem_reader);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;写入进程完成，退出&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>读取进程</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span>    <span class="comment">// 内存映射函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span>    <span class="comment">// 文件状态常量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>       <span class="comment">// 文件控制常量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span>   <span class="comment">// 信号量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>      <span class="comment">// POSIX API</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;shared_data.h&quot;</span> <span class="comment">// 共享数据结构定义</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打开共享内存对象</span></span><br><span class="line">    <span class="type">int</span> shm_fd = <span class="built_in">shm_open</span>(SHM_NAME, O_RDWR, <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span> (shm_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;shm_open失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打开写入者信号量</span></span><br><span class="line">    <span class="type">sem_t</span>* sem_writer = <span class="built_in">sem_open</span>(SEM_WRITER_NAME, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sem_writer == SEM_FAILED) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;sem_open(writer)失败&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(shm_fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打开读取者信号量</span></span><br><span class="line">    <span class="type">sem_t</span>* sem_reader = <span class="built_in">sem_open</span>(SEM_READER_NAME, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sem_reader == SEM_FAILED) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;sem_open(reader)失败&quot;</span>);</span><br><span class="line">        <span class="built_in">sem_close</span>(sem_writer);</span><br><span class="line">        <span class="built_in">close</span>(shm_fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将共享内存对象映射到进程地址空间</span></span><br><span class="line">    SharedData* shared_data = (SharedData*)<span class="built_in">mmap</span>(<span class="literal">NULL</span>, SHM_SIZE, </span><br><span class="line">                                             PROT_READ | PROT_WRITE, </span><br><span class="line">                                             MAP_SHARED, shm_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (shared_data == MAP_FAILED) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;mmap失败&quot;</span>);</span><br><span class="line">        <span class="built_in">sem_close</span>(sem_reader);</span><br><span class="line">        <span class="built_in">sem_close</span>(sem_writer);</span><br><span class="line">        <span class="built_in">close</span>(shm_fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;读取进程启动，PID: &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从共享内存读取数据</span></span><br><span class="line">    <span class="type">bool</span> running = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (running) &#123;</span><br><span class="line">        <span class="comment">// 等待有数据可读（获取读取信号量）</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;等待数据...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sem_wait</span>(sem_reader) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;sem_wait(reader)失败&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查状态</span></span><br><span class="line">        <span class="keyword">if</span> (shared_data-&gt;status == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="comment">// 写入进程已经结束</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;写入进程已结束通信&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            running = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shared_data-&gt;status == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 读取数据</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;读取到: &quot;</span> &lt;&lt; shared_data-&gt;message </span><br><span class="line">                      &lt;&lt; <span class="string">&quot; (计数: &quot;</span> &lt;&lt; shared_data-&gt;counter &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 标记为已读取</span></span><br><span class="line">            shared_data-&gt;status = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 释放写入者信号量，允许下一次写入</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sem_post</span>(sem_writer) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;sem_post(writer)失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清理资源</span></span><br><span class="line">    <span class="built_in">munmap</span>(shared_data, SHM_SIZE);</span><br><span class="line">    <span class="built_in">close</span>(shm_fd);</span><br><span class="line">    <span class="built_in">sem_close</span>(sem_writer);</span><br><span class="line">    <span class="built_in">sem_close</span>(sem_reader);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除共享内存和信号量</span></span><br><span class="line">    <span class="built_in">shm_unlink</span>(SHM_NAME);</span><br><span class="line">    <span class="built_in">sem_unlink</span>(SEM_WRITER_NAME);</span><br><span class="line">    <span class="built_in">sem_unlink</span>(SEM_READER_NAME);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;读取进程完成，退出&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>过程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">物理内存中的共享区域</span><br><span class="line">                       /dev/shm/my_shared_memory</span><br><span class="line">                      +----------------------+</span><br><span class="line">                      |  message: &quot;Hello&quot;    |</span><br><span class="line">                      |  counter: 42         |</span><br><span class="line">                      |  ready: true         |</span><br><span class="line">                      +----------------------+</span><br><span class="line">                             ↑      ↑</span><br><span class="line">                             |      |</span><br><span class="line">                    映射     |      |     映射</span><br><span class="line">                             |      |</span><br><span class="line">                             ↓      ↓</span><br><span class="line">  +----------------+    +----------+    +----------------+</span><br><span class="line">  |   进程 A       |    | 共享内存  |    |   进程 B       |</span><br><span class="line">  |                |    | 对象     |    |                |</span><br><span class="line">  | shared_data---&gt;|----| shm_fd   |----|---&gt;shared_data |</span><br><span class="line">  | (虚拟地址)     |    |          |    | (虚拟地址)     |</span><br><span class="line">  +----------------+    +----------+    +----------------+</span><br><span class="line">      写操作                               读操作</span><br></pre></td></tr></table></figure>

<p>bash终端输入以命令即可运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 编译三个文件</span><br><span class="line">g++ -o writer memory_writer.cpp -lrt -pthread</span><br><span class="line">g++ -o reader memory_reader.cpp -lrt -pthread</span><br><span class="line"></span><br><span class="line"># 在两个不同的终端窗口运行程序</span><br><span class="line"># 终端1:</span><br><span class="line">./reader</span><br><span class="line"></span><br><span class="line"># 终端2:</span><br><span class="line">./writer</span><br></pre></td></tr></table></figure>



<blockquote>
<p>优点：</p>
<ol>
<li><strong>高性能</strong>：最快的IPC方式，几乎没有数据复制开销</li>
<li><strong>灵活性</strong>：可以共享任何数据结构，包括复杂对象</li>
<li><strong>低延迟</strong>：适合需要频繁通信或大数据量传输的场景</li>
<li><strong>数据持久性</strong>：共享内存区域可以在进程终止后继续存在</li>
</ol>
</blockquote>
<blockquote>
<p>缺点：</p>
<ol>
<li><strong>同步复杂</strong>：需要额外的同步机制(如信号量、互斥锁)来协调访问</li>
<li><strong>无内置消息结构</strong>：需要自行设计数据格式和传输协议</li>
<li><strong>安全风险</strong>：错误的内存访问可能导致数据损坏或程序崩溃</li>
<li><strong>调试困难</strong>：多进程同时访问共享内存的问题难以排查</li>
</ol>
</blockquote>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>上面说的进程间通信，都是常规状态下的工作模式。<strong>对于异常情况下的工作模式，就需要用「信号」的方式来通知进程。</strong></p>
<p>在 Linux 操作系统中， 为了响应各种各样的事件，提供了几十种信号，分别代表不同的意义。我们可以通过 <code>kill -l</code> 命令，查看所有的信号：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">kill</span> -l</span><br><span class="line"> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP</span><br><span class="line"> 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1</span><br><span class="line">11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM</span><br><span class="line">16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP</span><br><span class="line">21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR</span><br><span class="line">31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1  64) SIGRTMAX</span><br></pre></td></tr></table></figure>

<p>运行在 shell 终端的进程，我们可以通过键盘输入某些组合键的时候，给进程发送信号。例如</p>
<ul>
<li>Ctrl+C 产生 <code>SIGINT</code> 信号，表示终止该进程；</li>
<li>Ctrl+Z 产生 <code>SIGTSTP</code> 信号，表示停止该进程，但还未结束；</li>
</ul>
<p>如果进程在后台运行，可以通过 <code>kill</code> 命令的方式给进程发送信号，但前提需要知道运行中的进程 PID 号，例如：</p>
<ul>
<li>kill -9 1050 ，表示给 PID 为 1050 的进程发送 <code>SIGKILL</code> 信号，用来立即结束该进程；</li>
</ul>
<p>所以，信号事件的来源主要有<strong>硬件来源</strong>（如键盘 Cltr+C ）和<strong>软件来源</strong>（如 kill 命令）。</p>
<blockquote>
<p>信号是进程间通信机制中<strong>唯一的异步通信机制</strong>，因为可以在任何时候发送信号给某一进程，一旦有信号产生，我们就有下面这几种，用户进程对信号的处理方式。</p>
<p><strong>1.执行默认操作</strong>。Linux 对每种信号都规定了默认操作，例如，上面列表中的 SIGTERM 信号，就是终止进程的意思。</p>
<p><strong>2.捕捉信号</strong>。我们可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数。</p>
<p><strong>3.忽略信号</strong>。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个信号是应用进程无法捕捉和忽略的，即 <code>SIGKILL</code> 和 <code>SEGSTOP</code>，它们用于在任何时候中断或结束某一进程。</p>
</blockquote>
<p>代码示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handler</span><span class="params">(<span class="type">int</span> sig)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Received signal: &quot;</span> &lt;&lt; sig &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">signal</span>(SIGUSR1, handler); <span class="comment">//注册信号，信号处理函数为handler</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">kill</span>(pid, SIGUSR1);</span><br><span class="line">        <span class="built_in">wait</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    return0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量其实就是一个计数器。在这里主要用于防止多个进程同时对共享内存资源操作导致数据竞争。</p>
<h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h3><p>套接字在这里主要用于不同主机之间的进程间通信，同一主机的进程间通信采用上述列举的方法。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>[1] 小林coding <a href="https://xiaolincoding.com/">https://xiaolincoding.com/</a></p>
<p>[2] 尹圣雨《tcp&#x2F;ip网络编程》</p>
]]></content>
      <categories>
        <category>linux</category>
        <category>多进程</category>
      </categories>
  </entry>
  <entry>
    <title>linux命令02</title>
    <url>/2025/04/22/linux_bashCmd02/</url>
    <content><![CDATA[<p>摘抄自《linux就该这么学》，仅做个人学习用</p>
<h2 id="4个快捷键-组合键小技巧"><a href="#4个快捷键-组合键小技巧" class="headerlink" title="4个快捷键&#x2F;组合键小技巧"></a>4个快捷键&#x2F;组合键小技巧</h2><ul>
<li><p>tab</p>
<p>它能够实现对命令、参数或文件的内容补全。例如，如果想执行reboot重启命令，但一时想不起来该命令的完整拼写，则可以这样输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@linuxprobe ~]# re&lt;Tab键&gt;&lt;Tab键&gt;</span><br><span class="line">read                    redhat-access-insights  rescan-scsi-bus.sh</span><br><span class="line">readarray               reject                  reset</span><br><span class="line">readelf                 remotectl               resize2fs</span><br><span class="line">readlink                rename                  resizecons</span><br><span class="line">readmult                renew-dummy-cert        resizepart</span><br><span class="line">readonly                renice                  resolvconf</span><br><span class="line">readprofile             report-cli              resolvectl</span><br><span class="line">realm                   reporter-rhtsupport     restorecon</span><br><span class="line">realpath                reporter-upload         restorecon_xattr</span><br><span class="line">reboot                  report-gtk              return</span><br><span class="line">recode-sr-latin         repquota                rev</span><br><span class="line">red                     request-key     </span><br><span class="line">[root@linuxprobe ~]# reb&lt;Tab键&gt;</span><br><span class="line">[root@linuxprobe ~]# reboot</span><br></pre></td></tr></table></figure>

<span id="more"></span>
</li>
<li><p><strong>Ctrl+C组合键</strong></p>
<p>同时按下键盘上的Ctrl和字母C的时候，意味着终止当前进程的运行。假如执行了一个错误命令，或者是执行某个命令后迟迟无法结束，这时就可以冷静地按下Ctrl+C组合键，命令行终端的控制权会立刻回到我们手中。</p>
</li>
<li><p><strong>Ctrl+D组合键</strong>：当同时按下键盘上的Ctrl和字母D的时候，表示键盘输入结束。</p>
</li>
<li><p><strong>Ctrl+L组合键</strong>：当同时按下键盘上的Ctrl和字母L的时候，会清空当前终端中已有的内容（相当于清屏操作）。</p>
</li>
</ul>
<h2 id="常用系统工作命令"><a href="#常用系统工作命令" class="headerlink" title="常用系统工作命令"></a>常用系统工作命令</h2><h3 id="1．echo命令"><a href="#1．echo命令" class="headerlink" title="1．echo命令"></a><strong>1．echo命令</strong></h3><p>echo命令用于在终端设备上输出字符串或变量提取后的值，语法格式为“echo [字符串] [$变量]”，它的操作非常简单，执行“echo字符串”或“echo $变量”就行，其中$符号的意思是提取变量的实际值，以便后续的输出操作。</p>
<p>例如，把指定字符串“LinuxProbe.com”输出到终端屏幕的命令为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@linuxprobe ~]# <span class="built_in">echo</span> LinuxProbe.com</span><br></pre></td></tr></table></figure>

<p>下面使用“$变量”的方式提取出变量SHELL的值，并将其输出到屏幕上：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@linuxprobe ~]# echo $SHELL</span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure>

<h3 id="2．date命令"><a href="#2．date命令" class="headerlink" title="2．date命令"></a><strong>2．date命令</strong></h3><p>date命令用于显示或设置系统的时间与日期，语法格式为“date [+指定的格式]”。</p>
<p>用户只需在强大的date命令后输入以“+”号开头的参数，即可按照指定格式来输出系统的时间或日期，这样在日常工作时便可以把备份数据的命令与指定格式输出的时间信息结合到一起。例如，把打包后的文件自动按照“年-月-日”的格式打包成“backup-2020-9-1.tar.gz”，用户只需要看一眼文件名称就能大致了解到每个文件的备份时间了。date命令中常见的参数格式及其作用如表2-4所示。</p>
<img src="/2025/04/22/linux_bashCmd02/image-20250422140148977.png" class="" title="image-20250422140148977">

<p>按照默认格式查看当前系统时间的date命令如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@linuxprobe ~]# date</span><br><span class="line">Sat Sep 5 09:13:45 CST 2020</span><br></pre></td></tr></table></figure>

<p>按照“年-月-日 小时:分钟:秒”的格式查看当前系统时间的date命令如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@linuxprobe ~]# date &quot;+%Y-%m-%d %H:%M:%S&quot;</span><br><span class="line">2020-09-05 09:14:35</span><br></pre></td></tr></table></figure>

<p>将系统的当前时间设置为2020年11月1日8点30分的date命令如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@linuxprobe ~]# date -s &quot;20201101 8:30:00&quot;</span><br><span class="line">Sun Nov 1 08:30:00 CST 2020</span><br></pre></td></tr></table></figure>

<p>date命令中的参数%j可用来查看今天是当年中的第几天。这个参数能够很好地区分备份时间的早晚，即数字越大，越靠近当前时间。该参数的使用方式以及显示结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@linuxprobe ~]# date &quot;+%j&quot;</span><br><span class="line">306</span><br></pre></td></tr></table></figure>

<h3 id="3．wget命令"><a href="#3．wget命令" class="headerlink" title="3．wget命令"></a><strong>3．wget命令</strong></h3><p>wget命令用于在终端命令行中下载网络文件，英文全称为“web get”，语法格式为“wget [参数] 网址”。</p>
<p>借助于wget命令，可以无须打开浏览器，直接在命令行界面中就能下载文件。表2-6所示为wget命令中的参数以及参数的作用。</p>
<style>.vqffjipsnksj{zoom:50%;}</style><img src="/2025/04/22/linux_bashCmd02/image-20250422140610109.png" class="vqffjipsnksj" alt="image-20250422140610109">

<blockquote>
<p>由于本命令需要从外部网络下载文件，但虚拟机默认是无法连接外网的，在操作后会提示响应超时的报错</p>
</blockquote>
<p>使用wget命令从本书的配套站点中下载本书最新的PDF格式的电子文档</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@linuxprobe ~]# wget https://www.linuxprobe.com/docs/LinuxProbe.pdf</span><br></pre></td></tr></table></figure>

<h3 id="4．ps命令"><a href="#4．ps命令" class="headerlink" title="4．ps命令"></a><strong>4．ps命令</strong></h3><p>ps命令用于查看系统中的进程状态，英文全称为“processes”，语法格式为“ps [参数]”。</p>
<p>估计读者在第一次执行这个命令时都要惊呆一下—怎么会有这么多输出值，这可怎么看得过来？其实，高手通常会将ps命令与第3章的管道符技术搭配使用，用来抓取与某个指定服务进程相对应的PID号码。ps命令的常见参数以及作用如表2-7所示。</p>
<img src="/2025/04/22/linux_bashCmd02/image-20250422140805451.png" class="" title="image-20250422140805451">

<p>Linux系统中时刻运行着许多进程，如果能够合理地管理它们，则可以优化系统的性能。在Linux系统中有5种常见的进程状态，分别为运行、中断、不可中断、僵死与停止，其各自含义如下所示。</p>
<blockquote>
<p><strong>R（运行）</strong>：进程正在运行或在运行队列中等待。</p>
<p><strong>S（中断）</strong>：进程处于休眠中，当某个条件形成后或者接收到信号时，则脱离该  状态。</p>
<p><strong>D（不可中断）</strong>：进程不响应系统异步信号，即便用kill命令也不能将其中断。</p>
<p><strong>Z（僵死）</strong>：进程已经终止，但进程描述符依然存在, 直到父进程调用wait4()系统函数后将进程释放。</p>
<p><strong>T（停止）</strong>：进程收到停止信号后停止运行。</p>
</blockquote>
<p>除了上面5种常见的进程状态，还有可能是高优先级（&lt;）、低优先级（N）、被锁进内存（L）、包含子进程（s）以及多线程（l）这5种补充形式。</p>
<p>当执行ps aux命令后通常会看到如表2-8所示的进程状态。表2-8只是列举了部分输出值，而且正常的输出值中不包括中文注释。</p>
<img src="/2025/04/22/linux_bashCmd02/image-20250422141049373.png" class="" title="image-20250422141049373">

<blockquote>
<p>如前面所提到的，在Linux系统中的命令参数有长短格式之分，长格式和长格式之间不能合并，长格式和短格式之间也不能合并，但短格式和短格式之间是可以合并的，合并后仅保留一个减号（-）即可。另外ps命令可允许参数不加减号（-），因此可直接写成ps aux的样子。</p>
</blockquote>
<h3 id="5．pstree命令"><a href="#5．pstree命令" class="headerlink" title="5．pstree命令"></a><strong>5．pstree命令</strong></h3><p>pstree命令用于以树状图的形式展示进程之间的关系，英文全称为“process tree”，输入该命令后按回车键执行即可。</p>
<p>前文提到，在执行ps命令后，产生的信息量太大又没有规律，很难让人再想看第二眼。如果想让进程以树状图的形式，有层次地展示出进程之间的关系，则可以使用pstree命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@linuxprobe ~]# pstree</span><br><span class="line">systemd─┬─ModemManager───2*[&#123;ModemManager&#125;]</span><br><span class="line">├─NetworkManager───2*[&#123;NetworkManager&#125;]</span><br><span class="line">├─VGAuthService</span><br><span class="line">├─accounts-daemon───2*[&#123;accounts-daemon&#125;]</span><br><span class="line">├─atd</span><br><span class="line">├─auditd─┬─sedispatch</span><br><span class="line">│ └─2*[&#123;auditd&#125;]</span><br><span class="line">├─avahi-daemon───avahi-daemon</span><br><span class="line">├─boltd───2*[&#123;boltd&#125;]</span><br><span class="line">├─colord───2*[&#123;colord&#125;]</span><br><span class="line">├─crond</span><br><span class="line">├─cupsd</span><br><span class="line">├─dbus-daemon───&#123;dbus-daemon&#125;</span><br><span class="line">├─dnsmasq───dnsmasq</span><br><span class="line">├─firewalld───&#123;firewalld&#125;</span><br><span class="line">├─fprintd───&#123;fprintd&#125;</span><br><span class="line">├─fwupd───4*[&#123;fwupd&#125;]</span><br><span class="line">………………省略部分输出信息………………</span><br></pre></td></tr></table></figure>

<h3 id="6．top命令"><a href="#6．top命令" class="headerlink" title="6．top命令"></a><strong>6．top命令</strong></h3><p>top命令用于<strong>动态地监视进程活动及系统负载等信息，输入该命令后按回车键执行即可</strong>。</p>
<p>前面介绍的命令都是静态地查看系统状态，不能实时滚动最新数据，而top命令能够动态地查看系统状态，因此完全可以将它看作是<strong>Linux中“强化版的Windows任务管理器”</strong>。top是相当好用的性能分析工具，该命令的运行界面如图2-6所示。</p>
<style>.zdepijwejgbe{zoom:50%;}</style><img src="/2025/04/22/linux_bashCmd02/image-20250422141220828.png" class="zdepijwejgbe" alt="image-20250422141220828">

<p>在图2-6中，top命令执行结果的前5行为系统整体的统计信息，其所代表的含义如下。</p>
<blockquote>
<p>第1行：系统时间、运行时间、登录终端数、系统负载（3个数值分别为1分钟、5分钟、15分钟内的平均值，数值越小意味着负载越低）。</p>
<p>第2行：进程总数、运行中的进程数、睡眠中的进程数、停止的进程数、僵死的进程数。</p>
<p>第3行：用户占用资源百分比、系统内核占用资源百分比、改变过优先级的进程资源百分比、空闲的资源百分比等。其中数据均为CPU数据并以百分比格式显示，例如“99.9 id”意味着有99.9%的CPU处理器资源处于空闲。</p>
<p>第4行：物理内存总量、内存空闲量、内存使用量、作为内核缓存的内存量。</p>
<p>第5行：虚拟内存总量、虚拟内存空闲量、虚拟内存使用量、已被提前加载的内存量。</p>
</blockquote>
<h3 id="7．nice命令"><a href="#7．nice命令" class="headerlink" title="7．nice命令"></a><strong>7．nice命令</strong></h3><p>nice命令用于调整进程的优先级，语法格式为“nice优先级数字 服务名称”。</p>
<p>在top命令输出的结果中，PR和NI值代表的是进程的优先级，数字越低（取值范围是-20～19），优先级越高。在日常的生产工作中，可以将一些不重要进程的优先级调低，让紧迫的服务更多地利用CPU和内存资源，以达到合理分配系统资源的目的。例如将bash服务的优先级调整到最高：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@linuxprobe ~]# nice -n -20 bash</span><br><span class="line">[root@linuxprobe ~]#</span><br></pre></td></tr></table></figure>

<h3 id="8．pidof命令"><a href="#8．pidof命令" class="headerlink" title="8．pidof命令"></a><strong>8．pidof命令</strong></h3><p>pidof命令用于查询某个指定服务进程的PID号码值，语法格式为“pidof [参数] 服务名称”。</p>
<p>每个进程的进程号码值（PID）是唯一的，可以用于区分不同的进程。例如，执行如下命令来查询本机上sshd服务程序的PID：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@linuxprobe ~]# pidof sshd</span><br><span class="line">2156</span><br></pre></td></tr></table></figure>

<h3 id="9．kill命令"><a href="#9．kill命令" class="headerlink" title="9．kill命令"></a><strong>9．kill命令</strong></h3><p>kill命令用于终止某个指定PID值的服务进程，语法格式为“kill [参数] 进程的PID”。</p>
<p>接下来，使用kill命令把上面用pidof命令查询到的PID所代表的进程终止掉，其命令如下所示。这种操作的效果等同于强制停止sshd服务。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@linuxprobe ~]# kill 2156</span><br></pre></td></tr></table></figure>

<p>但有时系统会提示进程无法被终止，此时可以加参数-9，表示最高级别地强制杀死进程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@linuxprobe ~]# kill -9 2156</span><br></pre></td></tr></table></figure>

<h3 id="10．killall命令"><a href="#10．killall命令" class="headerlink" title="10．killall命令"></a><strong>10．killall命令</strong></h3><p>killall命令用于终止某个指定名称的服务所对应的全部进程，语法格式为“killall [参数] 服务名称”。</p>
<p>通常来讲，复杂软件的服务程序会有多个进程协同为用户提供服务，如果用kill命令逐个去结束这些进程会比较麻烦，此时可以使用killall命令来批量结束某个服务程序带有的全部进程。下面以httpd服务程序为例，来结束其全部进程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@linuxprobe ~]# pidof httpd</span><br><span class="line">13581 13580 13579 13578 13577 13576</span><br><span class="line">[root@linuxprobe ~]# killall httpd</span><br><span class="line">[root@linuxprobe ~]# pidof httpd</span><br><span class="line">[root@linuxprobe ~]# </span><br></pre></td></tr></table></figure>

<p>如果在系统终端中执行一个命令后想立即停止它，可以同时按下Ctrl + C组合键（生产环境中比较常用的一个组合键），这样将立即终止该命令的进程。或者，<strong>如果有些命令在执行时不断地在屏幕上输出信息，影响到后续命令的输入，则可以在执行命令时在末尾添加一个&amp;符号</strong>，这样命令将进入系统后台来执行。</p>
<h2 id="系统状态检测命令"><a href="#系统状态检测命令" class="headerlink" title="系统状态检测命令"></a>系统状态检测命令</h2><p>要想更快、更好地了解Linux服务器，必须具备快速查看系统运行状态的能力，因此接下来会逐个讲解与网卡网络、系统内核、系统负载、内存使用情况、当前启用终端数量、历史登录记录、命令执行记录以及救援诊断等相关命令的使用方法。</p>
<h3 id="1．ifconfig命令"><a href="#1．ifconfig命令" class="headerlink" title="1．ifconfig命令"></a><strong>1．ifconfig命令</strong></h3><p>ifconfig命令用于获取网卡配置与网络状态等信息，英文全称为“interface config”，语法格式为“ifconfig [参数] [网络设备]”。</p>
<p>使用<strong>ifconfig命令来查看本机当前的网卡配置与网络状态等信息时</strong>，其实主要查看的就是<strong>网卡名称</strong>、inet参数后面的IP地址、<strong>ether参数后面的网卡物理地址（又称为MAC地址）</strong>，以及<strong>RX、TX的接收数据包与发送数据包的个数及累计流量</strong>（即下面加粗的信息内容）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@linuxprobe ~]# ifconfig</span><br><span class="line">ens160: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.10.10  netmask 255.255.255.0  broadcast 192.168.10.255</span><br><span class="line">        inet6 fe80::c8f8:f5c5:8251:aeaa  prefixlen 64  scopeid 0x20</span><br><span class="line">        ether 00:0c:29:7d:27:bf  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 304  bytes 33283 (32.5 KiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 91  bytes 11052 (10.7 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 376  bytes 31784 (31.0 KiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 376  bytes 31784 (31.0 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">virbr0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500</span><br><span class="line">        ether 52:54:00:a2:89:54  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>



<h3 id="2．uname命令"><a href="#2．uname命令" class="headerlink" title="2．uname命令"></a><strong>2．uname命令</strong></h3><p>uname命令<strong>用于查看系统内核版本与系统架构等信息</strong>，英文全称为“unix name”，语法格式为“uname [-a]”。</p>
<p>在使用uname命令时，一般要固定搭配上-a参数来完整地查看当前系统的内核名称、主机名、内核发行版本、节点名、压制时间、硬件名称、硬件平台、处理器类型以及操作系统名称等信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@linuxprobe ~]# uname -a</span><br><span class="line">Linux linuxprobe.com 4.18.0-80.el8.x86_64 #1 SMP Wed Mar 13 12:02:46 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure>

<p>顺带一提，如果要查看当前系统版本的详细信息，则需要查看redhat-release文件，其命令以及相应的结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@linuxprobe ~]# cat /etc/redhat-release</span><br><span class="line">Red Hat Enterprise Linux release 8.0 (Ootpa)</span><br></pre></td></tr></table></figure>



<h3 id="3．uptime命令"><a href="#3．uptime命令" class="headerlink" title="3．uptime命令"></a><strong>3．uptime命令</strong></h3><p><strong>uptime命令用于查看系统的负载信息，输入该命令后按回车键执行即可</strong>。</p>
<p>uptime命令真的很棒，它可以<strong>显示当前系统时间、系统已运行时间、启用终端数量以及平均负载值等信息</strong>。<font color='mediumseagreen'><strong>平均负载值指的是系统在最近1分钟、5分钟、15分钟内的压力情况（下面加粗的信息部分），负载值越低越好</strong>：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@linuxprobe ~]# uptime</span><br><span class="line">22:49:55 up 10 min, 1 users, load average: 0.01, 0.19, 0.18</span><br></pre></td></tr></table></figure>

<p>“负载值越低越好”是对运维人员来讲的，<strong>越低表示越安全省心。但是公司购置的硬件设备如果长期处于空闲状态，则明显是种资源浪费，老板也不会开心。所以建议负载值保持在1左右，在生产环境中不要超过5就好。</strong></p>
<h3 id="4．free命令"><a href="#4．free命令" class="headerlink" title="4．free命令"></a><strong>4．free命令</strong></h3><p><strong>free命令用于显示当前系统中内存的使用量信息</strong>，语法格式为“free [-h]”。</p>
<p>为了保证Linux系统不会因资源耗尽而突然宕机，运维人员需要时刻关注内存的使用量。在使用free命令时，可以结合使用-h参数以更人性化的方式输出当前内存的实时使用量信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@linuxprobe ~]# free -h</span><br></pre></td></tr></table></figure>

<p>表2-9                      执行free -h命令后的输出信息</p>
<table>
<thead>
<tr>
<th></th>
<th>内存总量</th>
<th>已用量</th>
<th>空闲量</th>
<th>共享使用的内存量</th>
<th>缓存的内存量</th>
<th>可用量</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>total</td>
<td>used</td>
<td>free</td>
<td>shared</td>
<td>buff&#x2F;cache</td>
<td>available</td>
</tr>
<tr>
<td>Mem:</td>
<td>1.9Gi</td>
<td>1.5Gi</td>
<td>126Mi</td>
<td>16Mi</td>
<td>487Mi</td>
<td>437Mi</td>
</tr>
<tr>
<td>Swap:</td>
<td>2.0Gi</td>
<td>56Mi</td>
<td>1.9Gi</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>如果不使用-h（易读模式）查看内存使用量情况，则默认以KB为单位</strong>。这样一来，服务器如果有几百GB的内存，则换算下来就会是一大长串的数字，真不利于阅读。</p>
<h3 id="5．who命令"><a href="#5．who命令" class="headerlink" title="5．who命令"></a><strong>5．who命令</strong></h3><p><strong>who命令用于查看当前登入主机的用户终端信息</strong>，输入该命令后按回车键执行即可。</p>
<p>这3个简单的字母可以快速显示出所有正在登录本机的用户名称以及他们正在开启的终端信息；如<strong>果有远程用户，还会显示出来访者的IP地址。表2-10所示为执行who命令后的结果。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@linuxprobe ~]# who</span><br></pre></td></tr></table></figure>

<p>表2-10                     执行who命令的结果</p>
<table>
<thead>
<tr>
<th>登录的用户名</th>
<th>终端设备</th>
<th>登录到系统的时间</th>
</tr>
</thead>
<tbody><tr>
<td>root</td>
<td>seat0</td>
<td>2025-05-18 02:31 (login screen)</td>
</tr>
<tr>
<td>root</td>
<td>tty2</td>
<td>2025-05-18 02:31 (tty2)</td>
</tr>
</tbody></table>
<h3 id="6．last命令"><a href="#6．last命令" class="headerlink" title="6．last命令"></a><strong>6．last命令</strong></h3><p><strong>last命令用于调取主机的被访记录，输入该命令后按回车键执行即可</strong>。</p>
<p>Linux系统会将每次的登录信息都记录到日志文件中，如果哪天想翻阅了，直接执行这条命令就行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@linuxprobe ~]# last</span><br><span class="line">root     pts/1        192.168.10.1     Tue May 18 10:30 - 11:03  (00:32)</span><br><span class="line">root     tty2         tty2             Fri Jul 24 06:26    gone - no logout</span><br><span class="line">reboot   system boot  4.18.0-80.el8.x8 Fri Jul 24 05:59   still running</span><br><span class="line">root     tty2         tty2             Tue Jul 21 05:19 - down   (00:00)</span><br><span class="line">reboot   system boot  4.18.0-80.el8.x8 Tue Jul 21 05:16 - 05:19  (00:02)</span><br><span class="line"></span><br><span class="line">wtmp begins Tue Jul 21 05:16:47 2020</span><br></pre></td></tr></table></figure>

<h3 id="7．ping命令"><a href="#7．ping命令" class="headerlink" title="7．ping命令"></a><strong>7．ping命令</strong></h3><p>ping命令用于测试主机之间的网络连通性，语法格式为“ping [参数] 主机地址”。</p>
<p>即便大家没有学习过Linux系统，相信也肯定见过别人使用ping命令。执行ping命令时，系统会使用ICMP向远端主机发出要求回应的信息，若连接远端主机的网络没有问题，远端主机会回应该信息。由此可见，ping命令可用于判断远端主机是否在线并且网络是否正常。ping命令的常见参数以及作用如表2-11所示。</p>
<p>表2-11                         ping命令中的参数以及作用</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-c</td>
<td>总共发送次数</td>
</tr>
<tr>
<td>-l</td>
<td>指定网卡名称</td>
</tr>
<tr>
<td>-i</td>
<td>每次间隔时间（秒）</td>
</tr>
<tr>
<td>-W</td>
<td>最长等待时间（秒）</td>
</tr>
</tbody></table>
<p>我们使用ping命令测试一台在线的主机（其IP地址为192.168.10.10），得到的回应是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@linuxprobe ~]# ping -c 4 192.168.10.10</span><br><span class="line">PING 192.168.10.10 (192.168.10.10) 56(84) bytes of data.</span><br><span class="line">64 bytes from 192.168.10.10: icmp_seq=1 ttl=64 time=0.155 ms</span><br><span class="line">64 bytes from 192.168.10.10: icmp_seq=2 ttl=64 time=0.110 ms</span><br><span class="line">64 bytes from 192.168.10.10: icmp_seq=3 ttl=64 time=0.112 ms</span><br><span class="line">64 bytes from 192.168.10.10: icmp_seq=4 ttl=64 time=0.209 ms</span><br><span class="line"></span><br><span class="line">--- 192.168.10.10 ping statistics ---</span><br><span class="line">4 packets transmitted, 4 received, 0% packet loss, time 56ms</span><br><span class="line">rtt min/avg/max/mdev = 0.110/0.146/0.209/0.042 ms</span><br></pre></td></tr></table></figure>

<p>测试一台不在线的主机（其IP地址为192.168.10.20），得到的回应是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@linuxprobe ~]# ping -c 4 192.168.10.20</span><br><span class="line">PING 192.168.10.20 (192.168.10.20) 56(84) bytes of data.</span><br><span class="line">From 192.168.10.10 icmp_seq=1 Destination Host Unreachable</span><br><span class="line">From 192.168.10.10 icmp_seq=2 Destination Host Unreachable</span><br><span class="line">From 192.168.10.10 icmp_seq=3 Destination Host Unreachable</span><br><span class="line">From 192.168.10.10 icmp_seq=4 Destination Host Unreachable</span><br><span class="line"></span><br><span class="line">--- 192.168.10.20 ping statistics ---</span><br><span class="line">4 packets transmitted, 0 received, +4 errors, 100% packet loss, time 68ms</span><br><span class="line">pipe 4</span><br></pre></td></tr></table></figure>

<h3 id="8．tracepath命令"><a href="#8．tracepath命令" class="headerlink" title="8．tracepath命令"></a><strong>8．tracepath命令</strong></h3><p><strong>tracepath命令用于显示数据包到达目的主机时途中经过的所有路由信息</strong>，语法格式为“tracepath [参数] 域名”。</p>
<p>当两台主机之间无法正常ping通时，要考虑两台主机之间是否有错误的路由信息，导致数据被某一台设备错误地丢弃。这时便可以使用tracepath命令追踪数据包到达目的主机时途中的所有路由信息，以分析是哪台设备出了问题。下面的情况就很清晰了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@linuxprobe ~]# tracepath www.linuxprobe.com</span><br><span class="line"> 1?: [LOCALHOST]                                          pmtu 1500</span><br><span class="line"> 1:  no reply</span><br><span class="line"> 2:  11.223.0.189                                          5.954ms asymm  1 </span><br><span class="line"> 3:  11.223.0.14                                           6.256ms asymm  2 </span><br><span class="line"> 4:  11.220.159.62                                         3.313ms asymm  3 </span><br><span class="line"> 5:  116.251.107.13                                        1.841ms </span><br><span class="line"> 6:  140.205.50.237                                        2.416ms asymm  5 </span><br><span class="line"> 7:  101.95.211.117                                        2.772ms </span><br><span class="line"> 8:  101.95.208.45                                        40.839ms </span><br><span class="line"> 9:  101.95.218.217                                       13.898ms asymm  8 </span><br><span class="line">10:  202.97.81.162                                         8.113ms asymm  9 </span><br><span class="line">11:  221.229.193.238                                      15.693ms asymm 10 </span><br><span class="line">12:  no reply</span><br><span class="line">13:  no reply</span><br><span class="line">14:  no reply</span><br><span class="line">15:  no reply</span><br><span class="line">16:  no reply</span><br><span class="line">17:  no reply</span><br><span class="line">18:  no reply</span><br><span class="line">………………省略部分输出信息………………</span><br></pre></td></tr></table></figure>



<h3 id="9．netstat命令"><a href="#9．netstat命令" class="headerlink" title="9．netstat命令"></a><strong>9．netstat命令</strong></h3><p>netstat命令用于显示如网络连接、路由表、接口状态等的网络相关信息，英文全称为“network status”，语法格式为“netstat [参数]”。</p>
<p>只要netstat命令使用得当，便可以查看到网络状态的方方面面信息。我们找出一些常用的参数让大家感受一下。netstat命令的常见参数以及作用如表2-12所示。</p>
<p>表2-12                         netstat命令中的参数以及作用</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-a</td>
<td>显示所有连接中的Socket</td>
</tr>
<tr>
<td>-p</td>
<td>显示正在使用的Socket信息</td>
</tr>
<tr>
<td>-t</td>
<td>显示TCP协议的连接状态</td>
</tr>
<tr>
<td>-u</td>
<td>显示UDP协议的连接状态</td>
</tr>
<tr>
<td>-n</td>
<td>使用IP地址，不使用域名</td>
</tr>
<tr>
<td>-l</td>
<td>仅列出正在监听的服务状态</td>
</tr>
<tr>
<td>-i</td>
<td>显示网卡列表信息</td>
</tr>
<tr>
<td>-r</td>
<td>显示路由表信息</td>
</tr>
</tbody></table>
<p>使用netstat命令显示详细的网络状况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@linuxprobe ~]# netstat -a</span><br><span class="line">Active Internet connections (servers and established)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State      </span><br><span class="line">tcp        0      0 0.0.0.0:ssh             0.0.0.0:*               LISTEN     </span><br><span class="line">tcp        0      0 localhost:ipp           0.0.0.0:*               LISTEN     </span><br><span class="line">tcp        0      0 0.0.0.0:sunrpc          0.0.0.0:*               LISTEN     </span><br><span class="line">tcp6       0      0 [::]:ssh                [::]:*                  LISTEN     </span><br><span class="line">tcp6       0      0 localhost:ipp           [::]:*                  LISTEN     </span><br><span class="line">tcp6       0      0 [::]:sunrpc             [::]:*                  LISTEN     </span><br><span class="line">udp        0      0 0.0.0.0:bootps          0.0.0.0:*                          </span><br><span class="line">udp        0      0 0.0.0.0:sunrpc          0.0.0.0:*                          </span><br><span class="line">udp        0      0 0.0.0.0:mdns            0.0.0.0:*                          </span><br><span class="line">udp        0      0 0.0.0.0:37396           0.0.0.0:*                          </span><br><span class="line">udp6       0      0 [::]:sunrpc             [::]:*                             </span><br><span class="line">udp6       0      0 [::]:mdns               [::]:*                             </span><br><span class="line">udp6       0      0 [::]:38541              [::]:*       </span><br><span class="line">………………省略部分输出信息………………     </span><br></pre></td></tr></table></figure>

<p>使用netstat命令显示网卡列表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@linuxrpobe ~]# netstat -i </span><br><span class="line">Kernel Interface table</span><br><span class="line">Iface             MTU    RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg</span><br><span class="line">ens160           1500       70      0      0 0            79      0      0      0 BMRU</span><br><span class="line">lo              65536      248      0      0 0           248      0      0      0 LRU</span><br><span class="line">virbr0           1500        0      0      0 0             0      0      0      0 BMU</span><br></pre></td></tr></table></figure>



<h3 id="10．history命令"><a href="#10．history命令" class="headerlink" title="10．history命令"></a><strong>10．history命令</strong></h3><p>history命令用于显示执行过的命令历史，语法格式为“history [-c]”。</p>
<p><strong>history命令应该是运维人员最喜欢的命令。执行history命令能显示出当前用户在本地计算机中执行过的最近1000条命令记录。</strong>如果觉得1000不够用，可以自定义&#x2F;etc&#x2F;profile文件中的HISTSIZE变量值。在使用history命令时，可以使用-c参数清空所有的命令历史记录。还可以使用“!编码数字”的方式来重复执行某一次的命令。总之，history命令有很多有趣的玩法等待您去开发。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@linuxprobe ~]# history</span><br><span class="line">1 ifconfig</span><br><span class="line">2 uname -a</span><br><span class="line">3 cat /etc/redhat-release</span><br><span class="line">4 uptime</span><br><span class="line">5 free -h</span><br><span class="line">6 who</span><br><span class="line">7 last</span><br><span class="line">8 ping -c 192.168.10.10</span><br><span class="line">9 ping -c 192.168.10.20</span><br><span class="line">10 tracepath www.linuxprobe.com</span><br><span class="line">11 netstat -a</span><br><span class="line">12 netstat -i</span><br><span class="line">13 history</span><br><span class="line">[root@linuxprobe ~]# !3</span><br><span class="line">cat /etc/redhat-release</span><br><span class="line">Red Hat Enterprise Linux release 8.0 (Ootpa)</span><br></pre></td></tr></table></figure>

<p>历史命令会被保存到用户家目录中的.bash_history文件中。Linux系统中以点（.）开头的文件均代表隐藏文件，这些文件大多数为系统服务文件，可以用cat命令查看其文件内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@linuxprobe ~]# cat ~/.bash_history</span><br></pre></td></tr></table></figure>

<p>要清空当前用户在本机上执行的Linux命令历史记录信息，可执行如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@linuxprobe ~]# history -c</span><br></pre></td></tr></table></figure>



<h3 id="11．sosreport命令"><a href="#11．sosreport命令" class="headerlink" title="11．sosreport命令"></a><strong>11．sosreport命令</strong></h3><p>sosreport命令用于收集系统配置及架构信息并输出诊断文档，输入该命令后按回车键执行即可。</p>
<p>当Linux系统出现故障需要联系技术支持人员时，大多数时候都要先使用这个命令来简单收集系统的运行状态和服务配置信息，以便让技术支持人员能够远程解决一些小问题，抑或让他们能提前了解某些复杂问题。在下面的输出信息中，加粗的部分是收集好的资料压缩文件以及校验码，将其发送给技术支持人员即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@linuxprobe ~]# sosreport</span><br><span class="line">sosreport (version 3.6)</span><br><span class="line">This command will collect diagnostic and configuration information from</span><br><span class="line">this Red Hat Enterprise Linux system and installed applications.</span><br><span class="line"></span><br><span class="line">An archive containing the collected information will be generated in</span><br><span class="line">/var/tmp/sos.9_i0glu8 and may be provided to a Red Hat support</span><br><span class="line">representative.</span><br><span class="line"></span><br><span class="line">Any information provided to Red Hat will be treated in accordance with</span><br><span class="line">the published support policies at:</span><br><span class="line">https://access.redhat.com/support/</span><br><span class="line">The generated archive may contain data considered sensitive and its</span><br><span class="line">content should be reviewed by the originating organization before being</span><br><span class="line">passed to any third party.</span><br><span class="line"></span><br><span class="line">No changes will be made to system configuration.</span><br><span class="line">Press ENTER to continue, or CTRL-C to quit.</span><br><span class="line">此处按下回车键进行确认</span><br><span class="line">Please enter the case id that you are generating this report for []:此处按下回车键进行确认</span><br><span class="line">Setting up archive ...</span><br><span class="line">Setting up plugins ...</span><br><span class="line">Running plugins. Please wait ...</span><br><span class="line">………………省略部分输出信息………………</span><br><span class="line">Finished running plugins </span><br><span class="line">Creating compressed archive...</span><br><span class="line"></span><br><span class="line">Your sosreport has been generated and saved in:</span><br><span class="line">/var/tmp/sosreport-linuxprobe.com-2021-05-18-jnkaspu.tar.xz</span><br><span class="line"></span><br><span class="line">The checksum is: 9fbecbd167b7e5836db1ff8f068c4db3</span><br><span class="line">Please send this file to your support representative.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>sosreport命令有点像是远程问诊。假如我们今天有点咳嗽发烧不舒服，可以先从网上搜索相关症状的病因，如果仅仅是感冒的话那就多喝水，这就免去了到医院挂号看病的车马劳顿；而如果怀疑出了大毛病，再请专业人员进行处理也不迟。</p>
</blockquote>
]]></content>
      <categories>
        <category>linux</category>
        <category>Bash命令</category>
      </categories>
  </entry>
</search>
