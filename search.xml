<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>cmake</title>
    <url>/2025/03/10/DevTools__cmake/</url>
    <content><![CDATA[<h2 id="从零开始写一个CMakeLists-txt文件"><a href="#从零开始写一个CMakeLists-txt文件" class="headerlink" title="从零开始写一个CMakeLists.txt文件"></a>从零开始写一个CMakeLists.txt文件</h2><p>从零开始写CMakeLists.txt的基本步骤和结构：</p>
<ol>
<li><strong>第一步：基础设置</strong><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定CMake最低版本</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目名称</span></span><br><span class="line"><span class="keyword">project</span>(你的项目名称)</span><br></pre></td></tr></table></figure></li>
</ol>
<span id="more"></span>

<ol start="2">
<li><strong>第二步：设置编译选项</strong></li>
</ol>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置C++标准</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -std=c++11&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置编译类型（Debug/Release）</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_BUILD_TYPE Debug)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p><strong>第三步：设置头文件和库文件路径</strong></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果有额外的头文件目录</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="keyword">include</span>)</span><br><span class="line"><span class="comment"># 如果有额外的库文件目录</span></span><br><span class="line"><span class="keyword">link_directories</span>(lib)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>第四步：添加源文件</strong></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方法1：直接列出所有源文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(项目名称 </span><br><span class="line">    src/main.cpp</span><br><span class="line">    src/other.cpp</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法2：使用变量收集源文件</span></span><br><span class="line"><span class="keyword">set</span>(SOURCES</span><br><span class="line">    src/main.cpp</span><br><span class="line">    src/other.cpp</span><br><span class="line">)</span><br><span class="line"><span class="keyword">add_executable</span>(项目名称 <span class="variable">$&#123;SOURCES&#125;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>第五步：如果需要链接外部库</strong></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 链接库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(项目名称</span><br><span class="line">    库名称<span class="number">1</span></span><br><span class="line">    库名称<span class="number">2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
</ol>
<p>一些实用的建议：</p>
<ol>
<li>保持结构清晰，按照上述步骤组织你的CMakeLists.txt</li>
<li>使用注释说明每个部分的作用</li>
<li>对于大型项目，可以使用子目录的CMakeLists.txt</li>
<li>养成良好的变量命名习惯</li>
<li>建议使用现代CMake的命令和特性</li>
</ol>
<p>创建一个最简单的CMakeLists.txt，可以参考这个模板：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 最低CMake版本要求</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目名称</span></span><br><span class="line"><span class="keyword">project</span>(MyProject)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将所有源文件添加到可执行文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(MyProject main.cpp)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>开发工具</category>
        <category>构建</category>
      </categories>
  </entry>
  <entry>
    <title>遍历排序与分治排序</title>
    <url>/2025/02/27/Algo_Sort/</url>
    <content><![CDATA[<p>总结了3种遍历排序与三种分治排序算法</p>
<p><strong>排序算法性质</strong>：</p>
<p><strong>自适应性</strong>：自适应排序能够利用输入已有的顺序信息来减少计算量，达到更优的时间效率</p>
<p><strong>稳定性</strong>：排序完成后，相等元素在数组中的顺序不发生改变</p>
<span id="more"></span>

<h2 id="遍历排序"><a href="#遍历排序" class="headerlink" title="遍历排序"></a>遍历排序</h2><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>思路：每次查找未排序区间的最小值，并与排序区间的尾部(实际这个位置是每轮外循环未排序区间的第一个位置)交换位置</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//外循环，未排序区间为[i,n-1],每轮未排序区间长度减1</span></span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++) &#123;<span class="comment">//最后一个不用排了</span></span><br><span class="line">    	<span class="type">int</span> k = i; <span class="comment">//未排序区间最小元素索引</span></span><br><span class="line">        <span class="comment">//内循环找未排序区间最小值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i<span class="number">+1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[k] &lt; nums[j]) &#123;</span><br><span class="line">                k = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[k]); <span class="comment">//将最小元素与未排序区间最小值交换</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度o(n^2),空间复杂度o(1)，非稳定性排序</li>
</ul>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>思路：每次冒泡都得到未排序区间的最大值，并交换至未排序区间的尾部，n个数冒泡n-1次即可(外循环次数),</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">//外循环，未排序区间[0,i]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n<span class="number">-1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>; <span class="comment">//标志</span></span><br><span class="line">   		<span class="comment">//内循环，交换最大值至未排序区间的末尾</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j<span class="number">+1</span>] &lt; nums[j]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[j],numss[j<span class="number">+1</span>]);</span><br><span class="line">                flage = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//本轮没有交换说明已经有序了，直接推出即可</span></span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;<span class="keyword">break</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度o(n^2), 有flag的情况下最佳时间复杂度o(n), 空间复杂度o(1)，稳定排序</li>
</ul>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>思路：在未排序区间选择一个基准元素，将其与左边的已排序区间比较，一直到左边元素不大于基准元素为止</p>
<style>.njwxivxbdapl{zoom:33%;}</style><img src="/2025/02/27/Algo_Sort/image-20250227120737150.png" class="njwxivxbdapl" alt="image-20250227120737150">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertionSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//外循环，已排序区间为[0,i-1]</span></span><br><span class="line">    <span class="comment">//初始状态，第一个元素已完成排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> base = nums[i], j = i<span class="number">-1</span>; </span><br><span class="line">    	<span class="comment">//内循环，将base插入到已排序区间</span></span><br><span class="line">		<span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &gt; base) &#123;</span><br><span class="line">            nums[j<span class="number">+1</span>] = nums[j]; <span class="comment">//右移一位</span></span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[j<span class="number">+1</span>] = base; <span class="comment">//插入base</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最差时间复杂度为o(n^2)，数据完全有序的情况下时间复杂度为o(n)，空间复杂度为o(1),稳定排序</p>
<img src="/2025/02/27/Algo_Sort/image-20250227132530692.png" class="" title="image-20250227132530692">

<hr>
<h2 id="分治排序"><a href="#分治排序" class="headerlink" title="分治排序"></a>分治排序</h2><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>思路：</p>
<ul>
<li><p>在未优化的情况下，快速排序的思路为先进行哨兵划分：即将数组最左边的元素nums[left]作为基准值，定义定义两个指针i,j,并分别初始化指向数组左边left和右边right，i从左往右找大于基准值的位置，j从右往左找小于基准值的位置，随后交换对应位置的值，并继续循环。  </p>
</li>
<li><p>进过哨兵划分之后，数组分成了两个子数组，接着递归这两个子数组即可。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//哨兵划分</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = left, j = right;</span><br><span class="line">    <span class="comment">//以nums[left]为基准值</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] &gt;= nums[left]) &#123; <span class="comment">//注意等于时也要移动</span></span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] &lt;= nums[left]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[j]);   															</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//i==j时，将基准值交换到i的位置</span></span><br><span class="line">    <span class="built_in">swap</span>(nums[left], nums[i]);</span><br><span class="line">    <span class="keyword">return</span> i; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//哨兵划分</span></span><br><span class="line">    <span class="comment">//左闭右闭</span></span><br><span class="line">    <span class="type">int</span> pivot = <span class="built_in">partition</span>(nums, left, right);</span><br><span class="line">    <span class="built_in">quickSort</span>(nums, left, pivot<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">queickSort</span>(nums, pivot<span class="number">+1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="易错点"><a href="#易错点" class="headerlink" title="易错点"></a>易错点</h4><blockquote>
<p>哨兵划分中，以下代码是错误的(即不能先从左往右搜索大于基准值的元素)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] &lt;= nums[left]) &#123;</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] &gt;= nums[left]) &#123;</span><br><span class="line">        --j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(nums[i], nums[j]);   															</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原因：</p>
<p>对于数组 <code>[5, 7, 8, 9, 6]</code>：</p>
<ol>
<li>初始状态：<code>[5, 7, 8, 9, 6]</code>，i &#x3D; 0，j &#x3D; 4，pivot &#x3D; 5</li>
<li>先从左往右搜：<ul>
<li>i &#x3D; 0, nums[0] &#x3D; 5 等于 pivot，i++</li>
<li>i &#x3D; 1, nums[1] &#x3D; 7 &gt; pivot，停止</li>
</ul>
</li>
<li>再从右往左搜：<ul>
<li>j &#x3D; 4, nums[4] &#x3D; 6 &gt; pivot，j–</li>
<li>j &#x3D; 3, nums[3] &#x3D; 9 &gt; pivot，j–</li>
<li>j &#x3D; 2, nums[2] &#x3D; 8 &gt; pivot，j–</li>
<li>j &#x3D; 1, 此时 i &#x3D; j，跳出循环</li>
</ul>
</li>
<li>交换 基准值nums[left] 和 nums[i]：i &#x3D; 1，所以交换 nums[0] 和 nums[1]： <code>[7, 5, 8, 9, 6]</code></li>
<li>返回 pivot 位置 1</li>
</ol>
<p>7 &gt; 5，但 7 被放到了 pivot 的左边，破坏了快速排序的分区性质，导致排序结果错误。</p>
</blockquote>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>在数组倒序的情况下，基准数左边或者右边数组长度为n-1，每次递归都会出现有一个子数组长度为0的情况，快速排序退化为类似冒泡排序，时间复杂度劣化为o(n^2)。</p>
<p>同样正序的情况下，也会出现有一个子数组长度为0的情况，每次递归长度为n-1的数组都只减少一个元素，递归深度为n-1，需要占用o(n)的栈帧空间</p>
<p>因此要对基准值和递归区间的选取进行优化：即选择数组左，中，右值的中位数作为基准值，选择对长度更短的子数组递归</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//选择基准数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">medianThree</span><span class="params">(vector&lt;<span class="type">int</span>&gt; nums, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = nums[left], m = nums[mid], r = nums[right];</span><br><span class="line">    <span class="keyword">if</span> ((l &lt;= m &amp;&amp; m &lt;= r) || (r &lt;= m &amp;&amp; m &lt;= l)) &#123;</span><br><span class="line">        <span class="keyword">return</span> mid;		     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((m &lt;= l &amp;&amp; l &lt;= r) || (r &lt;= l &amp;&amp; l &lt;= m)) &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//哨兵划分</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> median = <span class="built_in">medianThree</span>(nums, left, left+(right-left)/<span class="number">2</span> ,right); 	 </span><br><span class="line"> 	<span class="comment">//将数组交换至数组最左端</span></span><br><span class="line">    <span class="built_in">swap</span>(nums[median], nums[left]);</span><br><span class="line">   	<span class="comment">//后面一样，省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 子数组长度为1 时终止</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="comment">// 哨兵划分操作</span></span><br><span class="line">        <span class="type">int</span> pivot = <span class="built_in">partition</span>(nums, left, right);</span><br><span class="line">        <span class="comment">// 对两个子数组中较短的那个执行快速排序</span></span><br><span class="line">        <span class="keyword">if</span> (pivot - left &lt; right - pivot) &#123;</span><br><span class="line">            <span class="built_in">quickSort</span>(nums, left, pivot - <span class="number">1</span>); <span class="comment">// 递归排序左子数组</span></span><br><span class="line">            left = pivot + <span class="number">1</span>; <span class="comment">// 剩余未排序区间为[pivot + 1, right]</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">quickSort</span>(nums, pivot + <span class="number">1</span>, right); <span class="comment">// 递归排序右子数组</span></span><br><span class="line">            right = pivot - <span class="number">1</span>; <span class="comment">// 剩余未排序区间为[left, pivot - 1]  </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color='red'>注意</font>：</p>
<blockquote>
<p><font color='cornflowerblue'>1.得到中位数后，交换中位数与数组最左边元素的值之后，可以使用一个变量存储这个值再进行循环比较。</font></p>
<p>每次循环比较时，如果直接使用<code>nums[left]</code>，<font color='red'>编译器需要每次都访问数组并计算偏移量</font>。<strong>而存储在局部变量<code>pivotValue</code>中只需读取一次，可以减少内存访问，提高性能</strong>。在数组很大且循环次数多的情况下，这种优化是有意义的。（<strong>力扣912通过这个优化不会超时</strong>）</p>
<p><font color='cornflowerblue'>2.以下代码是错误的</font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 三数取中选择枢轴</span></span><br><span class="line">    <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> pivotIndex = <span class="built_in">medianThree</span>(nums, left, mid, right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将枢轴值移到最左边</span></span><br><span class="line">    <span class="built_in">swap</span>(nums[left], nums[pivotIndex]);</span><br><span class="line">    <span class="type">int</span> pivotValue = nums[left];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = left, j = right;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="comment">// 从右向左找第一个小于枢轴的元素</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] &gt;= pivotValue) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="comment">// 从左向右找第一个大于枢轴的元素</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] &lt;= pivotValue) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换这两个元素</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将枢轴值放到正确的位置</span></span><br><span class="line">    <span class="built_in">swap</span>(pivotValue, nums[i]);  <span class="comment">//错误！！应该是nums[left]和nums[i]交换</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原因：</p>
<p><strong>交换操作需要实际的数组元素位置</strong>，而不仅仅是值。<code>swap(nums[left], nums[i])</code>是在交换数组中两个位置的元素，而<code>pivotValue</code>只是一个存储值的变量，不是数组中的位置</p>
<p><font color='cornflowerblue'>3.随机选择基准点来应对特殊输入</font></p>
<p>如果每次选择的基准点都是当前区间的最大或最小值（例如在已排序数组上总是选择第一个元素），分区操作会导致极不平衡的子区间划分（一个子区间为空，另一个包含n-1个元素）。这会使时间复杂度退化到O(n²)。</p>
<p>只需在分区前随机选择一个元素作为基准点：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 随机选择基准点</span></span><br><span class="line">    <span class="type">int</span> randomIndex = left + <span class="built_in">rand</span>() % (right - left + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将随机选择的基准点交换到左端</span></span><br><span class="line">    <span class="built_in">swap</span>(nums[left], nums[randomIndex]);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> pivotValue = nums[left];</span><br><span class="line">    <span class="type">int</span> i = left, j = right;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 常规的分区过程</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] &gt;= pivotValue) j--;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] &lt;= pivotValue) i++;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">swap</span>(nums[left], nums[i]);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：</p>
<ul>
<li><p><strong>平均性能保证</strong>：随机选择使得算法性能不依赖于输入数据的特定模式，能够有效避免最坏情况的频繁出现。</p>
</li>
<li><p><strong>防御性编程</strong>：对抗恶意构造的输入数据，增强算法的健壮性。</p>
</li>
</ul>
<p><strong>概率分析</strong>：从理论上讲，随机快速排序的期望时间复杂度仍为O(n log n)，且这个期望适用于任何输入。</p>
<p><strong>简单直接</strong>：相比其他复杂的基准点选择策略，随机选择实现简单且效果显著。</p>
</blockquote>
<img src="/2025/02/27/Algo_Sort/image-20250227153337619.png" class="">



<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序的递归顺序和二叉树的后序遍历是一样的，即先递归左数组，再递归右数组，最后合并，注意合并时的子数组是有序的。一图总结如下：</p>
<style>.dffsugtlqvhi{zoom: 67%;}</style><img src="/2025/02/27/Algo_Sort/image-20250227153030239.png" class="dffsugtlqvhi" alt="image-20250227153030239">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//合并左右子数组,左数组[left, mid], 右数组[mid+1, right]</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = left, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//创建临时数组存放合并后数组</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tmp</span><span class="params">(right- left <span class="number">+1</span>)</span></span>;</span><br><span class="line">    <span class="comment">//左右数组都还有元素时进行比较</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">        <span class="comment">//将较小元素放入tmp</span></span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt;= nums[j]) &#123;</span><br><span class="line">            tmp[k++] = nums[i++]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp[k++] = nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将剩下元素放入tmp,注意i,j往后移动</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">        tmp[k++] = nums[i++]; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= right) &#123;</span><br><span class="line">        tmp[k++] = nums[j++]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将合并后放回到原数组对应位置</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; tmp.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        nums[left+i] = tmp[i]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//子数组长度为1时终止</span></span><br><span class="line">	<span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">//子数组划分</span></span><br><span class="line">    <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">mergeSort</span>(nums, left, mid); <span class="comment">//左</span></span><br><span class="line">    <span class="built_in">mergeSort</span>(nums, mid<span class="number">+1</span>, right); <span class="comment">//右</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对子数组进行合并</span></span><br><span class="line">    <span class="built_in">merge</span>(nums, left, mid, right);  <span class="comment">//中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度为o(n*logn)，递归深度logn,每层操作n次。  空间复杂度为o(n)，具体：栈帧空间占o(logn), 创建临时数组空间为o(n)</li>
</ul>
<p><font color='red'>归并排序特别适合链表排序</font>，在划分阶段可以使用迭代来代替递归，在合并阶段也不用创建额外的辅助数据，因为链表的合并只需要操作指针</p>
<h4 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148 排序链表"></a>148 排序链表</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//找到链表中点</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">findListMid</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast-&gt;next != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并左右子链表</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* left, ListNode* right)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>();<span class="comment">//虚拟头节点用于链表合并</span></span><br><span class="line">        ListNode* cur = dummyNode;</span><br><span class="line">        <span class="keyword">while</span> (left &amp;&amp; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left-&gt;val &lt;= right-&gt;val) &#123;</span><br><span class="line">                cur-&gt;next = left;</span><br><span class="line">                left = left-&gt;next;<span class="comment">//右移</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur-&gt;next = right;</span><br><span class="line">                right = right-&gt;next;</span><br><span class="line">            &#125;  </span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//链接剩下的节点</span></span><br><span class="line">        <span class="comment">//注意直接if链接就行，不用while</span></span><br><span class="line">        <span class="keyword">if</span> (left) cur-&gt;next = left;</span><br><span class="line">        <span class="keyword">if</span> (right) cur-&gt;next = right;</span><br><span class="line"></span><br><span class="line">        ListNode* result = dummyNode-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummyNode;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//归并排序</span></span><br><span class="line">        <span class="comment">//终止条件，空链表或者只有一个节点时终止</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* mid = <span class="built_in">findListMid</span>(head);</span><br><span class="line">        ListNode* right = mid-&gt;next;</span><br><span class="line">        mid-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        ListNode* leftSortedList = <span class="built_in">sortList</span>(head); <span class="comment">//递归左链表</span></span><br><span class="line">        ListNode* righSortedtList = <span class="built_in">sortList</span>(right); <span class="comment">//递归右链表</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">merge</span>(leftSortedList, righSortedtList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度为o(nlogn)</li>
<li>空间复杂度为栈帧空间o(logn)</li>
</ul>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>思路：</p>
<ul>
<li>先建立一个大顶堆，对数组执行堆化处理</li>
<li>交换堆顶元素和堆底元素,此时堆长度-1，已排序元素+1</li>
<li>堆顶元素从顶向下堆化</li>
<li>循环<strong>n-1</strong>次交换和堆化的过程</li>
</ul>
<p><strong>完全二叉树非常适合使用数组来表示</strong>，而堆就是一种特殊的完全二叉树，所以其底层实现就是数组。</p>
<style>.ssamiwywmqgz{zoom: 50%;}</style><img src="/2025/02/27/Algo_Sort/image-20250227171531676.png" class="ssamiwywmqgz" alt="image-20250227171531676">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//堆的长度为n，从节点i开始，从顶至底执行堆化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">siftDown</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> n, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">//索引i的左子节点为2i+1,右子节点为2i+2, 父节点索引为(i-1)/2</span></span><br><span class="line">        <span class="type">int</span> l = <span class="number">2</span>i<span class="number">+1</span>, r = <span class="number">2</span>i<span class="number">+2</span>;</span><br><span class="line">        <span class="type">int</span> ma = i; <span class="comment">//ma为i,l,r中值最大的节点索引</span></span><br><span class="line">        <span class="keyword">if</span> (l &lt; n &amp;&amp; nums[l] &gt;= nums[ma]) &#123;</span><br><span class="line">            ma = l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; n &amp;&amp; nums[r] &gt;= nums[ma]) &#123;</span><br><span class="line">           ma = r; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如节点i最大或l，r越界则无需继续堆化</span></span><br><span class="line">        <span class="keyword">if</span> (ma == i) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[ma]);</span><br><span class="line">        i = ma; <span class="comment">//循环进行堆化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">haepSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//建堆，堆化除叶子节点外所有节点</span></span><br><span class="line">    <span class="comment">//建堆的循环语句还可以从最后一个节点的父节点开始，即for (int i = (nums.size()- 1 - 1) / 2; i &gt;= 0; --i) &#123;&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = nums.<span class="built_in">size</span>() / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="comment">//从索引i开始从顶至底的执行堆化</span></span><br><span class="line">    	<span class="built_in">siftDown</span>(nums, nums.<span class="built_in">size</span>(), i); 	   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//循环n-1次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;<span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="comment">//交换堆顶元素与堆底元素</span></span><br><span class="line">        <span class="built_in">swap</span>(nums[<span class="number">0</span>], nums[i]); <span class="comment">//堆长度减1</span></span><br><span class="line">        <span class="built_in">siftDown</span>(nums, i, <span class="number">0</span>); <span class="comment">//从堆顶开始堆化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度o(nlogn)。输入列表并建堆操作的事件复杂度为o(n); 从堆中提取最大元素的时间复杂度为o(logn)(<strong>其实就是堆化的时间复杂度为o(logn)</strong>)。 </p>
<p><strong>补充</strong>：像堆排序这样直接将一个数组进行建堆是从底至顶的，而对于每个节点(除开叶子节点)来说，堆化却是从顶至底的。相比一个个输入元素再每次进行堆化(建堆时间复杂度为o(nlogn))的时间复杂度要小，因为叶子节点不用堆化。</p>
</li>
<li><p>原地排序，空间复杂度为o(1)</p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>冒泡排序通过交换相邻元素来实现排序。通过添加一个标志位来实现提前返回，我们可以将冒泡排序<br>的最佳时间复杂度优化到𝑂(𝑛) 。</li>
<li>插入排序每轮将未排序区间内的元素插入到已排序区间的正确位置，从而完成排序。虽然插入排序的<br>时间复杂度为𝑂(𝑛2) ，但由于单元操作相对较少，因此在小数据量的排序任务中非常受欢迎。</li>
<li>快速排序基于哨兵划分操作实现排序。在哨兵划分中，有可能每次都选取到最差的基准数，导致时间复<br>杂度劣化至𝑂(𝑛2) 。引入中位数基准数或随机基准数可以降低这种劣化的概率。尾递归方法可以有效<br>地减少递归深度，将空间复杂度优化到𝑂(log 𝑛) 。 </li>
<li>归并排序包括划分和合并两个阶段，典型地体现了分治策略。在归并排序中，排序数组需要创建辅助数<br>组，空间复杂度为𝑂(𝑛) ；然而排序链表的空间复杂度可以优化至𝑂(1) 。</li>
<li>桶排序包含三个步骤：数据分桶、桶内排序和合并结果。它同样体现了分治策略，适用于数据体量很大<br>的情况。桶排序的关键在于对数据进行平均分配。</li>
<li>计数排序是桶排序的一个特例，它通过统计数据出现的次数来实现排序。计数排序适用于数据量大但<br>数据范围有限的情况，并且要求数据能够转换为正整数。</li>
<li>基数排序通过逐位排序来实现数据排序，要求数据能够表示为固定位数的数字。</li>
</ul>
<p>总的来说，我们希望找到一种排序算法，具有高效率、稳定、原地以及自适应性等优点。然而，正如其<br>他数据结构和算法一样，没有一种排序算法能够同时满足所有这些条件。在实际应用中，我们需要根据<br>数据的特性来选择合适的排序算法</p>
<img src="/2025/02/27/Algo_Sort/image-20250414110458634.png" class="" title="image-20250414110458634">

<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>[1] hello-algo: 《Hello 算法》(<a href="https://github.com/krahets/hello-algo">https://github.com/krahets/hello-algo</a>)</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>排序</category>
      </categories>
  </entry>
  <entry>
    <title>typora+hexo-asset-img插入文章图片</title>
    <url>/2025/02/18/blog_typora&amp;hexo-asset-img/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在使用hexo部署博客文章时，发现hexo默认的上传文件方式不太方便(如下)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% asset_img image.png name %&#125;</span><br></pre></td></tr></table></figure>

<p>于是上网搜索方案，发现typora配合其它转图片路径的插件的方案很方便，但是在试过<code>hexo-asset-image</code>和<code>hexo-renderer-marked</code>之后，发现直接在typora中粘贴图片(即markdown格式)还是无法在网页上显示图片。</p>
<p>以下是遇到的主要问题及解决方法</p>
<span id="more"></span>

<h2 id="问题1："><a href="#问题1：" class="headerlink" title="问题1："></a>问题1：</h2><p><strong>_post目录下如果在生成的.md目录插入图片就会生成两个同名的文件夹(实际上有一个后面多了一个空格)，导致默认的图片上传方式都出问题</strong></p>
<p><strong>原因及解决方案</strong>：在修改_config.yml文件中的<strong>post_asset_folder为true</strong>之后，如果使用<code>hexo new xxx</code>的方式生成.md文件和同名文件夹，且同时还将typora的偏好设置为<code>./$&#123;filename&#125;</code>，那么就会出现这样的问题，解决办法就是直接手动创建一个.md文件，只要插入图片，typora就自动会生成一个同名文件夹，并加图片放入。（<font color='red'>注意不要将post_asset_folder又设回false了</font>）</p>
<h2 id="问题2："><a href="#问题2：" class="headerlink" title="问题2："></a>问题2：</h2><p><strong>按照网上许多方法仍然无法直接使用<code>![](xx.png)</code>这种markdown格式插入图片</strong></p>
<p><strong>原因分析</strong>：<font color='red'>该问题的主要原因在于插件版本和hexo版本不一致</font>。在本地生成的静态网页中我们可以按”F12”查看图片路径是否转换成功。</p>
<img src="/2025/02/18/blog_typora&hexo-asset-img/image-20250218221232758.png" class="" title="F12查看图片路径">

<p>如图所示，&#x2F;2025&#x2F;02&#x2F;18&#x2F;player&#x2F;xx这个目录就是<code>hexo g</code>执行后生成到public目录下的。</p>
<ul>
<li>从文件中查看，如果该目录下没有我们文章中出现的图片，则说明图片上传失败；</li>
<li>而从网页端查看则如图所示，即图片源路径指向了对应的目录。</li>
</ul>
<p>上面两种方式都可以用来判断图片是否上传成功</p>
<p><strong>解决办法:</strong></p>
<p>由于我们使用的是hexo6.3.0版本，<code>hexo-asset-image</code>插件已经无法适配，所以这里直接下载另外一个<code>hexo-asset-img</code>插件即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-asset-img --save</span><br></pre></td></tr></table></figure>

<p>随后，按照问题1的方式创建.md文件，直接在typora中粘贴图片，即可实现图片和文章一起上传至博客网站.</p>
<p>在typora中图片插入的具体的格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![命名](与.md同名文件夹/logo.png)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>AI提示词</title>
    <url>/2025/03/25/blog_AIprompt/</url>
    <content><![CDATA[<h2 id="提示词基本结构"><a href="#提示词基本结构" class="headerlink" title="提示词基本结构"></a>提示词基本结构</h2><p>即：角色+指令+上下文+输入问题+约束+例子+输出格式 。</p>
<span id="more"></span>

<p>1.角色(role) </p>
<blockquote>
<p>交互时通过给AI大模型设定某种角色，根据经验可以获得意想不到的效果，可以使大模型的输出更加具有个性化，专业化，同时能够增加模型输出的准确性。</p>
</blockquote>
<p>2.指示或者指令</p>
<blockquote>
<p> 是指示AI大模型需要完成的任务。</p>
</blockquote>
<p>3.上下文（context）</p>
<blockquote>
<p> 当你给出与任务相关的背景或细节时，可以帮助AI大模型更好的理解任务的具体情况，使得输出更加精确。</p>
</blockquote>
<p>4.输入或者问题</p>
<blockquote>
<p> 需要大模型执行具体的任务，或者具体的问题, 有时候如果指令部分描述的是具体的任务时，则指令部分就是输入。</p>
</blockquote>
<p>5.约束</p>
<blockquote>
<p> 有时候需要限制AI大模型的输出范围，设定一些约束条件，可以对输出进行控制。</p>
</blockquote>
<p>6.输出格式：</p>
<blockquote>
<p>主要给大模型指明，输出特定内容时的格式。</p>
</blockquote>
<p>7.例子：</p>
<blockquote>
<p>提供例子可以供AI大模型进行参考，可以有效的提高输出的准确度</p>
</blockquote>
<h2 id="更好的建议"><a href="#更好的建议" class="headerlink" title="更好的建议"></a>更好的建议</h2><ul>
<li><p>如果需求比较复杂，可以将其拆分为几个步骤，逐一提问。</p>
</li>
<li><p>开放式问题往往能够激发更多的想象空间和创造性答案。</p>
</li>
<li><p>在得到AI的回答后，如果不符合预期，可以给出反馈并修正提示词。(训练与测试的过程)</p>
</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="基本模板"><a href="#基本模板" class="headerlink" title="基本模板"></a>基本模板</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 角色设定</span><br><span class="line">你是一位资深流媒体架构师，精通视频传输协议（如HLS/DASH/WebRTC）、媒体编解码（H.264/HEVC/AV1）、CDN优化和实时通信技术。请用分步骤方案解决我的开发问题。</span><br><span class="line"></span><br><span class="line">## 开发背景</span><br><span class="line">当前项目使用[编程语言/框架，如Golang+FFmpeg]开发[具体功能，如低延迟直播系统]，运行在[部署环境，如AWS EC2 g4dn实例]。已实现[现有方案，如基于WebRTC的P2P传输]，但遇到[具体问题描述，如1080p视频在200ms延迟要求下出现5%的丢包率]。</span><br><span class="line"></span><br><span class="line">## 核心需求</span><br><span class="line">1. 优化[具体指标，如端到端延迟]到[目标值，如&lt;200ms]</span><br><span class="line">2. 提升[质量指标，如视频QoE]同时保持[约束条件，如带宽利用率&lt;8Mbps]</span><br><span class="line">3. 解决[具体异常现象，如iOS客户端首帧时间超过2s]</span><br><span class="line"></span><br><span class="line">## 请求格式</span><br><span class="line">请按以下结构给出建议：</span><br><span class="line">1. 诊断分析：可能导致问题的3个技术因素</span><br><span class="line">2. 优化方案：分网络传输、编解码、服务端三个层面的改进措施</span><br><span class="line">3. 配置示例：关键参数的推荐值（如WebRTC的sdp中设置a=goog-latency-experimental:100）</span><br><span class="line">4. 验证方法：建议的AB测试方案或监控指标</span><br><span class="line"></span><br><span class="line">## 补充信息</span><br><span class="line">[相关日志片段/抓包数据特征/硬件配置详情]</span><br></pre></td></tr></table></figure>

<h4 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h4><ol>
<li><strong>技术参数具体化</strong>：避免模糊表述，将”提高画质”改为”在HLS分片时长2s约束下优化SSIM≥0.92”</li>
<li><strong>上下文增强</strong>：附带关键代码段或网络拓扑图描述</li>
<li><strong>渐进式提问</strong>：复杂问题拆分为”协议选型→架构设计→参数调优”多轮对话</li>
<li><strong>验证驱动</strong>：要求AI给出可量化的验证方案（如：建议通过tc命令模拟20%丢包测试抗性）</li>
</ol>
<h3 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">场景：直播卡顿优化（核心需求）</span><br><span class="line">请分析基于NGINX-RTMP的直播系统在万人并发时出现的卡顿问题。当前配置： </span><br><span class="line">- 服务器：8核16G带宽1Gbps</span><br><span class="line">- 客户端观测：20%用户缓冲时间&gt;2s</span><br><span class="line">- 当前CDN配置：静态分片+单源站架构</span><br><span class="line"></span><br><span class="line">期望输出：</span><br><span class="line">1. 瓶颈定位：从协议栈/服务器架构/分发策略角度列出可能瓶颈</span><br><span class="line">2. 扩容方案：推荐边缘节点部署策略及成本估算</span><br><span class="line">3. 自适应码率方案：提供HLS动态分片配置示例</span><br><span class="line">4. 监控建议：关键性能指标的埋点方案</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>AI prompt</tag>
      </tags>
  </entry>
  <entry>
    <title>网络IO复用模型</title>
    <url>/2025/04/21/concurrentServer__Net_IOmodel/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li><strong>什么是网络IO复用？</strong></li>
</ul>
<blockquote>
<p>允许<strong>单个</strong>进程或线程同时监视多个文件描述符（如网络连接）的技术，<strong>只有当其中某个描述符就绪时（可读、可写或发生错误）才进行处理，而不需要为每个连接创建新的进程或线程。</strong></p>
</blockquote>
<ul>
<li><p><strong>为什么出现了网络IO复用技术</strong></p>
<blockquote>
<p>即便多进程服务器创建的子进程在数据传输完成后就会断开连接，并由信号处理函数完成子进程的销毁，但是这期间也可以有多个子进程的创建。而创建多个进程需要大量运算和内存空间，此外由于每个进程都有独立的内存空间，想要相互交换数据就需要IPC，因此需要io复用等技术</p>
<p><strong>io复用并不适用所有情况，需要根据服务器端特性选择</strong></p>
</blockquote>
</li>
</ul>
<span id="more"></span>

<h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p><strong>优点</strong>：兼容性强，linux和windows均可</p>
<p><strong>缺点</strong>：需要轮询监视的文件描述符集合，且文件描述符的变化监视本质还是内核完成，因此发生变化时还需要将事件拷贝到用户态（即存在用户态-内核态-用户态的切换过程），比较消耗资源。</p>
<blockquote>
<p><strong>select实现io复用的步骤：</strong></p>
<p>1.设置文件描述符，指定监视范围，设置超时</p>
<p>2.调用select函数</p>
<p>3.查看调用结果</p>
</blockquote>
<p>关键结构体：<code>fd_set</code> (对应的宏有<code>FD_ZERO(&amp;set), FD_SET(1, &amp;set) </code>)</p>
<p>关键函数：<code>select()</code>函数。select只有在监视的文件描述符发生变化时才会返回，如果未发生变化，就会进入阻塞状态。select判断文件描述符是否发生变化的过程如下，即需要比较变化前后文件描述符对应的值</p>


<p>一个简单的<code>select</code>服务端</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>     <span class="comment">// 标准输入输出</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>    <span class="comment">// 标准库函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>    <span class="comment">// 字符串处理函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>    <span class="comment">// UNIX标准函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span> <span class="comment">// 网络地址转换函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span> <span class="comment">// Socket API</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span>  <span class="comment">// 时间相关函数和结构</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span> <span class="comment">// select函数和相关宏定义</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 100   <span class="comment">// 定义缓冲区大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误处理函数声明</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">char</span> *buf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> serv_sock, clnt_sock;       <span class="comment">// 服务器和客户端socket文件描述符</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_adr, clnt_adr; <span class="comment">// 服务器和客户端地址结构</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timeval</span> timeout;         <span class="comment">// select超时结构</span></span><br><span class="line">    fd_set reads, cpy_reads;        <span class="comment">// 文件描述符集合，用于select</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">socklen_t</span> adr_sz;               <span class="comment">// 地址结构大小</span></span><br><span class="line">    <span class="type">int</span> fd_max, str_len, fd_num, i; <span class="comment">// 最大fd，字符串长度，select返回值，循环变量</span></span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE];             <span class="comment">// 数据缓冲区</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查命令行参数</span></span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建服务器TCP套接字</span></span><br><span class="line">    serv_sock=<span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化服务器地址结构</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family=AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr=<span class="built_in">htonl</span>(INADDR_ANY); <span class="comment">// 接受任意IP地址的连接</span></span><br><span class="line">    serv_adr.sin_port=<span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">1</span>]));     <span class="comment">// 设置端口号为命令行参数提供的值</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 绑定socket到指定地址和端口</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">bind</span>(serv_sock, (<span class="keyword">struct</span> sockaddr*) &amp;serv_adr, <span class="built_in">sizeof</span>(serv_adr))==<span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 开始监听连接请求，队列长度为5</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">listen</span>(serv_sock, <span class="number">5</span>)==<span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;listen() error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化fd_set</span></span><br><span class="line">    <span class="built_in">FD_ZERO</span>(&amp;reads);</span><br><span class="line">    <span class="comment">// 将服务器socket添加到监视列表</span></span><br><span class="line">    <span class="built_in">FD_SET</span>(serv_sock, &amp;reads);</span><br><span class="line">    <span class="comment">// 初始化最大文件描述符</span></span><br><span class="line">    fd_max=serv_sock;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 服务器主循环</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 每次select前复制fd_set，因为select会修改传入的fd_set</span></span><br><span class="line">        cpy_reads=reads;</span><br><span class="line">        <span class="comment">// 设置select超时时间为5.5秒</span></span><br><span class="line">        timeout.tv_sec=<span class="number">5</span>;</span><br><span class="line">        timeout.tv_usec=<span class="number">5000</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用select监视读取事件</span></span><br><span class="line">        <span class="keyword">if</span>((fd_num=<span class="built_in">select</span>(fd_max<span class="number">+1</span>, &amp;cpy_reads, <span class="number">0</span>, <span class="number">0</span>, &amp;timeout))==<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// select出错，退出循环</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 如果超时且没有活动事件，继续下一轮循环</span></span><br><span class="line">        <span class="keyword">if</span>(fd_num==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 遍历所有可能的文件描述符，检查哪些有事件发生</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;fd_max<span class="number">+1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 检查当前文件描述符是否有事件</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(i, &amp;cpy_reads))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果是服务器socket有事件，说明有新的连接请求</span></span><br><span class="line">                <span class="keyword">if</span>(i==serv_sock)    <span class="comment">// 连接请求事件</span></span><br><span class="line">                &#123;</span><br><span class="line">                    adr_sz=<span class="built_in">sizeof</span>(clnt_adr);</span><br><span class="line">                    <span class="comment">// 接受新连接</span></span><br><span class="line">                    clnt_sock=</span><br><span class="line">                        <span class="built_in">accept</span>(serv_sock, (<span class="keyword">struct</span> sockaddr*)&amp;clnt_adr, &amp;adr_sz);</span><br><span class="line">                    <span class="comment">// 将新客户端socket添加到监视列表</span></span><br><span class="line">                    <span class="built_in">FD_SET</span>(clnt_sock, &amp;reads);</span><br><span class="line">                    <span class="comment">// 更新最大文件描述符</span></span><br><span class="line">                    <span class="keyword">if</span>(fd_max&lt;clnt_sock)</span><br><span class="line">                        fd_max=clnt_sock;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;connected client: %d \n&quot;</span>, clnt_sock);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>    <span class="comment">// 客户端发送数据事件</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 读取客户端发送的数据</span></span><br><span class="line">                    str_len=<span class="built_in">read</span>(i, buf, BUF_SIZE);</span><br><span class="line">                    <span class="keyword">if</span>(str_len==<span class="number">0</span>)  <span class="comment">// EOF，客户端关闭连接</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 从监视列表中移除客户端socket</span></span><br><span class="line">                        <span class="built_in">FD_CLR</span>(i, &amp;reads);</span><br><span class="line">                        <span class="comment">// 关闭客户端socket</span></span><br><span class="line">                        <span class="built_in">close</span>(i);</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;closed client: %d \n&quot;</span>, i);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 将收到的数据回显给客户端（echo服务）</span></span><br><span class="line">                        <span class="built_in">write</span>(i, buf, str_len);  <span class="comment">// echo!</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关闭服务器socket（实际上这里很少会执行，因为服务器通常是通过信号终止的）</span></span><br><span class="line">    <span class="built_in">close</span>(serv_sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 错误处理函数，输出错误信息并终止程序</span></span><br><span class="line"><span class="comment"> * @param buf 错误信息字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(buf, stderr);    <span class="comment">// 输出错误信息到标准错误</span></span><br><span class="line">    <span class="built_in">fputc</span>(<span class="string">&#x27;\n&#x27;</span>, stderr);   <span class="comment">// 添加换行符</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);               <span class="comment">// 终止程序，返回状态码1表示错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><p>poll和select区别不大，基本上只有监视集合上的区别</p>
<p>优点：<code>select</code> 使用固定大小的位图数组限制了最大监听 fd 数(最大1024)，<code>poll</code> 使用<strong>可变数组</strong>支持更多 fd（只受限于系统源），且接口更简洁，避免了 <code>select</code> 的 fd_set 限制和繁琐操作。</p>
<p>缺点：<code>poll</code>每次都要重新设置事件数组，不保留状态</p>
<p>一个简单的<code>poll</code>服务端</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">    <span class="comment">// Windows平台特定头文件</span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ws2tcpip.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">int</span> <span class="type">socklen_t</span>;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> CLOSE_SOCKET closesocket</span></span><br><span class="line">    <span class="comment">// WSAPoll函数等同于Linux的poll</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> poll WSAPoll</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">// Linux平台特定头文件</span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> CLOSE_SOCKET close</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> SOCKET int</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> INVALID_SOCKET -1</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> SOCKET_ERROR -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 8889</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_CLIENTS 30</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_platform_specific</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">    <span class="comment">// Windows需要初始化Winsock</span></span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WSAStartup</span>(<span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;WSAStartup 失败\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cleanup_platform_specific</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">    <span class="comment">// Windows需要清理Winsock</span></span><br><span class="line">    <span class="built_in">WSACleanup</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">init_platform_specific</span>();</span><br><span class="line">    </span><br><span class="line">    SOCKET master_socket;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server_addr, client_addr;</span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">    <span class="type">int</span> activity, i, addrlen = <span class="built_in">sizeof</span>(client_addr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建poll使用的结构</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">pollfd</span> fds[MAX_CLIENTS + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> nfds = <span class="number">1</span>;  <span class="comment">// 初始只有主socket</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建主socket</span></span><br><span class="line">    <span class="keyword">if</span> ((master_socket = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == INVALID_SOCKET) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket 创建失败&quot;</span>);</span><br><span class="line">        <span class="built_in">cleanup_platform_specific</span>();</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置socket选项，允许地址重用</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">    <span class="type">char</span> opt = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">setsockopt</span>(master_socket, SOL_SOCKET, SO_REUSEADDR, (<span class="type">const</span> <span class="type">char</span>*)&amp;opt, <span class="built_in">sizeof</span>(opt)) == SOCKET_ERROR) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;setsockopt 失败&quot;</span>);</span><br><span class="line">        <span class="built_in">CLOSE_SOCKET</span>(master_socket);</span><br><span class="line">        <span class="built_in">cleanup_platform_specific</span>();</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 配置服务器地址结构</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    server_addr.sin_port = <span class="built_in">htons</span>(PORT);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 绑定socket</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(master_socket, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="built_in">sizeof</span>(server_addr)) == SOCKET_ERROR) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind 失败&quot;</span>);</span><br><span class="line">        <span class="built_in">CLOSE_SOCKET</span>(master_socket);</span><br><span class="line">        <span class="built_in">cleanup_platform_specific</span>();</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 监听socket，最大连接队列为3</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(master_socket, <span class="number">3</span>) == SOCKET_ERROR) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen 失败&quot;</span>);</span><br><span class="line">        <span class="built_in">CLOSE_SOCKET</span>(master_socket);</span><br><span class="line">        <span class="built_in">cleanup_platform_specific</span>();</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;服务器启动成功，监听端口 %d\n&quot;</span>, PORT);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化fds数组</span></span><br><span class="line">    <span class="built_in">memset</span>(fds, <span class="number">0</span>, <span class="built_in">sizeof</span>(fds));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置主socket到fds[0]</span></span><br><span class="line">    fds[<span class="number">0</span>].fd = master_socket;</span><br><span class="line">    fds[<span class="number">0</span>].events = POLLIN;  <span class="comment">// 监听读事件</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将所有其他fds初始化为-1</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= MAX_CLIENTS; i++) &#123;</span><br><span class="line">        fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 使用poll等待活动</span></span><br><span class="line">        activity = <span class="built_in">poll</span>(fds, nfds, <span class="number">500</span>);  <span class="comment">// 超时500毫秒</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (activity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;poll 错误&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查主socket是否有新连接</span></span><br><span class="line">        <span class="keyword">if</span> (fds[<span class="number">0</span>].revents &amp; POLLIN) &#123;</span><br><span class="line">            SOCKET new_socket;</span><br><span class="line">            <span class="keyword">if</span> ((new_socket = <span class="built_in">accept</span>(master_socket, (<span class="keyword">struct</span> sockaddr*)&amp;client_addr, (<span class="type">socklen_t</span>*)&amp;addrlen)) == INVALID_SOCKET) &#123;</span><br><span class="line">                <span class="built_in">perror</span>(<span class="string">&quot;accept 失败&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;新连接，socket fd: %d, IP: %s, 端口: %d\n&quot;</span>, </span><br><span class="line">                   (<span class="type">int</span>)new_socket, </span><br><span class="line">                   <span class="built_in">inet_ntoa</span>(client_addr.sin_addr), </span><br><span class="line">                   <span class="built_in">ntohs</span>(client_addr.sin_port));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 发送欢迎消息</span></span><br><span class="line">            <span class="type">const</span> <span class="type">char</span>* welcome_message = <span class="string">&quot;欢迎连接到poll服务器\r\n&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">send</span>(new_socket, welcome_message, <span class="built_in">strlen</span>(welcome_message), <span class="number">0</span>) != <span class="built_in">strlen</span>(welcome_message)) &#123;</span><br><span class="line">                <span class="built_in">perror</span>(<span class="string">&quot;send 失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将新socket添加到fds数组</span></span><br><span class="line">            <span class="type">int</span> slot = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= MAX_CLIENTS; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (fds[i].fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    fds[i].fd = new_socket;</span><br><span class="line">                    fds[i].events = POLLIN;  <span class="comment">// 监听读事件</span></span><br><span class="line">                    slot = i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (slot != <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;添加到clients列表，位置: %d\n&quot;</span>, slot);</span><br><span class="line">                <span class="keyword">if</span> (slot &gt;= nfds) &#123;</span><br><span class="line">                    nfds = slot + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;无法添加新连接，服务器已满\n&quot;</span>);</span><br><span class="line">                <span class="built_in">CLOSE_SOCKET</span>(new_socket);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查客户端socket是否有活动</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; nfds; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fds[i].fd &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (fds[i].revents &amp; POLLIN) &#123;</span><br><span class="line">                <span class="built_in">memset</span>(buffer, <span class="number">0</span>, BUFFER_SIZE);</span><br><span class="line">                <span class="type">int</span> valread = <span class="built_in">recv</span>(fds[i].fd, buffer, BUFFER_SIZE, <span class="number">0</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (valread &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 客户端断开连接或错误</span></span><br><span class="line">                    <span class="built_in">getpeername</span>(fds[i].fd, (<span class="keyword">struct</span> sockaddr*)&amp;client_addr, (<span class="type">socklen_t</span>*)&amp;addrlen);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;客户端断开连接，IP: %s, 端口: %d\n&quot;</span>, </span><br><span class="line">                           <span class="built_in">inet_ntoa</span>(client_addr.sin_addr), </span><br><span class="line">                           <span class="built_in">ntohs</span>(client_addr.sin_port));</span><br><span class="line">                    </span><br><span class="line">                    <span class="built_in">CLOSE_SOCKET</span>(fds[i].fd);</span><br><span class="line">                    fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 调整nfds以优化poll调用</span></span><br><span class="line">                    <span class="keyword">if</span> (i == nfds - <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">while</span> (nfds &gt; <span class="number">0</span> &amp;&amp; fds[nfds<span class="number">-1</span>].fd == <span class="number">-1</span>) &#123;</span><br><span class="line">                            nfds--;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 回显消息给客户端</span></span><br><span class="line">                    buffer[valread] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;从客户端接收: %s\n&quot;</span>, buffer);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 简单处理，回显消息</span></span><br><span class="line">                    <span class="type">char</span> response[BUFFER_SIZE + <span class="number">30</span>];</span><br><span class="line">                    <span class="built_in">sprintf</span>(response, <span class="string">&quot;服务器收到: %s&quot;</span>, buffer);</span><br><span class="line">                    <span class="built_in">send</span>(fds[i].fd, response, <span class="built_in">strlen</span>(response), <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关闭所有socket</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nfds; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fds[i].fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">CLOSE_SOCKET</span>(fds[i].fd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cleanup_platform_specific</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p><strong>优点</strong>：epoll的底层实现是一个红黑树+双向链表（还有其它一些底层机制，大体是这两个）。文件描述符的监视是放在内核的红黑树中的，以及发生事件时，会将事件拷贝到就绪队列（双向链表），整个过程用户不参与，用户只需要将发生的事件和文件描述符拷贝就行。</p>
<p>epoll是基于事件驱动的，首先事件发生时，由内核通知，而不用像<code>select</code>和<code>poll</code>那样不断轮询所监视的集合；其次，只用拷贝发生的事件，而不用拷贝整个文件描述符集合。</p>
<p><strong>缺点</strong>：linux特有，其它平台不支持</p>
<p><strong>二个重要接口</strong>：</p>
<ul>
<li><code>epoll_create</code>()</li>
<li><code>epoll_ctl()</code></li>
</ul>
<p><strong>一个结构体</strong>:</p>
<ul>
<li><code>epoll_event</code></li>
</ul>
<p>**水平触发(LT)**：只要输入缓冲(<font color='lightgreen'>创建套接字时，操作系统就会创建一个输入缓冲</font>)还有数据，服务端操作系统就会通知该事件(<strong>注册到发生变化的文件描述符，调用epoll_wait处理通知</strong>)</p>
<p>**边缘触发(ET)**：输入缓冲收到数据只会注册一次该事件（可以给服务器带来高性能），即使输入缓冲还有数据也不会再次注册事件</p>
<p>边缘触发服务端代码实现(linux)：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// epoll_ET_server.c</span></span><br><span class="line"><span class="comment">// 基于边缘触发(Edge Triggered)方式的epoll服务器实现</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 4096        <span class="comment">// 缓冲区大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPOLL_SIZE 50        <span class="comment">// epoll 事件池大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EVENTS 50        <span class="comment">// 单次处理的最大事件数</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误处理函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置文件描述符为非阻塞模式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setnonblocking</span><span class="params">(<span class="type">int</span> fd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> serv_sock, clnt_sock;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr, clnt_addr;</span><br><span class="line">    <span class="type">socklen_t</span> addr_size;</span><br><span class="line">    <span class="type">int</span> str_len, i, j;</span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> *events;        <span class="comment">// 用于接收的事件数组</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> event;          <span class="comment">// 用于注册的事件</span></span><br><span class="line">    <span class="type">int</span> epfd, event_cnt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查命令行参数</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建服务器套接字</span></span><br><span class="line">    serv_sock = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (serv_sock == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置地址重用选项</span></span><br><span class="line">    <span class="type">int</span> option = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">setsockopt</span>(serv_sock, SOL_SOCKET, SO_REUSEADDR, &amp;option, <span class="built_in">sizeof</span>(option));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化服务器地址结构</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">1</span>]));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 绑定套接字</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(serv_sock, (<span class="keyword">struct</span> sockaddr *)&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置监听</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(serv_sock, <span class="number">5</span>) == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;listen() error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建epoll实例</span></span><br><span class="line">    epfd = <span class="built_in">epoll_create</span>(EPOLL_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (epfd == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;epoll_create() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配events数组空间</span></span><br><span class="line">    events = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> epoll_event) * MAX_EVENTS);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置服务器套接字为非阻塞模式</span></span><br><span class="line">    <span class="built_in">setnonblocking</span>(serv_sock);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 向epoll注册服务器套接字事件</span></span><br><span class="line">    event.events = EPOLLIN;      <span class="comment">// 使用水平触发模式监听服务器套接字</span></span><br><span class="line">    event.data.fd = serv_sock;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, serv_sock, &amp;event);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Server started. Waiting for connections...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主循环</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 等待事件发生</span></span><br><span class="line">        event_cnt = <span class="built_in">epoll_wait</span>(epfd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (event_cnt == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">error_handling</span>(<span class="string">&quot;epoll_wait() error&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理所有就绪的事件</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; event_cnt; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (events[i].data.fd == serv_sock) &#123;  <span class="comment">// 新的客户端连接</span></span><br><span class="line">                addr_size = <span class="built_in">sizeof</span>(clnt_addr);</span><br><span class="line">                clnt_sock = <span class="built_in">accept</span>(serv_sock, (<span class="keyword">struct</span> sockaddr *)&amp;clnt_addr, &amp;addr_size);</span><br><span class="line">                <span class="keyword">if</span> (clnt_sock == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;accept() error\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 设置客户端套接字为非阻塞模式</span></span><br><span class="line">                <span class="built_in">setnonblocking</span>(clnt_sock);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 向epoll注册客户端套接字，使用边缘触发模式</span></span><br><span class="line">                event.events = EPOLLIN | EPOLLET;  <span class="comment">// 边缘触发模式</span></span><br><span class="line">                event.data.fd = clnt_sock;</span><br><span class="line">                <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, clnt_sock, &amp;event);</span><br><span class="line">                </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Connected client: %d\n&quot;</span>, clnt_sock);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 已有客户端的数据就绪</span></span><br><span class="line">                <span class="comment">// 使用循环读取数据，直到没有数据为止 (边缘触发模式必须)</span></span><br><span class="line">                <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                    str_len = <span class="built_in">read</span>(events[i].data.fd, buf, BUF_SIZE);</span><br><span class="line">                    <span class="keyword">if</span> (str_len == <span class="number">0</span>) &#123;  <span class="comment">// 客户端关闭连接</span></span><br><span class="line">                        <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_DEL, events[i].data.fd, <span class="literal">NULL</span>);</span><br><span class="line">                        <span class="built_in">close</span>(events[i].data.fd);</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;Closed client: %d\n&quot;</span>, events[i].data.fd);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str_len &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (errno == EAGAIN || errno == EWOULDBLOCK) &#123;</span><br><span class="line">                            <span class="comment">// 没有更多数据可读，退出读取循环</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="built_in">error_handling</span>(<span class="string">&quot;read() error&quot;</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 有数据，进行回显</span></span><br><span class="line">                        <span class="comment">// 实际应用中，这里可能需要使用循环确保写入所有数据</span></span><br><span class="line">                        <span class="built_in">write</span>(events[i].data.fd, buf, str_len);</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;Echoed %d bytes to client %d\n&quot;</span>, str_len, events[i].data.fd);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="built_in">close</span>(serv_sock);</span><br><span class="line">    <span class="built_in">close</span>(epfd);</span><br><span class="line">    <span class="built_in">free</span>(events);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置文件描述符为非阻塞模式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setnonblocking</span><span class="params">(<span class="type">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> flags = <span class="built_in">fcntl</span>(fd, F_GETFL, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">fcntl</span>(fd, F_SETFL, flags | O_NONBLOCK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误处理函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, stderr);</span><br><span class="line">    <span class="built_in">fputc</span>(<span class="string">&#x27;\n&#x27;</span>, stderr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>高并发</category>
        <category>网络IO复用</category>
      </categories>
  </entry>
  <entry>
    <title>linux常用命令总结</title>
    <url>/2025/02/23/linux_BasicShellCmd/</url>
    <content><![CDATA[<p>总结了一些linux中常用的基本命令和项目中常用的命令</p>
<span id="more"></span>

<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><ul>
<li>shell ：即命令解释器，是用户和linux内核交互的桥梁，通过在shell终端输入命令让linux内核相应部分识别用户命令并处理。</li>
</ul>
<p>​	shell命令的基本格式为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">命令 [option] 参数 </span><br></pre></td></tr></table></figure>
<p>​	其中加”[]”符号表示可以不输入这个选项</p>
<p><strong>tips</strong>: </p>
<ul>
<li><p>对于不熟悉的命令可以使用<code>man 1 命令</code>或者<code>命令 --help</code>来查看说明</p>
</li>
<li><p>注意如果想要在windows复制并粘贴到linux虚拟机中，就要安装open-vm-tools，而vm-tools是老版的，重复安装这两个就会冲突，所以只安装open-vm-tools即可。对应命令为：</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install open-vm-tools-desktop</span><br></pre></td></tr></table></figure>

<p>​	以下给出几个vm-tools的区别</p>
<blockquote>
<p><strong>open-vm-tools</strong>：开源工具集，主要用于 Linux 虚拟机。</p>
<p><strong>vm-tools</strong>：VMware 提供的专有工具集，通常用于 VMware 产品。</p>
<p><strong>open-vm-tools-desktop</strong>：<code>open-vm-tools</code> 的桌面扩展版，专为桌面环境（有图形界面的 Linux）优化，提供更多图形相关的功能。</p>
</blockquote>
<p>linux磁盘相关文件系统，扩容等：<a href="https://blog.csdn.net/zhanhjxxx/article/details/123232402">Linux磁盘分区详解（新建分区，现有分区扩容，分区减容）_linux分区-CSDN博客</a></p>
<h2 id="基本常用命令"><a href="#基本常用命令" class="headerlink" title="基本常用命令"></a>基本常用命令</h2><ol>
<li>切换用户权限组</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo su //切换为管理员</span><br><span class="line">exit //推出管理员权限</span><br></pre></td></tr></table></figure>

<p>在命令前加<code>sudo</code>也可以使用管理员权限</p>
<ol start="2">
<li>创建目录</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -m 目录名</span><br><span class="line">mkdir -r /home/hh # -r 可以递归的创建目录</span><br></pre></td></tr></table></figure>

<p>3.删除目录或者文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -i 文件名</span><br><span class="line">rm -r 目录名 #主要用来删除目录</span><br><span class="line">rm -f 文件名 #强制删除</span><br></pre></td></tr></table></figure>

<p>4.切换路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /  #切换到根目录</span><br><span class="line">cd ~  #切换到家目录</span><br><span class="line">cd /home/xxx  </span><br></pre></td></tr></table></figure>

<p>5.gedit 记事本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gedit main.c</span><br></pre></td></tr></table></figure>

<p>6.查看文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat main.c #查看文件内容并输出到shell终端</span><br><span class="line">cat -A 文件名  #隐藏的字符也可以查看</span><br></pre></td></tr></table></figure>

<p>7.复制</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp -r 源文件 目标文件 #可以复制目录的所有文件</span><br></pre></td></tr></table></figure>

<p>8.移动或重命名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv [选项] 源文件 目标文件</span><br><span class="line">mv old.txt new.txt #重命名单个文件</span><br><span class="line">mv old_folder new_folder #重命名目录</span><br><span class="line">mv file.txt /home/user/documents/newfile.txt #移动文件到其他目录并重命名</span><br></pre></td></tr></table></figure>

<p>9.查看当前路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></table></figure>

<p>10.查看当前目录文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls [option]</span><br><span class="line">ls -a #查看所有文件，包括隐藏的</span><br></pre></td></tr></table></figure>

<ol start="11">
<li>显示磁盘空间使用情况</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">df -h</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="项目常用命令"><a href="#项目常用命令" class="headerlink" title="项目常用命令"></a>项目常用命令</h2><ul>
<li>解压缩</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf xx.tar.gz # 解压缩tar.gz文件，x为提取，v为详细信息，f即file</span><br></pre></td></tr></table></figure>

<ul>
<li>查看进程</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps au #查看所有进程</span><br><span class="line">ps aux|grep xx*</span><br></pre></td></tr></table></figure>

<ul>
<li>查找文件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">基本语法：find 搜索路径 选项 表达式</span></span><br><span class="line">find /path/to/search -name &quot;filename&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在当前目录及子目录查找名为<span class="string">&quot;example.txt&quot;</span>的文件</span></span><br><span class="line">find . -name &quot;example.txt&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用通配符查找所有.<span class="built_in">log</span>文件</span></span><br><span class="line">find /var/log -name &quot;*.log&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找指定用户拥有的文件</span></span><br><span class="line">find /home -user username</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找过去7天内修改的文件</span></span><br><span class="line">find /home/user -mtime -7</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用 find 命令查找最近修改的文件</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果你刚刚安装了软件，可以查找系统中最近被修改的文件：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找过去30分钟内修改的文件</span></span><br><span class="line">sudo find / -type f -mmin -30 2&gt;/dev/null</span><br></pre></td></tr></table></figure>

<p>查找文件还可以使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">whereis xx</span><br></pre></td></tr></table></figure>

<ul>
<li>安装软件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i 文件名.deb #安装的默认路径为：/opt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看 dpkg 日志找出最近安装的包</span></span><br><span class="line">grep &quot;install &quot; /var/log/dpkg.log | tail</span><br></pre></td></tr></table></figure>

<ul>
<li>挂载共享文件夹</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mount -t fuse.vmhgfs-fuse .host:/ /mnt/hgfs -o allow_other</span><br></pre></td></tr></table></figure>

<p>开机自动挂载共享文件夹参考下图：</p>
<img src="/2025/02/23/linux_BasicShellCmd/image-20250302110137834.png" class="" title="image-20250302110137834">

<ul>
<li>安装和卸载</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install </span><br><span class="line">apt-get autoremove </span><br></pre></td></tr></table></figure>

<ul>
<li>编译和链接</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">编译c源码,以创建线程为例</span></span><br><span class="line">gcc thread1.c -o trl -lphread</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>gcc</code>: GNU编译器集合(GNU Compiler Collection)，这是一个常用的C&#x2F;C++编译器</p>
<p><code>thread1.c</code>: 源代码文件名，这是要被编译的C语言源文件</p>
<p><code>-o tr1</code>: 输出选项，指定编译后生成的可执行文件名为”tr1”</p>
<p><code>-lpthread</code>: 链接选项，告诉编译器链接POSIX线程库(pthread库)</p>
<p><strong>为什么要链接</strong>：</p>
<ul>
<li>当编译器看到你的代码引用了 pthread 库中的函数时，它需要知道这些函数的实现在哪里</li>
<li><code>-lpthread</code> 告诉链接器去寻找并链接 pthread 库</li>
<li>如果不链接这个库，链接器会报”未定义的引用”(undefined reference)错误</li>
</ul>
<p><strong>具体作用</strong></p>
<ul>
<li><code>-l</code> 是链接库的标志</li>
<li><code>pthread</code> 是库的名称（省略了前缀”lib”和后缀”.so”或”.a”）</li>
<li>实际上链接器会寻找 <code>libpthread.so</code>（共享库）或 <code>libpthread.a</code>（静态库）文件</li>
</ul>
</blockquote>
<ul>
<li><p>软链接</p>
<p>作用1：允许从不同位置访问同一个文件或目录，而不需要复制数据，相当于创建快捷方式</p>
<p>作用2：，比如先转移文件到其它目录，再删除原路径的文件，这时创建一个软链接，确保依赖于旧路径的程序继续正常工作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果已有Downloads目录且有内容，先移动</span></span><br><span class="line">mv ~/Downloads/* /data/Downloads/ # 仅当Downloads有内容时</span><br><span class="line">rm -rf ~/Downloads # 删除原Downloads目录</span><br><span class="line">ln -s /data/Downloads ~/Downloads # 创建软链接</span><br></pre></td></tr></table></figure>

</li>
<li><p>网络相关</p>
<ul>
<li>查看网络的配置和状态</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure>

<ul>
<li>查看 socket、网络协议栈、网口以及路由表的信息</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-n表示以数字方式显示ip和端口</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-l表示只显示listen状态的socket</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-p表示显示进程信息</span></span><br><span class="line">netstat -nlp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#######################################</span></span></span><br><span class="line">ss -ntlp</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-n表示以数字方式显示ip和端口</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-t表示只显示tcp连接</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-l表示只显示listen状态的socket</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-p表示显示进程信息</span></span><br></pre></td></tr></table></figure>

<ul>
<li>查看协议栈的统计信息</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -s</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##或者</span></span></span><br><span class="line">ss -s</span><br></pre></td></tr></table></figure>

<ul>
<li><p>查看网络吞吐率和pps</p>
<blockquote>
<p><strong>网络吞吐率</strong>：单位事件内成功传输的数据量</p>
<p><strong>pps</strong>：packet per second</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sar -n DEV  #显示网口的统计数据</span><br><span class="line">sar -n EDEV	#显示关于网络错误的统计数据</span><br><span class="line">sar -n TCP	#显示 TCP 的统计数据</span><br><span class="line">ethtool eth0 | grep Speed	#查看eth0网卡带宽，单位为Mb/s</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
</li>
</ul>
<p>​	</p>
]]></content>
      <categories>
        <category>linux</category>
        <category>shell命令</category>
      </categories>
  </entry>
  <entry>
    <title>智能指针</title>
    <url>/2025/03/10/Cpp11__smart_ptr/</url>
    <content><![CDATA[<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p><strong>c++11之后引入智能指针的目的</strong>：动态分配的内存空间如果不进行释放，就会导致内存泄露。智能指针是一个模板类，其离开作用域时就会销毁，这时就会调用其析构函数来释放所指向的动态分配对象的空间。<font color='red'>即智能指针就是用来解决内存泄露问题的。</font></p>
<p>本文重在实现简化版的智能指针的模板类，其它概念不多介绍。</p>
<p>阅读前请确保已了解右值引用和移动语义相关知识。</p>
<span id="more"></span>

<h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><p><strong>shared_ptr和其指向的动态分配对象可以实现多对一，即可以多个shared_ptr指向同一个动态分配的对象。</strong></p>
<p>​	<strong>首先需要列出实现的内容：</strong></p>
<ul>
<li>构造函数(默认构造函数，有参构造函数，拷贝构造函数)</li>
<li>析构函数</li>
<li>赋值运算符”&#x3D;”的重载</li>
<li>operator * 的重载</li>
<li>operator -&gt; 的重载</li>
<li>指向动态分配对象的原始指针<code>m_ptr</code></li>
<li>引用计数指针<code>m_count</code></li>
<li>成员函数get(), reset(), use_count()</li>
<li>make_shared函数模板</li>
</ul>
<img src="Cpp11__inteligent_ptr/image-20250310211607484.png" alt="image-20250310211607484" style="zoom:50%;" />

<blockquote>
<p><strong>为什么图中使用<code>int* m_count</code>而不是<code>int m_count</code>?</strong></p>
<p><strong>答：为了共享引用计数值</strong></p>
<p><strong>更具体的</strong>：使用指针m_count而不是整型m_count保证了不同的shared_ptr可以指向同一个引用计数值(因为m_count的地址值是一样的)。如果每个<code>shared_ptr</code>实例都有自己的<code>int m_count</code>成员变量，那么当一个实例增加或减少计数时，其他实例不会知道这个变化。</p>
</blockquote>
<h4 id="具体代码实现"><a href="#具体代码实现" class="headerlink" title="具体代码实现"></a>具体代码实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*	</span></span><br><span class="line"><span class="comment">	shared_ptr.h</span></span><br><span class="line"><span class="comment">	实现一个简化版的shared_ptr模板类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SHARED_PTR_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHARED_PTR_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySharedPtr</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//指向动态分配对象的原始指针</span></span><br><span class="line">	T* m_ptr;	</span><br><span class="line">	<span class="comment">//共享的引用计数指针</span></span><br><span class="line">	<span class="type">int</span>* m_count;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//释放函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//注意要保证已经指向了动态对象，即m_count不为空</span></span><br><span class="line">		<span class="keyword">if</span> (m_count) &#123;</span><br><span class="line">			--(*m_count);</span><br><span class="line">			<span class="comment">//只有引用计数为0，才释放管理的对象内存空间</span></span><br><span class="line">			<span class="keyword">if</span> ((*m_count) == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">delete</span> m_ptr;</span><br><span class="line">				<span class="keyword">delete</span> m_count;</span><br><span class="line">				m_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">				m_count = <span class="literal">nullptr</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//默认构造函数</span></span><br><span class="line">	<span class="built_in">MySharedPtr</span>(): <span class="built_in">m_ptr</span>(<span class="literal">nullptr</span>), <span class="built_in">m_count</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//有参构造函数,最好使用显式构造，避免出现在栈区隐式调用智能指针构造函数，导致智能指针提前销毁</span></span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">MySharedPtr</span><span class="params">(T* ptr)</span>: m_ptr(ptr), m_count(new int(<span class="number">1</span>)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//拷贝构造函数</span></span><br><span class="line">	<span class="comment">//MySharedptr&lt;T&gt; p2(p1);</span></span><br><span class="line">	<span class="built_in">MySharedPtr</span>(<span class="type">const</span> MySharedPtr &amp;other): <span class="built_in">m_ptr</span>(other.m_ptr), <span class="built_in">m_count</span>(other.m_count) &#123;</span><br><span class="line">		<span class="comment">//引用计数加1</span></span><br><span class="line">		<span class="keyword">if</span> (m_count) &#123;</span><br><span class="line">			++(*m_count);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//析构函数</span></span><br><span class="line">	~<span class="built_in">MySharedPtr</span>() &#123;</span><br><span class="line">		<span class="built_in">release</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//赋值运算符&quot;=&quot;重载</span></span><br><span class="line">	<span class="comment">//MySharedptr&lt;T&gt; p2 = p1; 不能给shared_ptr赋裸指针的原因</span></span><br><span class="line">	MySharedPtr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MySharedPtr &amp;other) &#123;</span><br><span class="line">		<span class="comment">//other这里是个实例,而this是指向p2的指针，所以要加个&quot;&amp;&quot;</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">			<span class="built_in">release</span>();</span><br><span class="line">			m_ptr = other.m_ptr;</span><br><span class="line">			m_count = other.m_count;</span><br><span class="line">			<span class="keyword">if</span> (m_count) &#123;</span><br><span class="line">				++(*m_count);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//解引用&quot;*&quot;的重载</span></span><br><span class="line">	T&amp; <span class="keyword">operator</span>*() &#123;</span><br><span class="line">		<span class="keyword">return</span> *m_ptr; <span class="comment">//返回管理的对象</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//&quot;-&gt;&quot;的重载</span></span><br><span class="line">	T* <span class="keyword">operator</span>-&gt;() &#123;</span><br><span class="line">		<span class="keyword">return</span> m_ptr; </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//reset函数</span></span><br><span class="line">	<span class="comment">//重置指针，如果调用该函数的shared_ptr对象没有初始化且ptr不为空则让裸指针指向动态对象，并将引用计数加1</span></span><br><span class="line">	<span class="comment">//如果shared_ptr对象已经初始化，则根据reset是否传参：即ptr有值则重新指向该对象；ptr为空，则让引用计数减1</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(T* ptr = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (m_ptr != ptr) &#123;</span><br><span class="line">			<span class="built_in">release</span>();</span><br><span class="line">			<span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">				m_ptr = ptr;</span><br><span class="line">				++(*m_count);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//get函数,获取原始指针</span></span><br><span class="line">	<span class="function">T* <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_ptr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//use_count函数，返回引用计数的值</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">use_count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//注意管理对象可以已经销毁再调用use_count查看的</span></span><br><span class="line">		<span class="keyword">return</span> m_count ? *m_count : <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//make_shared&lt;T&gt;() 函数模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">MySharedPtr&lt;T&gt; <span class="title">make_shared</span><span class="params">(Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//std::forward&lt;&gt; 在模板代码中用于完美转发</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">MySharedPtr</span>&lt;T&gt;(<span class="keyword">new</span> <span class="built_in">T</span>(std::forward&lt;Args&gt;(args)...)); <span class="comment">//有参构造</span></span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br></pre></td></tr></table></figure>

<p>测试函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;shared_ptr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">/****************shared_ptr的测试*******************************/</span></span><br><span class="line">	<span class="comment">/*测试简化版的shared_ptr模板类*/</span></span><br><span class="line">	<span class="function">MySharedPtr&lt;<span class="type">int</span>&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">50</span>))</span></span>;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;the use_count: &quot;</span> &lt;&lt; sp<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;sp1: &quot;</span> &lt;&lt; *sp1 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//测试赋值运算重载</span></span><br><span class="line">	MySharedPtr&lt;<span class="type">int</span>&gt; sp2 = sp1; </span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;After copy, use_count(): &quot;</span> &lt;&lt; sp<span class="number">2.</span><span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 修改值</span></span><br><span class="line">	*sp1 = <span class="number">100</span>;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;*the value of sp2: &quot;</span> &lt;&lt; *sp2 &lt;&lt; std::endl;  <span class="comment">// sp2也会看到更改</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用make_shared</span></span><br><span class="line">	<span class="keyword">auto</span> sp3 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">200</span>);</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;*sp3: &quot;</span> &lt;&lt; *sp3 &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;after sp3,  use_count of sp3 &quot;</span> &lt;&lt; sp<span class="number">3.</span><span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;after sp3, use_count of sp2,sp1 &quot;</span> &lt;&lt; sp<span class="number">2.</span><span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重置指针</span></span><br><span class="line">	sp<span class="number">1.</span><span class="built_in">reset</span>();</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;After sp1.reset(), sp2.use_count(): &quot;</span> &lt;&lt; sp<span class="number">2.</span><span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/****************shared_ptr测试函数到此结束***********************/</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">the use_count: 1</span><br><span class="line">sp1: 50</span><br><span class="line">After copy, use_count(): 2</span><br><span class="line">*the value of sp2: 100</span><br><span class="line">*sp3: 200</span><br><span class="line">after sp3,  use_count of sp3 1</span><br><span class="line">after sp3, use_count of sp2,sp1 2</span><br><span class="line">After sp1.reset(), sp2.use_count(): 1</span><br></pre></td></tr></table></figure>

<h4 id="难点以及“坑”解析"><a href="#难点以及“坑”解析" class="headerlink" title="难点以及“坑”解析"></a>难点以及“坑”解析</h4><ul>
<li><p>一、<strong>释放函数release必须要先判断引用计数指针m_count是否为空！</strong></p>
</li>
<li><p>二、<strong>赋值运算符重载这里需要考虑如下情况</strong></p>
<ul>
<li>1.<font color='mediumseagreen'>如果不加this !&#x3D; &amp;other</font></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">SharedPtr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">p1 = p1;  <span class="comment">// ❌ 如果没有 this != &amp;other，p1 可能释放掉自己正在管理的资源</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>2.<font color='mediumseagreen'>为什么先release()减少引用计数，而不是直接给赋值，并增加引用计数</font></p>
<p>如下假如不先执行release()</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">    m_ptr = other.m_ptr;</span><br><span class="line">    m_count = other.m_count;</span><br><span class="line">    <span class="keyword">if</span> (m_count) &#123;</span><br><span class="line">        ++(*m_count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	那么如果测试函数中出现如下情况，<font color='red'>则会导致p2原来指向的动态对象空间int(20)永远不会被释放，导致内存泄露</font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">MySharedPtr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;  <span class="comment">// p1: *m_count = 1</span></span><br><span class="line"><span class="function">MySharedPtr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">20</span>))</span></span>;  <span class="comment">// p2: *m_count = 1</span></span><br><span class="line">p2 = p1;  <span class="comment">// p2 放弃原来的对象，指向 p1 的对象</span></span><br></pre></td></tr></table></figure>

<p>​	正常的MySharedPtr赋值如下：</p>
<blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">MySharedPtr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;  <span class="comment">// p1: *m_count = 1</span></span><br><span class="line">MySharedPtr&lt;<span class="type">int</span>&gt; p2;  <span class="comment">// p2 为空，m_count = nullptr</span></span><br><span class="line">p2 = p1;  <span class="comment">// p2 变成 p1 的拷贝</span></span><br></pre></td></tr></table></figure>

<p><strong>步骤解析：</strong></p>
<p><code>p2.release();</code> <strong>不会释放任何东西</strong>（因为 <code>p2</code> 为空）。</p>
<p><code>p2.m_ptr = p1.m_ptr;</code>（指向相同对象）</p>
<p><code>p2.m_count = p1.m_count;</code>（共享相同引用计数）</p>
<p><code>++(*p2.m_count);</code>  引用计数 <code>1 → 2</code>。</p>
</blockquote>
<ul>
<li>3.<font color='mediumseagreen'>返回类型为该模板类<code>*this</code>的引用</font></li>
</ul>
<blockquote>
<p>这里这么做的作用主要是如果函数返回类型不加引用，那么实际上返回值是一个拷贝了原对象<code>*this</code>的新智能指针p2’，在需要<strong>链式编程</strong>的场景下就不可行了，所以我们直接加引用“&amp;”返回原对象即可。</p>
</blockquote>
</li>
<li><p>三、<strong>有参构造函数要加explicit关键字，保证是显式构造</strong></p>
<blockquote>
<p>如果没有 <code>explicit</code> 关键字，以下代码将被允许：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(SharedPtr&lt;<span class="type">int</span>&gt; ptr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 ptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* rawPtr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">func</span>(rawPtr);  <span class="comment">// 编译器会隐式地将 rawPtr 转换为 SharedPtr&lt;int&gt;</span></span><br><span class="line">    <span class="comment">// 可能导致内存泄漏，因为 func 结束后，临时创建的 SharedPtr 被销毁，会释放 rawPtr</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<p>补充：</p>
<blockquote>
<p>在 C++ 中，<code>const</code> 限定符有几个重要的用途：</p>
<ol>
<li><strong>保证接口安全</strong>：当函数声明为 <code>const</code> 时（例如 <code>T* get() const</code>），它承诺不会修改对象的状态。这使调用者知道调用该函数是安全的，不会改变对象的内部数据。</li>
<li><strong>编译时检查</strong>：编译器会检查并阻止在 <code>const</code> 方法中对对象成员变量的修改，这有助于防止意外的数据修改。</li>
<li><strong>更广泛的使用场景</strong>：<code>const</code> 方法可以被 <code>const</code> 对象和非 <code>const</code> 对象调用，而非 <code>const</code> 方法只能被非 <code>const</code> 对象调用。这增加了类的灵活性。</li>
<li><strong>代码自文档化</strong>：<code>const</code> 关键字明确告诉其他开发者哪些操作不会修改对象状态，增强了代码的可读性和可维护性。</li>
<li><strong>编译器优化</strong>：编译器可以对 <code>const</code> 方法进行更积极的优化，因为它知道这些方法不会修改对象状态。</li>
</ol>
</blockquote>
<p>此外，<font color='red'>还需注意标准库中的shared_ptr的reset函数在智能指针对象指向了动态分配对象的前提下使用且不传参，引用计数减1的同时，还会销毁该对象</font></p>
<h4 id="线程安全的引用计数"><a href="#线程安全的引用计数" class="headerlink" title="线程安全的引用计数"></a>线程安全的引用计数</h4><p><strong>注意在shared_ptr中引用计数是线程安全的，但是管理的数据不是线程安全的</strong>。我们上面的实现并不能保证引用计数是线程安全的，因为多个线程可能同时操作引用计数指针<code>m_count</code>，导致动态对象被提前释放或永远不被释放。</p>
<p>下面将采用互斥锁来实现引用计数线程安全（可以参考下图实现，这里我们就不考虑weak_count了）</p>
<img src="Cpp11__inteligent_ptr/image-20250310221101442.png" alt="image-20250310221101442" style="zoom:50%;" />

<p>具体代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* shared_ptr.h</span></span><br><span class="line"><span class="comment">* 实现一个线程安全的shared_ptr模板类，不考虑weak_ptr</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SHARED_PTR_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHARED_PTR_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySharedPtr</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 控制块结构</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ControlBlock</span> &#123;</span><br><span class="line">        <span class="type">int</span> ref_count; <span class="comment">// 引用计数</span></span><br><span class="line">        std::mutex mutex; <span class="comment">// 互斥锁，保证线程安全</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">        <span class="built_in">ControlBlock</span>() : <span class="built_in">ref_count</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向管理对象的原始指针</span></span><br><span class="line">    T* raw_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向控制块的指针</span></span><br><span class="line">    ControlBlock* control_block;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加引用计数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add_count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (control_block) &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(control_block-&gt;mutex)</span></span>;</span><br><span class="line">            ++(control_block-&gt;ref_count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 减少引用计数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sub_count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (control_block) &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(control_block-&gt;mutex)</span></span>;</span><br><span class="line">            --(control_block-&gt;ref_count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (control_block) &#123;</span><br><span class="line">            <span class="built_in">sub_count</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查是否为最后一个引用</span></span><br><span class="line">            <span class="type">bool</span> delete_resources = <span class="literal">false</span>;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(control_block-&gt;mutex)</span></span>;</span><br><span class="line">                delete_resources = (control_block-&gt;ref_count == <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 只有当引用计数为零时才删除资源</span></span><br><span class="line">            <span class="keyword">if</span> (delete_resources) &#123;</span><br><span class="line">                <span class="keyword">delete</span> raw_ptr;</span><br><span class="line">                <span class="keyword">delete</span> control_block;</span><br><span class="line">                raw_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">                control_block = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">MySharedPtr</span>() : <span class="built_in">raw_ptr</span>(<span class="literal">nullptr</span>), <span class="built_in">control_block</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有参构造，从原始指针构造</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MySharedPtr</span><span class="params">(T* ptr)</span>: raw_ptr(ptr), control_block(ptr ? new ControlBlock() : nullptr) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MySharedPtr</span>(<span class="type">const</span> MySharedPtr&amp; other): <span class="built_in">raw_ptr</span>(other.raw_ptr), <span class="built_in">control_block</span>(other.control_block) &#123;</span><br><span class="line">        <span class="built_in">add_count</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">MySharedPtr</span>(MySharedPtr&amp;&amp; other) <span class="keyword">noexcept</span>: <span class="built_in">raw_ptr</span>(other.raw_ptr), <span class="built_in">control_block</span>(other.control_block) &#123;</span><br><span class="line">        other.raw_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        other.control_block = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">MySharedPtr</span>() &#123;</span><br><span class="line">        <span class="built_in">release</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝赋值运算符重载</span></span><br><span class="line">    <span class="comment">//这里不能给shared_ptr赋裸指针</span></span><br><span class="line">    MySharedPtr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MySharedPtr&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="built_in">release</span>();</span><br><span class="line">            raw_ptr = other.raw_ptr;</span><br><span class="line">            control_block = other.control_block;</span><br><span class="line">            <span class="built_in">add_count</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动赋值运算符重载</span></span><br><span class="line">    MySharedPtr&amp; <span class="keyword">operator</span>=(MySharedPtr&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="built_in">release</span>();</span><br><span class="line">            raw_ptr = other.raw_ptr;</span><br><span class="line">            control_block = other.control_block;</span><br><span class="line">            other.raw_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">            other.control_block = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解引用运算符重载</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> *raw_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 箭头运算符重载</span></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> raw_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(T* ptr = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (raw_ptr != ptr) &#123;</span><br><span class="line">            <span class="built_in">release</span>();</span><br><span class="line">            <span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">                raw_ptr = ptr;</span><br><span class="line">                control_block = <span class="keyword">new</span> <span class="built_in">ControlBlock</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取原始指针</span></span><br><span class="line">    <span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> raw_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取引用计数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">use_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (control_block) &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(control_block-&gt;mutex)</span></span>;</span><br><span class="line">            <span class="keyword">return</span> control_block-&gt;ref_count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查指针是否是唯一拥有者（只有一个引用）</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">unique</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">use_count</span>() == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// make_shared函数模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">MySharedPtr&lt;T&gt; <span class="title">make_shared</span><span class="params">(Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">MySharedPtr</span>&lt;T&gt;(<span class="keyword">new</span> <span class="built_in">T</span>(std::forward&lt;Args&gt;(args)...));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>同样的测试用例下，代码无误</p>
<h4 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h4><h5 id="1-为什么make-shared创建shared-ptr会比shared-ptr-p-new-int-更优"><a href="#1-为什么make-shared创建shared-ptr会比shared-ptr-p-new-int-更优" class="headerlink" title="1.为什么make_shared&lt;int&gt;创建shared_ptr会比shared_ptr&lt;int&gt; p(new int())更优"></a>1.为什么<code>make_shared&lt;int&gt;</code>创建shared_ptr会比<code>shared_ptr&lt;int&gt; p(new int())</code>更优</h5><blockquote>
<p>简单来说就是make_shared内存分配效率更高(性能更好)，安全性更好，代码可读性更强</p>
<p>具体的：</p>
<p>（1）性能更优</p>
<p><code>std::make_shared&lt;T&gt;(...)</code> 在堆上只分配 <strong>一次内存</strong>，而 <code>std::shared_ptr&lt;T&gt;(new T(...))</code> 会进行 <strong>两次分配</strong>：</p>
<ul>
<li><code>make_shared</code> 会把 <strong>引用计数控制块</strong> 和 <strong>实际对象 T</strong> 一起分配在一块连续的内存中。</li>
<li>而 <code>shared_ptr&lt;T&gt;(new T(...))</code> 会先分配对象的内存，再分配引用计数控制块的内存。</li>
</ul>
<p>（2）安全性更好</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> Widget(), custom_deleter)</span></span>;</span><br></pre></td></tr></table></figure>

<p>如果 <code>new Widget()</code> 和 <code>custom_deleter</code> 之间抛异常，<code>Widget</code> 的指针就泄露了（因为 <code>shared_ptr</code> 构造尚未完成）。</p>
<p>而 <code>make_shared</code> 是原子操作，整个过程由内部管理，不存在这种中间状态导致的泄漏问题。</p>
<p>(3) 代码可读性更强</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = std::<span class="built_in">make_shared</span>&lt;MyClass&gt;(arg1, arg2);  <span class="comment">// 简洁明了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> p = std::<span class="built_in">shared_ptr</span>&lt;MyClass&gt;(<span class="keyword">new</span> <span class="built_in">MyClass</span>(arg1, arg2));  <span class="comment">// 啰嗦且容易出错</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="2-完美转发std-forward"><a href="#2-完美转发std-forward" class="headerlink" title="2.完美转发std::forward"></a>2.完美转发<code>std::forward</code></h5><blockquote>
<p>完美转发是C++11引入的一个重要概念，它允许我们在不损失任何参数信息（包括值类别、const修饰等）的情况下，将参数从一个函数传递到另一个函数。这在编写模板代码和通用包装函数时特别有用。</p>
<p><font color='cornflowerblue'>为什么需要完美转发？</font></p>
<p>在没有完美转发之前，我们面临一个困境：</p>
<ol>
<li>如果函数参数用值传递，会产生不必要的拷贝</li>
<li>如果使用const引用，无法传递可修改的引用</li>
<li>如果使用非const引用，无法接受临时对象或常量</li>
</ol>
<p>考虑这个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper</span><span class="params">(T&amp; param)</span> </span>&#123;  <span class="comment">// 非const引用</span></span><br><span class="line">    <span class="built_in">f</span>(param);  <span class="comment">// 调用目标函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个<code>wrapper</code>函数无法接受右值（如临时对象）。而如果我们改为<code>const T&amp;</code>，又无法传递需要被修改的参数。</p>
<p><font color='cornflowerblue'>完美转发的解决方案</font>:</p>
<p>C++11引入了两个关键组件来解决这个问题：</p>
<ol>
<li><strong>右值引用</strong>：<code>T&amp;&amp;</code></li>
<li><strong>引用折叠规则</strong>和<strong>万能引用(universal reference)</strong></li>
<li><strong>std::forward</strong>函数</li>
</ol>
<p>正确的完美转发包装函数是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper</span><span class="params">(T&amp;&amp; param)</span> </span>&#123;  <span class="comment">// 这里的T&amp;&amp;是万能引用，不是右值引用</span></span><br><span class="line">    <span class="built_in">f</span>(std::forward&lt;T&gt;(param));  <span class="comment">// 完美转发</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color='cornflowerblue'>关键组件详解</font>:</p>
<ul>
<li><strong>万能引用(Universal Reference)</strong></li>
</ul>
<p>当<code>T&amp;&amp;</code>出现在模板参数推导的上下文中时，它不是普通的右值引用，而是”万能引用”，可以绑定到任何值类别的对象上：</p>
<ul>
<li><p>当传入左值时，<code>T</code>被推导为左值引用类型</p>
</li>
<li><p>当传入右值时，<code>T</code>被推导为非引用类型</p>
</li>
<li><p><strong>引用折叠规则</strong></p>
</li>
</ul>
<p>C++11引入了”引用折叠”规则，对于类型<code>T</code>:</p>
<ul>
<li><code>T&amp; &amp;</code> 折叠为 <code>T&amp;</code></li>
<li><code>T&amp; &amp;&amp;</code> 折叠为 <code>T&amp;</code></li>
<li><code>T&amp;&amp; &amp;</code> 折叠为 <code>T&amp;</code></li>
<li><code>T&amp;&amp; &amp;&amp;</code> 折叠为 <code>T&amp;&amp;</code></li>
</ul>
<p>简单说：**只要有一个&amp;，结果就是&amp;**。</p>
<ul>
<li><strong>std::forward的原理</strong></li>
</ul>
<p><code>std::forward</code>是完美转发的核心，其简化实现大致如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp; param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它利用引用折叠规则，确保：</p>
<ul>
<li>如果原始参数是左值，通过<code>forward</code>后仍然是左值</li>
<li>如果原始参数是右值，通过<code>forward</code>后仍然是右值</li>
</ul>
<p><font color='cornflowerblue'>实际例子</font></p>
<p>假设我们要实现一个工厂函数，用于创建对象并转发构造函数的所有参数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;T&gt; <span class="title">make_unique</span><span class="params">(Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">unique_ptr</span>&lt;T&gt;(<span class="keyword">new</span> <span class="built_in">T</span>(std::forward&lt;Args&gt;(args)...));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个实现允许我们完美地转发任何参数到<code>T</code>的构造函数。</p>
<p><font color='cornflowerblue'>注意事项</font></p>
<ol>
<li><p>完美转发</p>
<p>只转发引用类型和值类别</p>
<p>，不转发以下内容：</p>
<ul>
<li>隐式转换</li>
<li>默认参数</li>
<li>函数重载解析的结果</li>
<li>语法糖（如初始化列表）</li>
</ul>
</li>
<li><p>调用<code>std::forward&lt;T&gt;</code>时，<code>T</code>必须准确匹配模板参数推导出的类型，否则会导致错误的行为。</p>
</li>
</ol>
</blockquote>
<p>​	</p>
<p>加了weak_ptr之后的实现可以参考下图，具体代码省略</p>
<img src="Cpp11__inteligent_ptr/image-20250310230603480.png" alt="image-20250310230603480" style="zoom:50%;" />



<h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p><strong>unique_ptr和其管理的动态分配对象必须一对一。</strong></p>
<ul>
<li><p>unique_ptr只有一个原始指针和一个删除器，<strong>占的内存空间和原始裸指针相当</strong></p>
</li>
<li><p>unique_ptr确保同一时间只有一个指针可以管理动态分配的对象，<strong>通过禁用拷贝构造函数和拷贝赋值运算符实现</strong></p>
</li>
<li><p><strong>如果要指定删除器，应当在unique_ptr创建时指定</strong></p>
</li>
<li><p>成员函数get(), release(),</p>
</li>
</ul>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* uniquex_ptr的实现</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Deleter = std::default_delete&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> UniquePtr &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//指向管理对象的原始指针</span></span><br><span class="line">	T* raw_ptr; </span><br><span class="line"></span><br><span class="line">	<span class="comment">//删除器</span></span><br><span class="line">	Deleter deleter;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">UniquePtr</span><span class="params">(T* ptr = <span class="literal">nullptr</span>)</span>: raw_ptr(ptr) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 移动构造函数</span></span><br><span class="line">	<span class="built_in">UniquePtr</span>(UniquePtr&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">raw_ptr</span>(other.raw_ptr) &#123;</span><br><span class="line">		other.raw_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 移动赋值运算符, std::move返回值就是右值，即测试函数中的&quot;=&quot;将会调用该移动拷贝函数</span></span><br><span class="line">	UniquePtr&amp; <span class="keyword">operator</span>=(UniquePtr&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">			<span class="keyword">if</span> (raw_ptr) <span class="built_in">deleter</span>(raw_ptr);</span><br><span class="line">			raw_ptr = other.raw_ptr;</span><br><span class="line">			other.raw_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//析构函数</span></span><br><span class="line">	~<span class="built_in">UniquePtr</span>() &#123;</span><br><span class="line">		<span class="keyword">if</span> (raw_ptr) &#123;</span><br><span class="line">			<span class="comment">//释放对象内存空间</span></span><br><span class="line">			<span class="built_in">deleter</span>(raw_ptr);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关键：禁用赋值拷贝和拷贝构造函数</span></span><br><span class="line">	UniquePtr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> UniquePtr&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">	<span class="built_in">UniquePtr</span>(<span class="type">const</span> UniquePtr&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//运算符重载</span></span><br><span class="line">	T&amp; <span class="keyword">operator</span>*() <span class="type">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> *raw_ptr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	T* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> raw_ptr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//get函数</span></span><br><span class="line">	<span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> raw_ptr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//reset函数,释放原管理对象空间，重置原始指针指向新对象</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(T* uptr = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (raw_ptr) &#123; </span><br><span class="line">			<span class="built_in">deleter</span>(raw_ptr); </span><br><span class="line">		&#125;</span><br><span class="line">		raw_ptr = uptr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//释放所有权release()</span></span><br><span class="line">	<span class="function">T* <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		T* tmp = raw_ptr;</span><br><span class="line">		raw_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>测试用例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简单测试类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> value;</span><br><span class="line">	<span class="built_in">Test</span>(<span class="type">int</span> v) : <span class="built_in">value</span>(v) &#123; std::cout &lt;&lt; <span class="string">&quot;Test(&quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot;) constructed\n&quot;</span>; &#125;</span><br><span class="line">	~<span class="built_in">Test</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Test(&quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot;) destructed\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************unique_ptr测试函数开始***********************/</span></span><br><span class="line">	<span class="comment">// 测试基本功能</span></span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;=== 测试基本功能 ===\n&quot;</span>;</span><br><span class="line">		<span class="function">UniquePtr&lt;Test&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> Test(<span class="number">1</span>))</span></span>;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;p1-&gt;value: &quot;</span> &lt;&lt; p1-&gt;value &lt;&lt; std::endl;</span><br><span class="line">	&#125; <span class="comment">// p1析构，Test(1)也析构</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 测试release</span></span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;\n=== 测试release ===\n&quot;</span>;</span><br><span class="line">		<span class="function">UniquePtr&lt;Test&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> Test(<span class="number">3</span>))</span></span>;</span><br><span class="line">		Test* raw = p<span class="number">1.</span><span class="built_in">release</span>();</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;release后p1是否为空: &quot;</span> &lt;&lt; (p<span class="number">1.</span><span class="built_in">get</span>() == <span class="literal">nullptr</span> ? <span class="string">&quot;是&quot;</span> : <span class="string">&quot;否&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;raw-&gt;value: &quot;</span> &lt;&lt; raw-&gt;value &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">delete</span> raw; <span class="comment">// 手动释放资源</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;\n=== 测试reset函数 ===\n&quot;</span>;</span><br><span class="line">		<span class="function">UniquePtr&lt;Test&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> Test(<span class="number">1</span>))</span></span>;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;原始p1-&gt;value: &quot;</span> &lt;&lt; p1-&gt;value &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 重置为新对象</span></span><br><span class="line">		p<span class="number">1.</span><span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Test</span>(<span class="number">2</span>));</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;reset后p1-&gt;value: &quot;</span> &lt;&lt; p1-&gt;value &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 重置为nullptr</span></span><br><span class="line">		p<span class="number">1.</span><span class="built_in">reset</span>();</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;reset为nullptr后，p1是否为空: &quot;</span> &lt;&lt; (p<span class="number">1.</span><span class="built_in">get</span>() == <span class="literal">nullptr</span> ? <span class="string">&quot;是&quot;</span> : <span class="string">&quot;否&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 测试移动构造</span></span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;\n=== 测试移动构造 ===\n&quot;</span>;</span><br><span class="line">		<span class="function">UniquePtr&lt;Test&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> Test(<span class="number">1</span>))</span></span>;</span><br><span class="line">		<span class="comment">//注意UniquePtr的拷贝赋值运算符重载被禁用了</span></span><br><span class="line">         <span class="comment">//这里std::move将p1转换为右值引用，所以这里会调用移动拷贝复制运算符重载函数</span></span><br><span class="line">		UniquePtr&lt;Test&gt; p2 = std::<span class="built_in">move</span>(p1);</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;移动后p2-&gt;value: &quot;</span> &lt;&lt; p2-&gt;value &lt;&lt; std::endl;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;p1是否为空: &quot;</span> &lt;&lt; (p<span class="number">1.</span><span class="built_in">get</span>() == <span class="literal">nullptr</span> ? <span class="string">&quot;是&quot;</span> : <span class="string">&quot;否&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************unique_ptr测试函数结束***********************/</span></span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">=== 测试基本功能 ===</span><br><span class="line">Test(1) constructed</span><br><span class="line">p1-&gt;value: 1</span><br><span class="line">Test(1) destructed</span><br><span class="line"></span><br><span class="line">=== 测试release ===</span><br><span class="line">Test(3) constructed</span><br><span class="line">release后p1是否为空: 是</span><br><span class="line">raw-&gt;value: 3</span><br><span class="line">Test(3) destructed</span><br><span class="line"></span><br><span class="line">=== 测试reset函数 ===</span><br><span class="line">Test(1) constructed</span><br><span class="line">原始p1-&gt;value: 1</span><br><span class="line">Test(2) constructed</span><br><span class="line">Test(1) destructed</span><br><span class="line">reset后p1-&gt;value: 2</span><br><span class="line">Test(2) destructed</span><br><span class="line">reset为nullptr后，p1是否为空: 是</span><br><span class="line"></span><br><span class="line">=== 测试移动构造 ===</span><br><span class="line">Test(1) constructed</span><br><span class="line">移动后p2-&gt;value: 1</span><br><span class="line">p1是否为空: 是</span><br><span class="line">Test(1) destructed</span><br></pre></td></tr></table></figure>

<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><ul>
<li><p>move函数要加<code>static</code>关键字(在模板类中实现move函数要注意的点，展示的代码用的标准库的move函数)</p>
<blockquote>
<p>原因：</p>
<ul>
<li><p><strong>静态成员函数不属于某个实例，而是属于类</strong>，这意味着它不绑定到特定的 <code>unique_ptr</code> 实例上，也不需要通过特定实例来调用。所以这里才允许使用 <code>unique_ptr&lt;T&gt;::move(ptr)</code> 这样的调用方式，而不是如<code>UniquePtr&lt;Test&gt; p2 = p1.move(p1);</code>这样来调用</p>
</li>
<li><p>将函数定义为静态成员函数可以将其限定在类的作用域内，<strong>避免与全局命名空间中的其他 <code>move</code> 函数冲突。</strong></p>
</li>
</ul>
</blockquote>
</li>
<li><p>移动构造函数及<code>noexcept</code>作用</p>
<blockquote>
<p>移动构造函数(Move Constructor)是C++11中引入的一个特性，它允许在创建新对象时”窃取”已有对象的资源，而不是复制这些资源。</p>
<p>移动构造函数的基本形式是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ClassName</span>(ClassName&amp;&amp; other) <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure>

<p>这里的关键是双引用符号<code>&amp;&amp;</code>，它表示一个右值引用，允许函数接收临时对象或即将被销毁的对象(<strong>都是右值</strong>)。</p>
<p><strong>移动构造函数的主要优点是：</strong></p>
<ol>
<li><strong>提高性能</strong>：对于包含大量数据的对象（如向量、字符串等），<strong>移动比复制快得多。</strong></li>
<li><strong>避免不必要的资源分配和释放</strong>：使用移动语义优化了临时变量创建、复制、转移的过程。</li>
</ol>
<p><strong>补充</strong>：<font color='red'>在移动语义中，一个临时变量的创建、复制、转移过程都被省略优化掉了(拷贝省略优化)</font>，即直接在目标对象的空间中完成构造。<strong>在上面的代码中，并没有实现指针赋值的深拷贝，而在需要深拷贝以避免同一内存多次释放的情况下，使用移动拷贝构造函数和移动拷贝赋值运算符可以避免申请大量资源，从而提高引用程序的效率。</strong></p>
<p>我们在设计和实现类时，对于需要动态申请大量资源的类，应该设计右值引用的拷贝构造函数和赋值函数，以提高应用程序的效率。</p>
<p><strong>noexcept作用</strong></p>
<p><code>noexcept</code> 关键字在 C++ 中用来指定函数不会抛出异常，它有几个重要作用：</p>
<ol>
<li><strong>性能优化</strong>：当编译器知道函数不会抛出异常时，可以生成更高效的代码。特别是对于移动构造函数和移动赋值运算符，标记为 <code>noexcept</code> 可以显著提高性能。</li>
<li><strong>标准容器优化</strong>：标准库容器（如 <code>std::vector</code>）会根据移动操作是否标记为 <code>noexcept</code> 来决定在扩容时使用移动还是复制操作。如果移动构造函数标记为 <code>noexcept</code>，<code>std::vector</code> 会使用移动操作，否则会退回到复制操作以保证异常安全性。</li>
<li><strong>异常安全保证</strong>：向调用者明确表明函数不会抛出异常，有助于编写更可靠的代码和进行异常处理设计。</li>
<li><strong>编译时检查</strong>：编译器会检查标记为 <code>noexcept</code> 的函数是否真的不会抛出异常。如果函数内部可能抛出异常（直接或通过调用可能抛出异常的函数），则会产生编译错误。</li>
</ol>
<p><code>noexcept</code> 可以有两种形式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无条件指定函数不会抛出异常</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有条件指定，表达式为 true 时函数不会抛出异常</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(表达式)</span></span>;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p><strong>weak_ptr主要用来观测shared_ptr所管理的动态分配对象，其不会导致引用计数变化。</strong></p>
<h3 id="标准库的智能指针实战指南"><a href="#标准库的智能指针实战指南" class="headerlink" title="标准库的智能指针实战指南"></a>标准库的智能指针实战指南</h3><h4 id="三大智能指针使用场景"><a href="#三大智能指针使用场景" class="headerlink" title="三大智能指针使用场景"></a>三大智能指针使用场景</h4><h5 id="1-std-unique-ptr-独占所有权"><a href="#1-std-unique-ptr-独占所有权" class="headerlink" title="1. std::unique_ptr - 独占所有权"></a>1. <code>std::unique_ptr</code> - 独占所有权</h5><p>这是你应该最常用的智能指针：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">modernWay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unique_ptr&lt;MyClass&gt; ptr = std::<span class="built_in">make_unique</span>&lt;MyClass&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 无需担心异常，函数结束时自动释放内存</span></span><br><span class="line">    <span class="built_in">doSomething</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 不需要手动delete</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实际使用场景：</strong></p>
<ul>
<li>工厂方法返回新创建的对象</li>
<li>类的私有实现（PIMPL模式）</li>
<li>容器中存储多态对象</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 工厂函数示例</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;Shape&gt; <span class="title">createShape</span><span class="params">(ShapeType type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> ShapeType::Circle:</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;Circle&gt;();</span><br><span class="line">        <span class="keyword">case</span> ShapeType::Rectangle:</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;Rectangle&gt;();</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>几个重要特性：</strong></p>
<ul>
<li>不可复制，只能移动</li>
<li>可以自定义删除器</li>
<li>几乎零开销（与原始指针大小相同）</li>
</ul>
<h5 id="2-std-shared-ptr-共享所有权"><a href="#2-std-shared-ptr-共享所有权" class="headerlink" title="2. std::shared_ptr - 共享所有权"></a>2. <code>std::shared_ptr</code> - 共享所有权</h5><p>当多个对象需要共同拥有某个资源时使用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sharedOwnership</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> sharedResource = std::<span class="built_in">make_shared</span>&lt;LargeObject&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 多个对象可以共享这个资源</span></span><br><span class="line">    worker1-&gt;<span class="built_in">setResource</span>(sharedResource);</span><br><span class="line">    worker2-&gt;<span class="built_in">setResource</span>(sharedResource);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 所有shared_ptr都销毁后，资源才会释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实际使用场景：</strong></p>
<ul>
<li>缓存系统</li>
<li>观察者模式中的主题对象</li>
<li>异步操作中共享的数据</li>
</ul>
<p><strong>使用注意事项：</strong></p>
<ul>
<li>比<code>unique_ptr</code>有更多开销（引用计数）</li>
<li>创建时优先使用<code>std::make_shared</code>（单次内存分配更高效）</li>
<li>避免从同一原始指针创建多个<code>shared_ptr</code></li>
</ul>
<h5 id="3-std-weak-ptr-弱引用"><a href="#3-std-weak-ptr-弱引用" class="headerlink" title="3. std::weak_ptr - 弱引用"></a>3. <code>std::weak_ptr</code> - 弱引用</h5><p><code>weak_ptr</code>不增加引用计数，用于打破循环引用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    std::shared_ptr&lt;Node&gt; next;  <span class="comment">// 强引用</span></span><br><span class="line">    std::weak_ptr&lt;Node&gt; parent;  <span class="comment">// 弱引用，避免循环引用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>实际使用场景：</strong></p>
<ul>
<li>缓存系统（可以被自动回收的缓存）</li>
<li>观察者模式（避免被观察者和观察者之间的循环引用）</li>
<li>父子关系（子对象持有父对象的弱引用）</li>
</ul>
<h4 id="实际工程中的最佳实践"><a href="#实际工程中的最佳实践" class="headerlink" title="实际工程中的最佳实践"></a>实际工程中的最佳实践</h4><h5 id="1-尽量使用make-unique和make-shared"><a href="#1-尽量使用make-unique和make-shared" class="headerlink" title="1. 尽量使用make_unique和make_shared"></a>1. 尽量使用<code>make_unique</code>和<code>make_shared</code></h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">w1</span><span class="params">(<span class="keyword">new</span> Widget(arg1, arg2))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">auto</span> w2 = std::<span class="built_in">make_shared</span>&lt;Widget&gt;(arg1, arg2);</span><br></pre></td></tr></table></figure>

<p>这样做的优势：</p>
<ul>
<li>避免内存泄漏风险（如表达式计算顺序问题）</li>
<li><code>make_shared</code>只分配一次内存（同时分配对象和控制块）</li>
<li>代码更简洁</li>
</ul>
<h5 id="2-处理自定义删除器"><a href="#2-处理自定义删除器" class="headerlink" title="2. 处理自定义删除器"></a>2. 处理自定义删除器</h5><p>有时需要特殊的资源清理逻辑：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件句柄的自定义删除器</span></span><br><span class="line"><span class="keyword">auto</span> fileDeleter = [](FILE* file) &#123; </span><br><span class="line">    <span class="keyword">if</span> (file) <span class="built_in">fclose</span>(file); </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_ptr&lt;FILE, <span class="title">decltype</span><span class="params">(fileDeleter)</span>&gt; </span></span><br><span class="line"><span class="function">    <span class="title">filePtr</span><span class="params">(fopen(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>), fileDeleter)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>实际场景：</strong></p>
<ul>
<li>关闭文件、套接字</li>
<li>释放C库分配的内存</li>
<li>释放系统资源（如Windows中的句柄）</li>
</ul>
<h5 id="3-避免智能指针的常见陷阱"><a href="#3-避免智能指针的常见陷阱" class="headerlink" title="3. 避免智能指针的常见陷阱"></a>3. 避免智能指针的常见陷阱</h5><h6 id="循环引用问题"><a href="#循环引用问题" class="headerlink" title="循环引用问题"></a>循环引用问题</h6><p>这是最常见的问题之一：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;Child&gt; child;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;Parent&gt; parent;  <span class="comment">// 会导致循环引用！</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createObjects</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> parent = std::<span class="built_in">make_shared</span>&lt;Parent&gt;();</span><br><span class="line">    <span class="keyword">auto</span> child = std::<span class="built_in">make_shared</span>&lt;Child&gt;();</span><br><span class="line">    </span><br><span class="line">    parent-&gt;child = child;</span><br><span class="line">    child-&gt;parent = parent;  <span class="comment">// 循环引用形成</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 函数结束，但两个对象都不会被释放！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决方案：使用weak_ptr</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::weak_ptr&lt;Parent&gt; parent;  <span class="comment">// 使用weak_ptr打破循环</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h6 id="从this创建shared-ptr的危险"><a href="#从this创建shared-ptr的危险" class="headerlink" title="从this创建shared_ptr的危险"></a>从this创建shared_ptr的危险</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 危险！可能导致同一对象有两个独立的控制块</span></span><br><span class="line">        <span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">self</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">        worker-&gt;<span class="built_in">enqueue</span>(self);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>解决方案：使用<code>enable_shared_from_this</code></strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> : <span class="keyword">public</span> std::enable_shared_from_this&lt;Widget&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 安全地获取shared_ptr</span></span><br><span class="line">        <span class="keyword">auto</span> self = <span class="built_in">shared_from_this</span>();</span><br><span class="line">        worker-&gt;<span class="built_in">enqueue</span>(self);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h5 id="4-性能考量"><a href="#4-性能考量" class="headerlink" title="4. 性能考量"></a>4. 性能考量</h5><ul>
<li><code>unique_ptr</code>几乎无开销，放心使用</li>
<li><code>shared_ptr</code>有引用计数开销，尤其是频繁复制时</li>
<li>大量小对象使用<code>shared_ptr</code>可能导致内存碎片</li>
<li>避免频繁的<code>shared_ptr</code>复制，考虑传递引用</li>
</ul>
<h5 id="5-针对大型项目的建议"><a href="#5-针对大型项目的建议" class="headerlink" title="5. 针对大型项目的建议"></a>5. 针对大型项目的建议</h5><h6 id="明确所有权策略"><a href="#明确所有权策略" class="headerlink" title="明确所有权策略"></a>明确所有权策略</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数参数中表明所有权语义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processData</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;Data&gt;&amp; data)</span></span>;  <span class="comment">// 共享访问，不获取所有权</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumeData</span><span class="params">(std::unique_ptr&lt;Data&gt; data)</span></span>;  <span class="comment">// 获取独占所有权</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">borrowData</span><span class="params">(Data* data)</span></span>;  <span class="comment">// 临时访问，不涉及所有权</span></span><br></pre></td></tr></table></figure>



<h6 id="在API边界使用原始指针或引用"><a href="#在API边界使用原始指针或引用" class="headerlink" title="在API边界使用原始指针或引用"></a>在API边界使用原始指针或引用</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;Impl&gt; pImpl_;  <span class="comment">// 内部使用智能指针管理生命周期</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// API使用原始引用，不暴露内存管理细节</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">const</span> Data&amp; data)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="实际工程案例"><a href="#实际工程案例" class="headerlink" title="实际工程案例"></a>实际工程案例</h4><h5 id="案例1：资源管理系统"><a href="#案例1：资源管理系统" class="headerlink" title="案例1：资源管理系统"></a>案例1：资源管理系统</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ResourceManager</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 缓存使用weak_ptr，不阻止资源释放</span></span><br><span class="line">    std::unordered_map&lt;std::string, std::weak_ptr&lt;Resource&gt;&gt; resourceCache_;</span><br><span class="line">    std::mutex cacheMutex_;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::shared_ptr&lt;Resource&gt; <span class="title">getResource</span><span class="params">(<span class="type">const</span> std::string&amp; id)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(cacheMutex_)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 尝试从缓存获取</span></span><br><span class="line">        <span class="keyword">auto</span> it = resourceCache_.<span class="built_in">find</span>(id);</span><br><span class="line">        <span class="keyword">if</span> (it != resourceCache_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="comment">// 尝试将weak_ptr提升为shared_ptr</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">auto</span> resource = it-&gt;second.<span class="built_in">lock</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> resource;  <span class="comment">// 缓存命中，返回已有资源</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建新资源</span></span><br><span class="line">        <span class="keyword">auto</span> resource = std::<span class="built_in">make_shared</span>&lt;Resource&gt;(id);</span><br><span class="line">        resourceCache_[id] = resource;  <span class="comment">// 存入缓存</span></span><br><span class="line">        <span class="keyword">return</span> resource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h5 id="案例2：组件系统"><a href="#案例2：组件系统" class="headerlink" title="案例2：组件系统"></a>案例2：组件系统</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameObject</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;std::unique_ptr&lt;Component&gt;&gt; components_;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">    T* <span class="title">addComponent</span><span class="params">(Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> component = std::<span class="built_in">make_unique</span>&lt;T&gt;(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">        T* rawPtr = component.<span class="built_in">get</span>();  <span class="comment">// 保存原始指针用于返回</span></span><br><span class="line">        components_.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(component));</span><br><span class="line">        <span class="keyword">return</span> rawPtr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="keyword">auto</span> gameObject = std::<span class="built_in">make_unique</span>&lt;GameObject&gt;();</span><br><span class="line"><span class="keyword">auto</span> renderer = gameObject-&gt;<span class="built_in">addComponent</span>&lt;RenderComponent&gt;(meshData);</span><br><span class="line"><span class="keyword">auto</span> physics = gameObject-&gt;<span class="built_in">addComponent</span>&lt;PhysicsComponent&gt;(mass, volume);</span><br></pre></td></tr></table></figure>



<h4 id="总结：智能指针使用指南"><a href="#总结：智能指针使用指南" class="headerlink" title="总结：智能指针使用指南"></a>总结：智能指针使用指南</h4><ol>
<li><strong>默认选择<code>unique_ptr</code></strong> - 除非确实需要共享所有权</li>
<li><strong>需要共享所有权时使用<code>shared_ptr</code></strong></li>
<li><strong>处理循环引用时使用<code>weak_ptr</code></strong></li>
<li><strong>始终使用<code>make_</code>函数创建</strong> - <code>std::make_unique</code>和<code>std::make_shared</code></li>
<li><strong>不要混用原始<code>new/delete</code>和智能指针</strong></li>
<li><strong>小心<code>this</code>指针与智能指针的关系</strong> - 需要时继承<code>enable_shared_from_this</code></li>
<li><strong>明确函数参数中的所有权语义</strong></li>
<li><strong>在类中使用智能指针管理资源，在API边界使用引用或原始指针</strong></li>
</ol>
]]></content>
      <categories>
        <category>c++11</category>
        <category>智能指针</category>
      </categories>
  </entry>
  <entry>
    <title>死锁与活锁</title>
    <url>/2025/04/21/conCurrency__muteManage/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>并发</category>
        <category>锁管理</category>
      </categories>
      <tags>
        <tag>死锁</tag>
        <tag>活锁</tag>
      </tags>
  </entry>
  <entry>
    <title>生产者-消费者模式</title>
    <url>/2025/03/07/conCurrency__comsumer&amp;producer/</url>
    <content><![CDATA[<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>在介绍生产者-消费者模式之前，首先讲讲线程与进程的区别，以及互斥锁和条件变量、信号量</p>
<ul>
<li>线程：进程执行流的最小单元</li>
<li>进程：操作系统执行流的最小单元</li>
<li><strong>进程与线程的区别</strong>：<font color='mediumseagreen'>每个进程都有独立的内存空间，因此多进程将耗费大量系统资源，而线程只有栈区是独立的，堆区和数据都是共享的。</font>如下图所示</li>
</ul>
<span id="more"></span>

<p><img src="/thread__comsumer&producer/image-20250307230213904.png" alt="image-20250307230213904"></p>
<ul>
<li><p>线程销毁：在c中使用<code>pthread_detach()</code>来引导线程销毁，一般服务端不使用<code>pthread_join()</code>，因为该函数会一直阻塞等待线程终止，而对于服务端来说是不能这样阻塞的。</p>
</li>
<li><p>互斥锁：主要用于线程安全，可以通过创建互斥锁，并将需要保护的临界区使用<code>lock</code>和<code>unlock</code>围住，<strong>当前线程在执行临界区代码时，其它线程会进入阻塞状态。</strong><font color='red'>防止同一变量被多个线程同时操作，导致混乱</font></p>
</li>
<li><p>条件变量：和互斥锁配合使用，主要用于消费者-生产者模式，实现线程同步</p>
</li>
<li><p>信号量: 定义两个信号量，并将初值分别初始化为0，1，也可以实现线程同步. 调用一次<code>sem_wait()</code>对应的信号量就减1，当信号量值已经为0了，如果又运行到<code>sem_wait()</code>就会阻塞，直到<code>sem_post()</code>运行，给该信号量值+1。</p>
</li>
</ul>
<h2 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h2><p>我们直接通过代码来进行分析</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生产者-消费者问题</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 共享缓冲区</span></span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; buffer;</span><br><span class="line"><span class="comment">// 最大缓冲区大小</span></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> BUFFER_SIZE = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 互斥锁和条件变量</span></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv_producer;</span><br><span class="line">std::condition_variable cv_consumer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者线程函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> product = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待缓冲区有空位</span></span><br><span class="line">        cv_producer.<span class="built_in">wait</span>(lock, []() &#123; <span class="keyword">return</span> buffer.<span class="built_in">size</span>() &lt; BUFFER_SIZE; &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生产数据并放入缓冲区</span></span><br><span class="line">        product++;</span><br><span class="line">        buffer.<span class="built_in">push</span>(product);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Producer &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; produced: &quot;</span> &lt;&lt; product &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知消费者有数据可取</span></span><br><span class="line">        cv_consumer.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放锁，生产间隔一段时间（模拟生产过程）</span></span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者线程函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待缓冲区有数据</span></span><br><span class="line">        cv_consumer.<span class="built_in">wait</span>(lock, []() &#123; <span class="keyword">return</span> !buffer.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费数据</span></span><br><span class="line">        <span class="type">int</span> consumed_product = buffer.<span class="built_in">front</span>();</span><br><span class="line">        buffer.<span class="built_in">pop</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Consumer &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; consumed: &quot;</span> &lt;&lt; consumed_product &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知生产者缓冲区有空位</span></span><br><span class="line">        cv_producer.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放锁，消费间隔一段时间（模拟消费过程）</span></span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">150</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建生产者和消费者线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">producer1</span><span class="params">(producer, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">producer2</span><span class="params">(producer, <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">consumer1</span><span class="params">(consumer, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">consumer2</span><span class="params">(consumer, <span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让主线程等待生产者和消费者线程（通常不会结束）</span></span><br><span class="line">    producer<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    producer<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    consumer<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    consumer<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的输出结果为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Producer 1 produced: 1</span><br><span class="line">Producer 2 produced: 1</span><br><span class="line">Consumer 1 consumed: 1</span><br><span class="line">Consumer 2 consumed: 1</span><br><span class="line">Producer 2 produced: 2</span><br><span class="line">Producer 1 produced: 2</span><br><span class="line">Consumer 1 consumed: 2</span><br><span class="line">Consumer 2 consumed: 2</span><br><span class="line">Producer 1 produced: 3</span><br><span class="line">Producer 2 produced: 3</span><br><span class="line">Consumer 1 consumed: 3</span><br><span class="line">Consumer 2 consumed: 3</span><br><span class="line">Producer 1 produced: 4</span><br><span class="line">Producer 2 produced: 4</span><br><span class="line">.....</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>执行流程</strong></li>
</ul>
<blockquote>
<p><strong><font color='mediumseagreen'>假设消费者先获得锁：</font></strong></p>
<ol>
<li><p>消费者调用<code>std::unique_lock&lt;std::mutex&gt; lock(mtx)</code>获取锁</p>
</li>
<li><p>消费者执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cv_consumer.wait(lock, []() &#123; return !buffer.empty(); &#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>由于<code>buffer.empty()</code>为真，<code>!buffer.empty()</code>为假</li>
<li>消费者会释放锁并进入等待状态</li>
</ul>
</li>
<li><p>此时锁被释放，生产者可以获取锁</p>
</li>
</ol>
<p><strong><font color='mediumseagreen'>生产者获得锁：</font></strong></p>
<ol>
<li><p>生产者调用<code>std::unique_lock&lt;std::mutex&gt; lock(mtx)</code>获取锁</p>
</li>
<li><p>生产者执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cv_producer.wait(lock, []() &#123; return buffer.size() &lt; BUFFER_SIZE; &#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>由于<code>buffer.size() &lt; BUFFER_SIZE</code>为真（缓冲区为空）</li>
<li>生产者不阻塞，继续执行</li>
</ul>
</li>
<li><p>生产者放入数据：<code>buffer.push(product)</code></p>
</li>
<li><p>生产者调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cv_consumer.notify_all()</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>关键点</strong>：这里仅发送通知，不会立即唤醒消费者线程</li>
<li>消费者线程仍在等待状态，只有当锁被释放后才会被唤醒</li>
</ul>
</li>
<li><p>生产者通过<code>lock.unlock()</code>释放锁</p>
</li>
<li><p><strong>这时</strong>消费者线程才会被唤醒并尝试重新获取锁</p>
</li>
</ol>
<p><strong><font color='mediumseagreen'>消费者被唤醒：</font></strong></p>
<ol>
<li><p>消费者获取锁</p>
</li>
<li><p>消费者重新检查条件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">!buffer.empty()</span><br></pre></td></tr></table></figure>

<ul>
<li>由于缓冲区现在有数据，条件为真</li>
</ul>
</li>
<li><p>消费者从缓冲区取出数据并处理</p>
</li>
<li><p>消费者调用<code>cv_producer.notify_all()</code>通知生产者</p>
</li>
<li><p>消费者通过<code>lock.unlock()</code>释放锁</p>
</li>
</ol>
</blockquote>
<p><strong>在这里我们使用了互斥锁保护了临界区</strong>，如下所示，在多线程运行的情况下，通过互斥锁保证了buffer中数据是正常的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//生产者中</span></span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line"><span class="comment">// 等待缓冲区有空位</span></span><br><span class="line">cv_producer.<span class="built_in">wait</span>(lock, []() &#123; <span class="keyword">return</span> buffer.<span class="built_in">size</span>() &lt; BUFFER_SIZE; &#125;);</span><br><span class="line"><span class="comment">// 生产数据并放入缓冲区</span></span><br><span class="line">product++;</span><br><span class="line">buffer.<span class="built_in">push</span>(product);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Producer &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; produced: &quot;</span> &lt;&lt; product &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">// 通知消费者有数据可取</span></span><br><span class="line">cv_consumer.<span class="built_in">notify_all</span>();</span><br><span class="line"><span class="comment">// 释放锁，生产间隔一段时间（模拟生产过程）</span></span><br><span class="line">lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者中</span></span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line"><span class="comment">// 等待缓冲区有数据</span></span><br><span class="line">cv_consumer.<span class="built_in">wait</span>(lock, []() &#123; <span class="keyword">return</span> !buffer.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line"><span class="comment">// 消费数据</span></span><br><span class="line"><span class="type">int</span> consumed_product = buffer.<span class="built_in">front</span>();</span><br><span class="line">buffer.<span class="built_in">pop</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Consumer &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; consumed: &quot;</span> &lt;&lt; consumed_product &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">// 通知生产者缓冲区有空位</span></span><br><span class="line">cv_producer.<span class="built_in">notify_all</span>();</span><br><span class="line"><span class="comment">// 释放锁，消费间隔一段时间（模拟消费过程）</span></span><br><span class="line">lock.<span class="built_in">unlock</span>();</span><br></pre></td></tr></table></figure>

<p>此外，我们还需要注意以下几点：</p>
<blockquote>
<p><strong>条件变量通知后不会立即执行</strong>：当线程A调用<code>notify_all()</code>时，线程B不会立即从等待状态恢复执行。线程B只有在线程A释放锁后才有机会获取锁并检查条件。</p>
<p><strong>条件变量始终与锁配合使用</strong>：</p>
<ul>
<li><code>wait()</code>操作会自动释放锁</li>
<li>被通知唤醒后，线程会重新尝试获取锁</li>
<li>获取锁成功后，会再次检查条件</li>
</ul>
<p><strong>条件变量防止虚假唤醒</strong>：<code>wait()</code>函数的谓词参数(lambda函数)用于防止虚假唤醒。即使线程被错误地唤醒，它也会检查条件是否真的满足。</p>
<p><strong>通知只是发信号，不会立即触发执行</strong>：通知只是告诉等待的线程”可能满足条件了”，被通知的线程仍然需要:</p>
<ul>
<li>等待当前持有锁的线程释放锁</li>
<li>获取锁</li>
<li>重新检查条件是否满足</li>
</ul>
<p><strong>线程的栈区是独立的</strong>，所以两个生产者输出的produced才会是独立的，而其它全局区数据是多线程共享的</p>
</blockquote>
]]></content>
      <categories>
        <category>并发</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>线程同步</tag>
        <tag>线程安全</tag>
      </tags>
  </entry>
  <entry>
    <title>linux常用命令总结</title>
    <url>/2025/04/21/linux_LearningNote01_/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
</search>
